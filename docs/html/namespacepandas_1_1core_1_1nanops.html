<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Poker_Project: Référence de l&#39;espace de nommage pandas.core.nanops</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Poker_Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Chargement...</div>
<div class="SRStatus" id="Searching">Recherche...</div>
<div class="SRStatus" id="NoMatches">Aucune correspondance</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1nanops.html">nanops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Fonctions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Référence de l'espace de nommage pandas.core.nanops</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1nanops_1_1bottleneck__switch.html">bottleneck_switch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1nanops_1_1disallow.html">disallow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:a7ba5b317118c1de15bba9b3f11f653bf" id="r_a7ba5b317118c1de15bba9b3f11f653bf"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a7ba5b317118c1de15bba9b3f11f653bf">set_use_bottleneck</a> (bool v=True)</td></tr>
<tr class="separator:a7ba5b317118c1de15bba9b3f11f653bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94cc62c215f7594bd93ab4330666f5c" id="r_aa94cc62c215f7594bd93ab4330666f5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#aa94cc62c215f7594bd93ab4330666f5c">_bn_ok_dtype</a> (DtypeObj dtype, str name)</td></tr>
<tr class="separator:aa94cc62c215f7594bd93ab4330666f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924fff4e8357429260f7862406675752" id="r_a924fff4e8357429260f7862406675752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a924fff4e8357429260f7862406675752">_has_infs</a> (result)</td></tr>
<tr class="separator:a924fff4e8357429260f7862406675752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ca211d3f9a354cb5cf86b398b401d5" id="r_af8ca211d3f9a354cb5cf86b398b401d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#af8ca211d3f9a354cb5cf86b398b401d5">_get_fill_value</a> (DtypeObj dtype, Scalar|None fill_value=None, fill_value_typ=None)</td></tr>
<tr class="separator:af8ca211d3f9a354cb5cf86b398b401d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf21a9381a322f32d8a0d411e0f9c4f1" id="r_acf21a9381a322f32d8a0d411e0f9c4f1"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#acf21a9381a322f32d8a0d411e0f9c4f1">_maybe_get_mask</a> (np.ndarray values, bool skipna, npt.NDArray[np.bool_]|None mask)</td></tr>
<tr class="separator:acf21a9381a322f32d8a0d411e0f9c4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7750a24661b63a60b1cfe45409d71347" id="r_a7750a24661b63a60b1cfe45409d71347"><td class="memItemLeft" align="right" valign="top">tuple[np.ndarray, npt.NDArray[np.bool_]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a7750a24661b63a60b1cfe45409d71347">_get_values</a> (np.ndarray values, bool skipna, Any fill_value=None, str|None fill_value_typ=None, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a7750a24661b63a60b1cfe45409d71347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d209253c580410d836050026a2ee5c4" id="r_a1d209253c580410d836050026a2ee5c4"><td class="memItemLeft" align="right" valign="top">np.dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a1d209253c580410d836050026a2ee5c4">_get_dtype_max</a> (np.dtype dtype)</td></tr>
<tr class="separator:a1d209253c580410d836050026a2ee5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3d7b7d7dd3a421376a05cfc3a62d14" id="r_a9f3d7b7d7dd3a421376a05cfc3a62d14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a9f3d7b7d7dd3a421376a05cfc3a62d14">_na_ok_dtype</a> (DtypeObj dtype)</td></tr>
<tr class="separator:a9f3d7b7d7dd3a421376a05cfc3a62d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926c4951718f784bc7072a0d2f37c84a" id="r_a926c4951718f784bc7072a0d2f37c84a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a926c4951718f784bc7072a0d2f37c84a">_wrap_results</a> (result, np.dtype dtype, fill_value=None)</td></tr>
<tr class="separator:a926c4951718f784bc7072a0d2f37c84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6a1c4d87eff10bfeeeb0924cce9b88" id="r_a2b6a1c4d87eff10bfeeeb0924cce9b88"><td class="memItemLeft" align="right" valign="top">F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a2b6a1c4d87eff10bfeeeb0924cce9b88">_datetimelike_compat</a> (F func)</td></tr>
<tr class="separator:a2b6a1c4d87eff10bfeeeb0924cce9b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e45c3199612b0af815c2dc75bf05d0c" id="r_a3e45c3199612b0af815c2dc75bf05d0c"><td class="memItemLeft" align="right" valign="top">Scalar|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a3e45c3199612b0af815c2dc75bf05d0c">_na_for_min_count</a> (np.ndarray values, AxisInt|None axis)</td></tr>
<tr class="separator:a3e45c3199612b0af815c2dc75bf05d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142d0573cb84be54a4f444476b574e11" id="r_a142d0573cb84be54a4f444476b574e11"><td class="memItemLeft" align="right" valign="top">F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a142d0573cb84be54a4f444476b574e11">maybe_operate_rowwise</a> (F func)</td></tr>
<tr class="separator:a142d0573cb84be54a4f444476b574e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3309db9d87848009d7bc1bd1fbb6ea12" id="r_a3309db9d87848009d7bc1bd1fbb6ea12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a3309db9d87848009d7bc1bd1fbb6ea12">nanany</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a3309db9d87848009d7bc1bd1fbb6ea12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baeeb6d5a55a8f82d1d340566b6dccf" id="r_a5baeeb6d5a55a8f82d1d340566b6dccf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a5baeeb6d5a55a8f82d1d340566b6dccf">nanall</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a5baeeb6d5a55a8f82d1d340566b6dccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0cb58727011947abe4db87c9a15995" id="r_aff0cb58727011947abe4db87c9a15995"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#aff0cb58727011947abe4db87c9a15995">nansum</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, int min_count=0, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:aff0cb58727011947abe4db87c9a15995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe51baf9fd064e9389b5b72f1dad39c" id="r_adbe51baf9fd064e9389b5b72f1dad39c"><td class="memItemLeft" align="right" valign="top">np.ndarray|np.datetime64|np.timedelta64|NaTType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#adbe51baf9fd064e9389b5b72f1dad39c">_mask_datetimelike_result</a> (np.ndarray|np.datetime64|np.timedelta64 result, AxisInt|None axis, npt.NDArray[np.bool_] mask, np.ndarray orig_values)</td></tr>
<tr class="separator:adbe51baf9fd064e9389b5b72f1dad39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168a1c4fae3e35839c21e44d44119135" id="r_a168a1c4fae3e35839c21e44d44119135"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a168a1c4fae3e35839c21e44d44119135">nanmean</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a168a1c4fae3e35839c21e44d44119135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2982b6830dd4e8e0f14d4cbacdaeffd9" id="r_a2982b6830dd4e8e0f14d4cbacdaeffd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a2982b6830dd4e8e0f14d4cbacdaeffd9">nanmedian</a> (values, *AxisInt|None axis=None, bool skipna=True, mask=None)</td></tr>
<tr class="separator:a2982b6830dd4e8e0f14d4cbacdaeffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cde3e3d0b8c5a2f653ada0db010fc66" id="r_a2cde3e3d0b8c5a2f653ada0db010fc66"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a2cde3e3d0b8c5a2f653ada0db010fc66">_get_empty_reduction_result</a> (Shape shape, AxisInt axis)</td></tr>
<tr class="separator:a2cde3e3d0b8c5a2f653ada0db010fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb71bf9b0a9c7201d1db44c2248540e" id="r_aceb71bf9b0a9c7201d1db44c2248540e"><td class="memItemLeft" align="right" valign="top">tuple[float|np.ndarray, float|np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#aceb71bf9b0a9c7201d1db44c2248540e">_get_counts_nanvar</a> (Shape values_shape, npt.NDArray[np.bool_]|None mask, AxisInt|None axis, int ddof, np.dtype dtype=np.dtype(np.float64))</td></tr>
<tr class="separator:aceb71bf9b0a9c7201d1db44c2248540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c4928fc13111dbcf6247536c1b9c2d" id="r_a21c4928fc13111dbcf6247536c1b9c2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a21c4928fc13111dbcf6247536c1b9c2d">nanstd</a> (values, *AxisInt|None axis=None, bool skipna=True, int ddof=1, mask=None)</td></tr>
<tr class="separator:a21c4928fc13111dbcf6247536c1b9c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445b38d63c0e5acc5928f94bb43a3787" id="r_a445b38d63c0e5acc5928f94bb43a3787"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a445b38d63c0e5acc5928f94bb43a3787">nanvar</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, int ddof=1, mask=None)</td></tr>
<tr class="separator:a445b38d63c0e5acc5928f94bb43a3787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12034563649d1a56f18c62181fba3d18" id="r_a12034563649d1a56f18c62181fba3d18"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a12034563649d1a56f18c62181fba3d18">nansem</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, int ddof=1, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a12034563649d1a56f18c62181fba3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93045b765aeff3805cabfa2720d7a143" id="r_a93045b765aeff3805cabfa2720d7a143"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a93045b765aeff3805cabfa2720d7a143">_nanminmax</a> (meth, fill_value_typ)</td></tr>
<tr class="separator:a93045b765aeff3805cabfa2720d7a143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6890134a5138efe54e26e72403ce76" id="r_a0e6890134a5138efe54e26e72403ce76"><td class="memItemLeft" align="right" valign="top">int|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a0e6890134a5138efe54e26e72403ce76">nanargmax</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a0e6890134a5138efe54e26e72403ce76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8ba31c8c06e13d4f3325f9fd1d6be6" id="r_aff8ba31c8c06e13d4f3325f9fd1d6be6"><td class="memItemLeft" align="right" valign="top">int|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#aff8ba31c8c06e13d4f3325f9fd1d6be6">nanargmin</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:aff8ba31c8c06e13d4f3325f9fd1d6be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1063388926939f4a636fd9bff9b28481" id="r_a1063388926939f4a636fd9bff9b28481"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a1063388926939f4a636fd9bff9b28481">nanskew</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a1063388926939f4a636fd9bff9b28481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597697d9c6edbe8bcff32e17944bae6d" id="r_a597697d9c6edbe8bcff32e17944bae6d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a597697d9c6edbe8bcff32e17944bae6d">nankurt</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a597697d9c6edbe8bcff32e17944bae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d67520cb32daba37b5d2d90ac7fd1d" id="r_a14d67520cb32daba37b5d2d90ac7fd1d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a14d67520cb32daba37b5d2d90ac7fd1d">nanprod</a> (np.ndarray values, *AxisInt|None axis=None, bool skipna=True, int min_count=0, npt.NDArray[np.bool_]|None mask=None)</td></tr>
<tr class="separator:a14d67520cb32daba37b5d2d90ac7fd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7a030713f87d42d60a1c8ede76b293" id="r_a7c7a030713f87d42d60a1c8ede76b293"><td class="memItemLeft" align="right" valign="top">np.ndarray|int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a7c7a030713f87d42d60a1c8ede76b293">_maybe_arg_null_out</a> (np.ndarray result, AxisInt|None axis, npt.NDArray[np.bool_]|None mask, bool skipna)</td></tr>
<tr class="separator:a7c7a030713f87d42d60a1c8ede76b293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aae6c5bd56f8aa75fe71dc381ebbe5c" id="r_a4aae6c5bd56f8aa75fe71dc381ebbe5c"><td class="memItemLeft" align="right" valign="top">np.floating|npt.NDArray[np.floating]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a4aae6c5bd56f8aa75fe71dc381ebbe5c">_get_counts</a> (Shape values_shape, npt.NDArray[np.bool_]|None mask, AxisInt|None axis, np.dtype[np.floating] dtype=np.dtype(np.float64))</td></tr>
<tr class="separator:a4aae6c5bd56f8aa75fe71dc381ebbe5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd3611b1b110ef765e80080d677866b" id="r_a3cd3611b1b110ef765e80080d677866b"><td class="memItemLeft" align="right" valign="top">np.ndarray|float|NaTType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a3cd3611b1b110ef765e80080d677866b">_maybe_null_out</a> (np.ndarray|float|NaTType result, AxisInt|None axis, npt.NDArray[np.bool_]|None mask, tuple[int,...] shape, int min_count=1)</td></tr>
<tr class="separator:a3cd3611b1b110ef765e80080d677866b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328f3af29479e82a52cc5f3d3ae08763" id="r_a328f3af29479e82a52cc5f3d3ae08763"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a328f3af29479e82a52cc5f3d3ae08763">check_below_min_count</a> (tuple[int,...] shape, npt.NDArray[np.bool_]|None mask, int min_count)</td></tr>
<tr class="separator:a328f3af29479e82a52cc5f3d3ae08763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f47c0d8a7b3a36de8b219c8aa49d72" id="r_a16f47c0d8a7b3a36de8b219c8aa49d72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a16f47c0d8a7b3a36de8b219c8aa49d72">_zero_out_fperr</a> (arg)</td></tr>
<tr class="separator:a16f47c0d8a7b3a36de8b219c8aa49d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdac9427ff98622a40eadbf79c6944b4" id="r_afdac9427ff98622a40eadbf79c6944b4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#afdac9427ff98622a40eadbf79c6944b4">nancorr</a> (np.ndarray a, np.ndarray b, *CorrelationMethod method=&quot;pearson&quot;, int|None min_periods=None)</td></tr>
<tr class="separator:afdac9427ff98622a40eadbf79c6944b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19358270e13bec4c7711e487d71e69ea" id="r_a19358270e13bec4c7711e487d71e69ea"><td class="memItemLeft" align="right" valign="top">Callable[[np.ndarray, np.ndarray], float]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a19358270e13bec4c7711e487d71e69ea">get_corr_func</a> (CorrelationMethod method)</td></tr>
<tr class="separator:a19358270e13bec4c7711e487d71e69ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f54b35a6617784f3aaab2f1060263a" id="r_af7f54b35a6617784f3aaab2f1060263a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#af7f54b35a6617784f3aaab2f1060263a">nancov</a> (np.ndarray a, np.ndarray b, *int|None min_periods=None, int|None ddof=1)</td></tr>
<tr class="separator:af7f54b35a6617784f3aaab2f1060263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14df2879e27a3fdd5b9889f9b07bb7a" id="r_aa14df2879e27a3fdd5b9889f9b07bb7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#aa14df2879e27a3fdd5b9889f9b07bb7a">_ensure_numeric</a> (x)</td></tr>
<tr class="separator:aa14df2879e27a3fdd5b9889f9b07bb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41fd84812b523fee95d4d87f1b40e35" id="r_ac41fd84812b523fee95d4d87f1b40e35"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#ac41fd84812b523fee95d4d87f1b40e35">na_accum_func</a> (ArrayLike values, accum_func, *bool skipna)</td></tr>
<tr class="separator:ac41fd84812b523fee95d4d87f1b40e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a566357757bc906d3485ee21672f17e0e" id="r_a566357757bc906d3485ee21672f17e0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a566357757bc906d3485ee21672f17e0e">bn</a> = import_optional_dependency(&quot;bottleneck&quot;, errors=&quot;warn&quot;)</td></tr>
<tr class="separator:a566357757bc906d3485ee21672f17e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af834bffa987e3ae366d6e953fd4337fb" id="r_af834bffa987e3ae366d6e953fd4337fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#af834bffa987e3ae366d6e953fd4337fb">_BOTTLENECK_INSTALLED</a> = <a class="el" href="namespacepandas_1_1core_1_1nanops.html#a566357757bc906d3485ee21672f17e0e">bn</a> is not None</td></tr>
<tr class="separator:af834bffa987e3ae366d6e953fd4337fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f162fe703abaee698d911864d454f8" id="r_a40f162fe703abaee698d911864d454f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a40f162fe703abaee698d911864d454f8">_USE_BOTTLENECK</a> = False</td></tr>
<tr class="separator:a40f162fe703abaee698d911864d454f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d06ee1140b9e48e55b314d5039bb29" id="r_a33d06ee1140b9e48e55b314d5039bb29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#a33d06ee1140b9e48e55b314d5039bb29">nanmin</a> = <a class="el" href="namespacepandas_1_1core_1_1nanops.html#a93045b765aeff3805cabfa2720d7a143">_nanminmax</a>(&quot;min&quot;, fill_value_typ=&quot;+inf&quot;)</td></tr>
<tr class="separator:a33d06ee1140b9e48e55b314d5039bb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9e1a5ebdbb93674e992b54b31c72e4" id="r_abd9e1a5ebdbb93674e992b54b31c72e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1nanops.html#abd9e1a5ebdbb93674e992b54b31c72e4">nanmax</a> = <a class="el" href="namespacepandas_1_1core_1_1nanops.html#a93045b765aeff3805cabfa2720d7a143">_nanminmax</a>(&quot;max&quot;, fill_value_typ=&quot;-inf&quot;)</td></tr>
<tr class="separator:abd9e1a5ebdbb93674e992b54b31c72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentation des fonctions</h2>
<a id="aa94cc62c215f7594bd93ab4330666f5c" name="aa94cc62c215f7594bd93ab4330666f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94cc62c215f7594bd93ab4330666f5c">&#9670;&#160;</a></span>_bn_ok_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.nanops._bn_ok_dtype </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b6a1c4d87eff10bfeeeb0924cce9b88" name="a2b6a1c4d87eff10bfeeeb0924cce9b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6a1c4d87eff10bfeeeb0924cce9b88">&#9670;&#160;</a></span>_datetimelike_compat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> F pandas.core.nanops._datetimelike_compat </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If we have datetime64 or timedelta64 values, ensure we have a correct
mask before calling the wrapped function, then cast back afterwards.
</pre> 
</div>
</div>
<a id="aa14df2879e27a3fdd5b9889f9b07bb7a" name="aa14df2879e27a3fdd5b9889f9b07bb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14df2879e27a3fdd5b9889f9b07bb7a">&#9670;&#160;</a></span>_ensure_numeric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops._ensure_numeric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aae6c5bd56f8aa75fe71dc381ebbe5c" name="a4aae6c5bd56f8aa75fe71dc381ebbe5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aae6c5bd56f8aa75fe71dc381ebbe5c">&#9670;&#160;</a></span>_get_counts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.floating | npt.NDArray[np.floating] pandas.core.nanops._get_counts </td>
          <td>(</td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>values_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt | None&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype[np.floating] &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>np.dtype(np.float64)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the count of non-null values along an axis

Parameters
----------
values_shape : tuple of int
    shape tuple from values ndarray, used if mask is None
mask : Optional[ndarray[bool]]
    locations in values that should be considered missing
axis : Optional[int]
    axis to count along
dtype : type, optional
    type to use for count

Returns
-------
count : scalar or array
</pre> 
</div>
</div>
<a id="aceb71bf9b0a9c7201d1db44c2248540e" name="aceb71bf9b0a9c7201d1db44c2248540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceb71bf9b0a9c7201d1db44c2248540e">&#9670;&#160;</a></span>_get_counts_nanvar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[float | np.ndarray, float | np.ndarray] pandas.core.nanops._get_counts_nanvar </td>
          <td>(</td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>values_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt | None&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ddof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>np.dtype(np.float64)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the count of non-null values along an axis, accounting
for degrees of freedom.

Parameters
----------
values_shape : Tuple[int, ...]
    shape tuple from values ndarray, used if mask is None
mask : Optional[ndarray[bool]]
    locations in values that should be considered missing
axis : Optional[int]
    axis to count along
ddof : int
    degrees of freedom
dtype : type, optional
    type to use for count

Returns
-------
count : int, np.nan or np.ndarray
d : int, np.nan or np.ndarray
</pre> 
</div>
</div>
<a id="a1d209253c580410d836050026a2ee5c4" name="a1d209253c580410d836050026a2ee5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d209253c580410d836050026a2ee5c4">&#9670;&#160;</a></span>_get_dtype_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.dtype pandas.core.nanops._get_dtype_max </td>
          <td>(</td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cde3e3d0b8c5a2f653ada0db010fc66" name="a2cde3e3d0b8c5a2f653ada0db010fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cde3e3d0b8c5a2f653ada0db010fc66">&#9670;&#160;</a></span>_get_empty_reduction_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.nanops._get_empty_reduction_result </td>
          <td>(</td>
          <td class="paramtype">Shape&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The result from a reduction on an empty ndarray.

Parameters
----------
shape : Tuple[int, ...]
axis : int

Returns
-------
np.ndarray
</pre> 
</div>
</div>
<a id="af8ca211d3f9a354cb5cf86b398b401d5" name="af8ca211d3f9a354cb5cf86b398b401d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ca211d3f9a354cb5cf86b398b401d5">&#9670;&#160;</a></span>_get_fill_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops._get_fill_value </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar | None &#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value_typ</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">return the correct fill value for the dtype of the values</pre> 
</div>
</div>
<a id="a7750a24661b63a60b1cfe45409d71347" name="a7750a24661b63a60b1cfe45409d71347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7750a24661b63a60b1cfe45409d71347">&#9670;&#160;</a></span>_get_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[np.ndarray, npt.NDArray[np.bool_] | None] pandas.core.nanops._get_values </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipna</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any &#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | None &#160;</td>
          <td class="paramname"><em>fill_value_typ</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Utility to get the values view, mask, dtype, dtype_max, and fill_value.

If both mask and fill_value/fill_value_typ are not None and skipna is True,
the values array will be copied.

For input arrays of boolean or integer dtypes, copies will only occur if a
precomputed mask, a fill_value/fill_value_typ, and skipna=True are
provided.

Parameters
----------
values : ndarray
    input array to potentially compute mask for
skipna : bool
    boolean for whether NaNs should be skipped
fill_value : Any
    value to fill NaNs with
fill_value_typ : str
    Set to '+inf' or '-inf' to handle dtype-specific infinities
mask : Optional[np.ndarray[bool]]
    nan-mask if known

Returns
-------
values : ndarray
    Potential copy of input value array
mask : Optional[ndarray[bool]]
    Mask for values, if deemed necessary to compute
</pre> 
</div>
</div>
<a id="a924fff4e8357429260f7862406675752" name="a924fff4e8357429260f7862406675752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924fff4e8357429260f7862406675752">&#9670;&#160;</a></span>_has_infs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.nanops._has_infs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbe51baf9fd064e9389b5b72f1dad39c" name="adbe51baf9fd064e9389b5b72f1dad39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe51baf9fd064e9389b5b72f1dad39c">&#9670;&#160;</a></span>_mask_datetimelike_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | np.datetime64 | np.timedelta64 | NaTType pandas.core.nanops._mask_datetimelike_result </td>
          <td>(</td>
          <td class="paramtype">np.ndarray | np.datetime64 | np.timedelta64&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt | None&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_]&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>orig_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c7a030713f87d42d60a1c8ede76b293" name="a7c7a030713f87d42d60a1c8ede76b293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7a030713f87d42d60a1c8ede76b293">&#9670;&#160;</a></span>_maybe_arg_null_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | int pandas.core.nanops._maybe_arg_null_out </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt | None&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipna</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf21a9381a322f32d8a0d411e0f9c4f1" name="acf21a9381a322f32d8a0d411e0f9c4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf21a9381a322f32d8a0d411e0f9c4f1">&#9670;&#160;</a></span>_maybe_get_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] | None pandas.core.nanops._maybe_get_mask </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipna</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None
&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute a mask if and only if necessary.

This function will compute a mask iff it is necessary. Otherwise,
return the provided mask (potentially None) when a mask does not need to be
computed.

A mask is never necessary if the values array is of boolean or integer
dtypes, as these are incapable of storing NaNs. If passing a NaN-capable
dtype that is interpretable as either boolean or integer data (eg,
timedelta64), a mask must be provided.

If the skipna parameter is False, a new mask will not be computed.

The mask is computed using isna() by default. Setting invert=True selects
notna() as the masking function.

Parameters
----------
values : ndarray
    input array to potentially compute mask for
skipna : bool
    boolean for whether NaNs should be skipped
mask : Optional[ndarray]
    nan-mask if known

Returns
-------
Optional[np.ndarray[bool]]
</pre> 
</div>
</div>
<a id="a3cd3611b1b110ef765e80080d677866b" name="a3cd3611b1b110ef765e80080d677866b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd3611b1b110ef765e80080d677866b">&#9670;&#160;</a></span>_maybe_null_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray | float | NaTType pandas.core.nanops._maybe_null_out </td>
          <td>(</td>
          <td class="paramtype">np.ndarray | float | NaTType&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt | None&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple[int, ...]&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns
-------
Dtype
    The product of all elements on a given axis. ( NaNs are treated as 1)
</pre> 
</div>
</div>
<a id="a3e45c3199612b0af815c2dc75bf05d0c" name="a3e45c3199612b0af815c2dc75bf05d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e45c3199612b0af815c2dc75bf05d0c">&#9670;&#160;</a></span>_na_for_min_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Scalar | np.ndarray pandas.core.nanops._na_for_min_count </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AxisInt | None&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the missing value for `values`.

Parameters
----------
values : ndarray
axis : int or None
    axis for the reduction, required if values.ndim &gt; 1.

Returns
-------
result : scalar or ndarray
    For 1-D values, returns a scalar of the correct missing type.
    For 2-D values, returns a 1-D array where each element is missing.
</pre> 
</div>
</div>
<a id="a9f3d7b7d7dd3a421376a05cfc3a62d14" name="a9f3d7b7d7dd3a421376a05cfc3a62d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3d7b7d7dd3a421376a05cfc3a62d14">&#9670;&#160;</a></span>_na_ok_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.nanops._na_ok_dtype </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93045b765aeff3805cabfa2720d7a143" name="a93045b765aeff3805cabfa2720d7a143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93045b765aeff3805cabfa2720d7a143">&#9670;&#160;</a></span>_nanminmax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops._nanminmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>meth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value_typ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a926c4951718f784bc7072a0d2f37c84a" name="a926c4951718f784bc7072a0d2f37c84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926c4951718f784bc7072a0d2f37c84a">&#9670;&#160;</a></span>_wrap_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops._wrap_results </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.dtype&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">wrap our results if needed</pre> 
</div>
</div>
<a id="a16f47c0d8a7b3a36de8b219c8aa49d72" name="a16f47c0d8a7b3a36de8b219c8aa49d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f47c0d8a7b3a36de8b219c8aa49d72">&#9670;&#160;</a></span>_zero_out_fperr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops._zero_out_fperr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a328f3af29479e82a52cc5f3d3ae08763" name="a328f3af29479e82a52cc5f3d3ae08763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328f3af29479e82a52cc5f3d3ae08763">&#9670;&#160;</a></span>check_below_min_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.nanops.check_below_min_count </td>
          <td>(</td>
          <td class="paramtype">tuple[int, ...]&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
&#160;</td>
          <td class="paramname"><em>min_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check for the `min_count` keyword. Returns True if below `min_count` (when
missing value should be returned from the reduction).

Parameters
----------
shape : tuple
    The shape of the values (`values.shape`).
mask : ndarray[bool] or None
    Boolean numpy array (typically of same shape as `shape`) or None.
min_count : int
    Keyword passed through from sum/prod call.

Returns
-------
bool
</pre> 
</div>
</div>
<a id="a19358270e13bec4c7711e487d71e69ea" name="a19358270e13bec4c7711e487d71e69ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19358270e13bec4c7711e487d71e69ea">&#9670;&#160;</a></span>get_corr_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Callable[[np.ndarray, np.ndarray], float] pandas.core.nanops.get_corr_func </td>
          <td>(</td>
          <td class="paramtype">CorrelationMethod&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a142d0573cb84be54a4f444476b574e11" name="a142d0573cb84be54a4f444476b574e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142d0573cb84be54a4f444476b574e11">&#9670;&#160;</a></span>maybe_operate_rowwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> F pandas.core.nanops.maybe_operate_rowwise </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">NumPy operations on C-contiguous ndarrays with axis=1 can be
very slow if axis 1 &gt;&gt; axis 0.
Operate row-by-row and concatenate the results.
</pre> 
</div>
</div>
<a id="ac41fd84812b523fee95d4d87f1b40e35" name="ac41fd84812b523fee95d4d87f1b40e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41fd84812b523fee95d4d87f1b40e35">&#9670;&#160;</a></span>na_accum_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.nanops.na_accum_func </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>accum_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool&#160;</td>
          <td class="paramname"><em>skipna</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cumulative function with skipna support.

Parameters
----------
values : np.ndarray or ExtensionArray
accum_func : {np.cumprod, np.maximum.accumulate, np.cumsum, np.minimum.accumulate}
skipna : bool

Returns
-------
np.ndarray or ExtensionArray
</pre> 
</div>
</div>
<a id="a5baeeb6d5a55a8f82d1d340566b6dccf" name="a5baeeb6d5a55a8f82d1d340566b6dccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baeeb6d5a55a8f82d1d340566b6dccf">&#9670;&#160;</a></span>nanall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.nanops.nanall </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if all elements along an axis evaluate to True.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : bool

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, 2, np.nan])
&gt;&gt;&gt; nanops.nanall(s.values)
True

&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, 0])
&gt;&gt;&gt; nanops.nanall(s.values)
False
</pre> 
</div>
</div>
<a id="a3309db9d87848009d7bc1bd1fbb6ea12" name="a3309db9d87848009d7bc1bd1fbb6ea12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3309db9d87848009d7bc1bd1fbb6ea12">&#9670;&#160;</a></span>nanany()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.nanops.nanany </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if any elements along an axis evaluate to True.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : bool

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, 2])
&gt;&gt;&gt; nanops.nanany(s.values)
True

&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([np.nan])
&gt;&gt;&gt; nanops.nanany(s.values)
False
</pre> 
</div>
</div>
<a id="a0e6890134a5138efe54e26e72403ce76" name="a0e6890134a5138efe54e26e72403ce76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6890134a5138efe54e26e72403ce76">&#9670;&#160;</a></span>nanargmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | np.ndarray pandas.core.nanops.nanargmax </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : int or ndarray[int]
    The index/indices  of max value in specified axis or -1 in the NA case

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; arr = np.array([1, 2, 3, np.nan, 4])
&gt;&gt;&gt; nanops.nanargmax(arr)
4

&gt;&gt;&gt; arr = np.array(range(12), dtype=np.float64).reshape(4, 3)
&gt;&gt;&gt; arr[2:, 2] = np.nan
&gt;&gt;&gt; arr
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7., nan],
       [ 9., 10., nan]])
&gt;&gt;&gt; nanops.nanargmax(arr, axis=1)
array([2, 2, 1, 1])
</pre> 
</div>
</div>
<a id="aff8ba31c8c06e13d4f3325f9fd1d6be6" name="aff8ba31c8c06e13d4f3325f9fd1d6be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8ba31c8c06e13d4f3325f9fd1d6be6">&#9670;&#160;</a></span>nanargmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int | np.ndarray pandas.core.nanops.nanargmin </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : int or ndarray[int]
    The index/indices of min value in specified axis or -1 in the NA case

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; arr = np.array([1, 2, 3, np.nan, 4])
&gt;&gt;&gt; nanops.nanargmin(arr)
0

&gt;&gt;&gt; arr = np.array(range(12), dtype=np.float64).reshape(4, 3)
&gt;&gt;&gt; arr[2:, 0] = np.nan
&gt;&gt;&gt; arr
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [nan,  7.,  8.],
       [nan, 10., 11.]])
&gt;&gt;&gt; nanops.nanargmin(arr, axis=1)
array([0, 0, 1, 1])
</pre> 
</div>
</div>
<a id="afdac9427ff98622a40eadbf79c6944b4" name="afdac9427ff98622a40eadbf79c6944b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdac9427ff98622a40eadbf79c6944b4">&#9670;&#160;</a></span>nancorr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nancorr </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*CorrelationMethod &#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;pearson&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>min_periods</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">a, b: ndarrays
</pre> 
</div>
</div>
<a id="af7f54b35a6617784f3aaab2f1060263a" name="af7f54b35a6617784f3aaab2f1060263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f54b35a6617784f3aaab2f1060263a">&#9670;&#160;</a></span>nancov()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nancov </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*int | None &#160;</td>
          <td class="paramname"><em>min_periods</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a597697d9c6edbe8bcff32e17944bae6d" name="a597697d9c6edbe8bcff32e17944bae6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597697d9c6edbe8bcff32e17944bae6d">&#9670;&#160;</a></span>nankurt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nankurt </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the sample excess kurtosis

The statistic computed here is the adjusted Fisher-Pearson standardized
moment coefficient G2, computed directly from the second and fourth
central moment.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float64
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, np.nan, 1, 3, 2])
&gt;&gt;&gt; nanops.nankurt(s.values)
-1.2892561983471076
</pre> 
</div>
</div>
<a id="a168a1c4fae3e35839c21e44d44119135" name="a168a1c4fae3e35839c21e44d44119135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168a1c4fae3e35839c21e44d44119135">&#9670;&#160;</a></span>nanmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nanmean </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the mean of the element along an axis ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, 2, np.nan])
&gt;&gt;&gt; nanops.nanmean(s.values)
1.5
</pre> 
</div>
</div>
<a id="a2982b6830dd4e8e0f14d4cbacdaeffd9" name="a2982b6830dd4e8e0f14d4cbacdaeffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2982b6830dd4e8e0f14d4cbacdaeffd9">&#9670;&#160;</a></span>nanmedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops.nanmedian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 2])
&gt;&gt;&gt; nanops.nanmedian(s.values)
2.0
</pre> 
</div>
</div>
<a id="a14d67520cb32daba37b5d2d90ac7fd1d" name="a14d67520cb32daba37b5d2d90ac7fd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d67520cb32daba37b5d2d90ac7fd1d">&#9670;&#160;</a></span>nanprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nanprod </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
values : ndarray[dtype]
axis : int, optional
skipna : bool, default True
min_count: int, default 0
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
Dtype
    The product of all elements on a given axis. ( NaNs are treated as 1)

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, 2, 3, np.nan])
&gt;&gt;&gt; nanops.nanprod(s.values)
6.0
</pre> 
</div>
</div>
<a id="a12034563649d1a56f18c62181fba3d18" name="a12034563649d1a56f18c62181fba3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12034563649d1a56f18c62181fba3d18">&#9670;&#160;</a></span>nansem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nansem </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the standard error in the mean along given axis while ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
ddof : int, default 1
    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
    where N represents the number of elements.
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float64
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 3])
&gt;&gt;&gt; nanops.nansem(s.values)
 0.5773502691896258
</pre> 
</div>
</div>
<a id="a1063388926939f4a636fd9bff9b28481" name="a1063388926939f4a636fd9bff9b28481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1063388926939f4a636fd9bff9b28481">&#9670;&#160;</a></span>nanskew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nanskew </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the sample skewness.

The statistic computed here is the adjusted Fisher-Pearson standardized
moment coefficient G1. The algorithm computes this coefficient directly
from the second and third central moment.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float64
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, np.nan, 1, 2])
&gt;&gt;&gt; nanops.nanskew(s.values)
1.7320508075688787
</pre> 
</div>
</div>
<a id="a21c4928fc13111dbcf6247536c1b9c2d" name="a21c4928fc13111dbcf6247536c1b9c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c4928fc13111dbcf6247536c1b9c2d">&#9670;&#160;</a></span>nanstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops.nanstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the standard deviation along given axis while ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
ddof : int, default 1
    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
    where N represents the number of elements.
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 3])
&gt;&gt;&gt; nanops.nanstd(s.values)
1.0
</pre> 
</div>
</div>
<a id="aff0cb58727011947abe4db87c9a15995" name="aff0cb58727011947abe4db87c9a15995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0cb58727011947abe4db87c9a15995">&#9670;&#160;</a></span>nansum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float pandas.core.nanops.nansum </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>min_count</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_] | None &#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sum the elements along an axis ignoring NaNs

Parameters
----------
values : ndarray[dtype]
axis : int, optional
skipna : bool, default True
min_count: int, default 0
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : dtype

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, 2, np.nan])
&gt;&gt;&gt; nanops.nansum(s.values)
3.0
</pre> 
</div>
</div>
<a id="a445b38d63c0e5acc5928f94bb43a3787" name="a445b38d63c0e5acc5928f94bb43a3787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445b38d63c0e5acc5928f94bb43a3787">&#9670;&#160;</a></span>nanvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops.nanvar </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*AxisInt | None &#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>ddof</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the variance along given axis while ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
ddof : int, default 1
    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
    where N represents the number of elements.
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
&gt;&gt;&gt; from pandas.core import nanops
&gt;&gt;&gt; s = pd.Series([1, np.nan, 2, 3])
&gt;&gt;&gt; nanops.nanvar(s.values)
1.0
</pre> 
</div>
</div>
<a id="a7ba5b317118c1de15bba9b3f11f653bf" name="a7ba5b317118c1de15bba9b3f11f653bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba5b317118c1de15bba9b3f11f653bf">&#9670;&#160;</a></span>set_use_bottleneck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.nanops.set_use_bottleneck </td>
          <td>(</td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>v</em> = <code>True</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Documentation des variables</h2>
<a id="af834bffa987e3ae366d6e953fd4337fb" name="af834bffa987e3ae366d6e953fd4337fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af834bffa987e3ae366d6e953fd4337fb">&#9670;&#160;</a></span>_BOTTLENECK_INSTALLED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops._BOTTLENECK_INSTALLED = <a class="el" href="namespacepandas_1_1core_1_1nanops.html#a566357757bc906d3485ee21672f17e0e">bn</a> is not None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40f162fe703abaee698d911864d454f8" name="a40f162fe703abaee698d911864d454f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f162fe703abaee698d911864d454f8">&#9670;&#160;</a></span>_USE_BOTTLENECK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.nanops._USE_BOTTLENECK = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a566357757bc906d3485ee21672f17e0e" name="a566357757bc906d3485ee21672f17e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566357757bc906d3485ee21672f17e0e">&#9670;&#160;</a></span>bn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops.bn = import_optional_dependency(&quot;bottleneck&quot;, errors=&quot;warn&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd9e1a5ebdbb93674e992b54b31c72e4" name="abd9e1a5ebdbb93674e992b54b31c72e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9e1a5ebdbb93674e992b54b31c72e4">&#9670;&#160;</a></span>nanmax</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops.nanmax = <a class="el" href="namespacepandas_1_1core_1_1nanops.html#a93045b765aeff3805cabfa2720d7a143">_nanminmax</a>(&quot;max&quot;, fill_value_typ=&quot;-inf&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33d06ee1140b9e48e55b314d5039bb29" name="a33d06ee1140b9e48e55b314d5039bb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d06ee1140b9e48e55b314d5039bb29">&#9670;&#160;</a></span>nanmin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.nanops.nanmin = <a class="el" href="namespacepandas_1_1core_1_1nanops.html#a93045b765aeff3805cabfa2720d7a143">_nanminmax</a>(&quot;min&quot;, fill_value_typ=&quot;+inf&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
