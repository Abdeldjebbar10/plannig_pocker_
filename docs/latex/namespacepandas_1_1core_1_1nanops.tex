\doxysection{Référence de l\textquotesingle{}espace de nommage pandas.\+core.\+nanops}
\hypertarget{namespacepandas_1_1core_1_1nanops}{}\label{namespacepandas_1_1core_1_1nanops}\index{pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classpandas_1_1core_1_1nanops_1_1bottleneck__switch}{bottleneck\+\_\+switch}}
\item 
class \mbox{\hyperlink{classpandas_1_1core_1_1nanops_1_1disallow}{disallow}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
None \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a7ba5b317118c1de15bba9b3f11f653bf}{set\+\_\+use\+\_\+bottleneck}} (bool v=True)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_aa94cc62c215f7594bd93ab4330666f5c}{\+\_\+bn\+\_\+ok\+\_\+dtype}} (Dtype\+Obj dtype, str name)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a924fff4e8357429260f7862406675752}{\+\_\+has\+\_\+infs}} (result)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_af8ca211d3f9a354cb5cf86b398b401d5}{\+\_\+get\+\_\+fill\+\_\+value}} (Dtype\+Obj dtype, Scalar\texorpdfstring{$\vert$}{|}None fill\+\_\+value=None, fill\+\_\+value\+\_\+typ=None)
\item 
npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_acf21a9381a322f32d8a0d411e0f9c4f1}{\+\_\+maybe\+\_\+get\+\_\+mask}} (np.\+ndarray values, bool skipna, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask)
\item 
tuple\mbox{[}np.\+ndarray, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a7750a24661b63a60b1cfe45409d71347}{\+\_\+get\+\_\+values}} (np.\+ndarray values, bool skipna, Any fill\+\_\+value=None, str\texorpdfstring{$\vert$}{|}None fill\+\_\+value\+\_\+typ=None, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
np.\+dtype \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a1d209253c580410d836050026a2ee5c4}{\+\_\+get\+\_\+dtype\+\_\+max}} (np.\+dtype dtype)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a9f3d7b7d7dd3a421376a05cfc3a62d14}{\+\_\+na\+\_\+ok\+\_\+dtype}} (Dtype\+Obj dtype)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a926c4951718f784bc7072a0d2f37c84a}{\+\_\+wrap\+\_\+results}} (result, np.\+dtype dtype, fill\+\_\+value=None)
\item 
F \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a2b6a1c4d87eff10bfeeeb0924cce9b88}{\+\_\+datetimelike\+\_\+compat}} (F func)
\item 
Scalar\texorpdfstring{$\vert$}{|}np.\+ndarray \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a3e45c3199612b0af815c2dc75bf05d0c}{\+\_\+na\+\_\+for\+\_\+min\+\_\+count}} (np.\+ndarray values, Axis\+Int\texorpdfstring{$\vert$}{|}None axis)
\item 
F \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a142d0573cb84be54a4f444476b574e11}{maybe\+\_\+operate\+\_\+rowwise}} (F func)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a3309db9d87848009d7bc1bd1fbb6ea12}{nanany}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a5baeeb6d5a55a8f82d1d340566b6dccf}{nanall}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_aff0cb58727011947abe4db87c9a15995}{nansum}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, int min\+\_\+count=0, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
np.\+ndarray\texorpdfstring{$\vert$}{|}np.\+datetime64\texorpdfstring{$\vert$}{|}np.\+timedelta64\texorpdfstring{$\vert$}{|}Na\+TType \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_adbe51baf9fd064e9389b5b72f1dad39c}{\+\_\+mask\+\_\+datetimelike\+\_\+result}} (np.\+ndarray\texorpdfstring{$\vert$}{|}np.\+datetime64\texorpdfstring{$\vert$}{|}np.\+timedelta64 result, Axis\+Int\texorpdfstring{$\vert$}{|}None axis, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} mask, np.\+ndarray orig\+\_\+values)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a168a1c4fae3e35839c21e44d44119135}{nanmean}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a2982b6830dd4e8e0f14d4cbacdaeffd9}{nanmedian}} (values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, mask=None)
\item 
np.\+ndarray \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a2cde3e3d0b8c5a2f653ada0db010fc66}{\+\_\+get\+\_\+empty\+\_\+reduction\+\_\+result}} (Shape shape, Axis\+Int axis)
\item 
tuple\mbox{[}float\texorpdfstring{$\vert$}{|}np.\+ndarray, float\texorpdfstring{$\vert$}{|}np.\+ndarray\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_aceb71bf9b0a9c7201d1db44c2248540e}{\+\_\+get\+\_\+counts\+\_\+nanvar}} (Shape values\+\_\+shape, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask, Axis\+Int\texorpdfstring{$\vert$}{|}None axis, int ddof, np.\+dtype dtype=np.\+dtype(np.\+float64))
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a21c4928fc13111dbcf6247536c1b9c2d}{nanstd}} (values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, int ddof=1, mask=None)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a445b38d63c0e5acc5928f94bb43a3787}{nanvar}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, int ddof=1, mask=None)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a12034563649d1a56f18c62181fba3d18}{nansem}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, int ddof=1, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143}{\+\_\+nanminmax}} (meth, fill\+\_\+value\+\_\+typ)
\item 
int\texorpdfstring{$\vert$}{|}np.\+ndarray \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a0e6890134a5138efe54e26e72403ce76}{nanargmax}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
int\texorpdfstring{$\vert$}{|}np.\+ndarray \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_aff8ba31c8c06e13d4f3325f9fd1d6be6}{nanargmin}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a1063388926939f4a636fd9bff9b28481}{nanskew}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a597697d9c6edbe8bcff32e17944bae6d}{nankurt}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a14d67520cb32daba37b5d2d90ac7fd1d}{nanprod}} (np.\+ndarray values, \texorpdfstring{$\ast$}{*}Axis\+Int\texorpdfstring{$\vert$}{|}None axis=None, bool skipna=True, int min\+\_\+count=0, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask=None)
\item 
np.\+ndarray\texorpdfstring{$\vert$}{|}int \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a7c7a030713f87d42d60a1c8ede76b293}{\+\_\+maybe\+\_\+arg\+\_\+null\+\_\+out}} (np.\+ndarray result, Axis\+Int\texorpdfstring{$\vert$}{|}None axis, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask, bool skipna)
\item 
np.\+floating\texorpdfstring{$\vert$}{|}npt.\+NDArray\mbox{[}np.\+floating\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a4aae6c5bd56f8aa75fe71dc381ebbe5c}{\+\_\+get\+\_\+counts}} (Shape values\+\_\+shape, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask, Axis\+Int\texorpdfstring{$\vert$}{|}None axis, np.\+dtype\mbox{[}np.\+floating\mbox{]} dtype=np.\+dtype(np.\+float64))
\item 
np.\+ndarray\texorpdfstring{$\vert$}{|}float\texorpdfstring{$\vert$}{|}Na\+TType \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a3cd3611b1b110ef765e80080d677866b}{\+\_\+maybe\+\_\+null\+\_\+out}} (np.\+ndarray\texorpdfstring{$\vert$}{|}float\texorpdfstring{$\vert$}{|}Na\+TType result, Axis\+Int\texorpdfstring{$\vert$}{|}None axis, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask, tuple\mbox{[}int,...\mbox{]} shape, int min\+\_\+count=1)
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a328f3af29479e82a52cc5f3d3ae08763}{check\+\_\+below\+\_\+min\+\_\+count}} (tuple\mbox{[}int,...\mbox{]} shape, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}\texorpdfstring{$\vert$}{|}None mask, int min\+\_\+count)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a16f47c0d8a7b3a36de8b219c8aa49d72}{\+\_\+zero\+\_\+out\+\_\+fperr}} (arg)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_afdac9427ff98622a40eadbf79c6944b4}{nancorr}} (np.\+ndarray a, np.\+ndarray b, \texorpdfstring{$\ast$}{*}Correlation\+Method method="{}pearson"{}, int\texorpdfstring{$\vert$}{|}None min\+\_\+periods=None)
\item 
Callable\mbox{[}\mbox{[}np.\+ndarray, np.\+ndarray\mbox{]}, float\mbox{]} \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a19358270e13bec4c7711e487d71e69ea}{get\+\_\+corr\+\_\+func}} (Correlation\+Method method)
\item 
float \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_af7f54b35a6617784f3aaab2f1060263a}{nancov}} (np.\+ndarray a, np.\+ndarray b, \texorpdfstring{$\ast$}{*}int\texorpdfstring{$\vert$}{|}None min\+\_\+periods=None, int\texorpdfstring{$\vert$}{|}None ddof=1)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_aa14df2879e27a3fdd5b9889f9b07bb7a}{\+\_\+ensure\+\_\+numeric}} (x)
\item 
Array\+Like \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_ac41fd84812b523fee95d4d87f1b40e35}{na\+\_\+accum\+\_\+func}} (Array\+Like values, accum\+\_\+func, \texorpdfstring{$\ast$}{*}bool skipna)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a566357757bc906d3485ee21672f17e0e}{bn}} = import\+\_\+optional\+\_\+dependency("{}bottleneck"{}, errors="{}warn"{})
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_af834bffa987e3ae366d6e953fd4337fb}{\+\_\+\+BOTTLENECK\+\_\+\+INSTALLED}} = \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a566357757bc906d3485ee21672f17e0e}{bn}} is not None
\item 
bool \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a40f162fe703abaee698d911864d454f8}{\+\_\+\+USE\+\_\+\+BOTTLENECK}} = False
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a33d06ee1140b9e48e55b314d5039bb29}{nanmin}} = \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143}{\+\_\+nanminmax}}("{}min"{}, fill\+\_\+value\+\_\+typ="{}+inf"{})
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_abd9e1a5ebdbb93674e992b54b31c72e4}{nanmax}} = \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143}{\+\_\+nanminmax}}("{}max"{}, fill\+\_\+value\+\_\+typ="{}-\/inf"{})
\end{DoxyCompactItemize}


\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacepandas_1_1core_1_1nanops_aa94cc62c215f7594bd93ab4330666f5c}\label{namespacepandas_1_1core_1_1nanops_aa94cc62c215f7594bd93ab4330666f5c} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_bn\_ok\_dtype@{\_bn\_ok\_dtype}}
\index{\_bn\_ok\_dtype@{\_bn\_ok\_dtype}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_bn\_ok\_dtype()}{\_bn\_ok\_dtype()}}
{\footnotesize\ttfamily  bool pandas.\+core.\+nanops.\+\_\+bn\+\_\+ok\+\_\+dtype (\begin{DoxyParamCaption}\item[{Dtype\+Obj}]{dtype,  }\item[{str}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a2b6a1c4d87eff10bfeeeb0924cce9b88}\label{namespacepandas_1_1core_1_1nanops_a2b6a1c4d87eff10bfeeeb0924cce9b88} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_datetimelike\_compat@{\_datetimelike\_compat}}
\index{\_datetimelike\_compat@{\_datetimelike\_compat}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_datetimelike\_compat()}{\_datetimelike\_compat()}}
{\footnotesize\ttfamily  F pandas.\+core.\+nanops.\+\_\+datetimelike\+\_\+compat (\begin{DoxyParamCaption}\item[{F}]{func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}If we have datetime64 or timedelta64 values, ensure we have a correct
mask before calling the wrapped function, then cast back afterwards.
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_aa14df2879e27a3fdd5b9889f9b07bb7a}\label{namespacepandas_1_1core_1_1nanops_aa14df2879e27a3fdd5b9889f9b07bb7a} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_ensure\_numeric@{\_ensure\_numeric}}
\index{\_ensure\_numeric@{\_ensure\_numeric}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_ensure\_numeric()}{\_ensure\_numeric()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+\_\+ensure\+\_\+numeric (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a4aae6c5bd56f8aa75fe71dc381ebbe5c}\label{namespacepandas_1_1core_1_1nanops_a4aae6c5bd56f8aa75fe71dc381ebbe5c} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_get\_counts@{\_get\_counts}}
\index{\_get\_counts@{\_get\_counts}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_get\_counts()}{\_get\_counts()}}
{\footnotesize\ttfamily  np.\+floating \texorpdfstring{$\vert$}{|} npt.\+NDArray\mbox{[}np.\+floating\mbox{]} pandas.\+core.\+nanops.\+\_\+get\+\_\+counts (\begin{DoxyParamCaption}\item[{Shape}]{values\+\_\+shape,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None}]{mask,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} None}]{axis,  }\item[{np.\+dtype\mbox{[}np.\+floating\mbox{]} }]{dtype = {\ttfamily np.dtype(np.float64)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get the count of non-null values along an axis

Parameters
----------
values_shape : tuple of int
    shape tuple from values ndarray, used if mask is None
mask : Optional[ndarray[bool]]
    locations in values that should be considered missing
axis : Optional[int]
    axis to count along
dtype : type, optional
    type to use for count

Returns
-------
count : scalar or array
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_aceb71bf9b0a9c7201d1db44c2248540e}\label{namespacepandas_1_1core_1_1nanops_aceb71bf9b0a9c7201d1db44c2248540e} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_get\_counts\_nanvar@{\_get\_counts\_nanvar}}
\index{\_get\_counts\_nanvar@{\_get\_counts\_nanvar}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_get\_counts\_nanvar()}{\_get\_counts\_nanvar()}}
{\footnotesize\ttfamily  tuple\mbox{[}float \texorpdfstring{$\vert$}{|} np.\+ndarray, float \texorpdfstring{$\vert$}{|} np.\+ndarray\mbox{]} pandas.\+core.\+nanops.\+\_\+get\+\_\+counts\+\_\+nanvar (\begin{DoxyParamCaption}\item[{Shape}]{values\+\_\+shape,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None}]{mask,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} None}]{axis,  }\item[{int}]{ddof,  }\item[{np.\+dtype }]{dtype = {\ttfamily np.dtype(np.float64)} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Get the count of non-null values along an axis, accounting
for degrees of freedom.

Parameters
----------
values_shape : Tuple[int, ...]
    shape tuple from values ndarray, used if mask is None
mask : Optional[ndarray[bool]]
    locations in values that should be considered missing
axis : Optional[int]
    axis to count along
ddof : int
    degrees of freedom
dtype : type, optional
    type to use for count

Returns
-------
count : int, np.nan or np.ndarray
d : int, np.nan or np.ndarray
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a1d209253c580410d836050026a2ee5c4}\label{namespacepandas_1_1core_1_1nanops_a1d209253c580410d836050026a2ee5c4} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_get\_dtype\_max@{\_get\_dtype\_max}}
\index{\_get\_dtype\_max@{\_get\_dtype\_max}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_get\_dtype\_max()}{\_get\_dtype\_max()}}
{\footnotesize\ttfamily  np.\+dtype pandas.\+core.\+nanops.\+\_\+get\+\_\+dtype\+\_\+max (\begin{DoxyParamCaption}\item[{np.\+dtype}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a2cde3e3d0b8c5a2f653ada0db010fc66}\label{namespacepandas_1_1core_1_1nanops_a2cde3e3d0b8c5a2f653ada0db010fc66} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_get\_empty\_reduction\_result@{\_get\_empty\_reduction\_result}}
\index{\_get\_empty\_reduction\_result@{\_get\_empty\_reduction\_result}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_get\_empty\_reduction\_result()}{\_get\_empty\_reduction\_result()}}
{\footnotesize\ttfamily  np.\+ndarray pandas.\+core.\+nanops.\+\_\+get\+\_\+empty\+\_\+reduction\+\_\+result (\begin{DoxyParamCaption}\item[{Shape}]{shape,  }\item[{Axis\+Int}]{axis }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}The result from a reduction on an empty ndarray.

Parameters
----------
shape : Tuple[int, ...]
axis : int

Returns
-------
np.ndarray
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_af8ca211d3f9a354cb5cf86b398b401d5}\label{namespacepandas_1_1core_1_1nanops_af8ca211d3f9a354cb5cf86b398b401d5} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_get\_fill\_value@{\_get\_fill\_value}}
\index{\_get\_fill\_value@{\_get\_fill\_value}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_get\_fill\_value()}{\_get\_fill\_value()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+\_\+get\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{Dtype\+Obj}]{dtype,  }\item[{Scalar \texorpdfstring{$\vert$}{|} None }]{fill\+\_\+value = {\ttfamily None},  }\item[{}]{fill\+\_\+value\+\_\+typ = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}return the correct fill value for the dtype of the values\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a7750a24661b63a60b1cfe45409d71347}\label{namespacepandas_1_1core_1_1nanops_a7750a24661b63a60b1cfe45409d71347} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_get\_values@{\_get\_values}}
\index{\_get\_values@{\_get\_values}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_get\_values()}{\_get\_values()}}
{\footnotesize\ttfamily  tuple\mbox{[}np.\+ndarray, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None\mbox{]} pandas.\+core.\+nanops.\+\_\+get\+\_\+values (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{bool}]{skipna,  }\item[{Any }]{fill\+\_\+value = {\ttfamily None},  }\item[{str \texorpdfstring{$\vert$}{|} None }]{fill\+\_\+value\+\_\+typ = {\ttfamily None},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Utility to get the values view, mask, dtype, dtype_max, and fill_value.

If both mask and fill_value/fill_value_typ are not None and skipna is True,
the values array will be copied.

For input arrays of boolean or integer dtypes, copies will only occur if a
precomputed mask, a fill_value/fill_value_typ, and skipna=True are
provided.

Parameters
----------
values : ndarray
    input array to potentially compute mask for
skipna : bool
    boolean for whether NaNs should be skipped
fill_value : Any
    value to fill NaNs with
fill_value_typ : str
    Set to '+inf' or '-inf' to handle dtype-specific infinities
mask : Optional[np.ndarray[bool]]
    nan-mask if known

Returns
-------
values : ndarray
    Potential copy of input value array
mask : Optional[ndarray[bool]]
    Mask for values, if deemed necessary to compute
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a924fff4e8357429260f7862406675752}\label{namespacepandas_1_1core_1_1nanops_a924fff4e8357429260f7862406675752} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_has\_infs@{\_has\_infs}}
\index{\_has\_infs@{\_has\_infs}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_has\_infs()}{\_has\_infs()}}
{\footnotesize\ttfamily  bool pandas.\+core.\+nanops.\+\_\+has\+\_\+infs (\begin{DoxyParamCaption}\item[{}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_adbe51baf9fd064e9389b5b72f1dad39c}\label{namespacepandas_1_1core_1_1nanops_adbe51baf9fd064e9389b5b72f1dad39c} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_mask\_datetimelike\_result@{\_mask\_datetimelike\_result}}
\index{\_mask\_datetimelike\_result@{\_mask\_datetimelike\_result}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_mask\_datetimelike\_result()}{\_mask\_datetimelike\_result()}}
{\footnotesize\ttfamily  np.\+ndarray \texorpdfstring{$\vert$}{|} np.\+datetime64 \texorpdfstring{$\vert$}{|} np.\+timedelta64 \texorpdfstring{$\vert$}{|} Na\+TType pandas.\+core.\+nanops.\+\_\+mask\+\_\+datetimelike\+\_\+result (\begin{DoxyParamCaption}\item[{np.\+ndarray \texorpdfstring{$\vert$}{|} np.\+datetime64 \texorpdfstring{$\vert$}{|} np.\+timedelta64}]{result,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} None}]{axis,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}}]{mask,  }\item[{np.\+ndarray}]{orig\+\_\+values }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a7c7a030713f87d42d60a1c8ede76b293}\label{namespacepandas_1_1core_1_1nanops_a7c7a030713f87d42d60a1c8ede76b293} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_maybe\_arg\_null\_out@{\_maybe\_arg\_null\_out}}
\index{\_maybe\_arg\_null\_out@{\_maybe\_arg\_null\_out}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_maybe\_arg\_null\_out()}{\_maybe\_arg\_null\_out()}}
{\footnotesize\ttfamily  np.\+ndarray \texorpdfstring{$\vert$}{|} int pandas.\+core.\+nanops.\+\_\+maybe\+\_\+arg\+\_\+null\+\_\+out (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{result,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} None}]{axis,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None}]{mask,  }\item[{bool}]{skipna }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_acf21a9381a322f32d8a0d411e0f9c4f1}\label{namespacepandas_1_1core_1_1nanops_acf21a9381a322f32d8a0d411e0f9c4f1} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_maybe\_get\_mask@{\_maybe\_get\_mask}}
\index{\_maybe\_get\_mask@{\_maybe\_get\_mask}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_maybe\_get\_mask()}{\_maybe\_get\_mask()}}
{\footnotesize\ttfamily  npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None pandas.\+core.\+nanops.\+\_\+maybe\+\_\+get\+\_\+mask (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{bool}]{skipna,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute a mask if and only if necessary.

This function will compute a mask iff it is necessary. Otherwise,
return the provided mask (potentially None) when a mask does not need to be
computed.

A mask is never necessary if the values array is of boolean or integer
dtypes, as these are incapable of storing NaNs. If passing a NaN-capable
dtype that is interpretable as either boolean or integer data (eg,
timedelta64), a mask must be provided.

If the skipna parameter is False, a new mask will not be computed.

The mask is computed using isna() by default. Setting invert=True selects
notna() as the masking function.

Parameters
----------
values : ndarray
    input array to potentially compute mask for
skipna : bool
    boolean for whether NaNs should be skipped
mask : Optional[ndarray]
    nan-mask if known

Returns
-------
Optional[np.ndarray[bool]]
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a3cd3611b1b110ef765e80080d677866b}\label{namespacepandas_1_1core_1_1nanops_a3cd3611b1b110ef765e80080d677866b} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_maybe\_null\_out@{\_maybe\_null\_out}}
\index{\_maybe\_null\_out@{\_maybe\_null\_out}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_maybe\_null\_out()}{\_maybe\_null\_out()}}
{\footnotesize\ttfamily  np.\+ndarray \texorpdfstring{$\vert$}{|} float \texorpdfstring{$\vert$}{|} Na\+TType pandas.\+core.\+nanops.\+\_\+maybe\+\_\+null\+\_\+out (\begin{DoxyParamCaption}\item[{np.\+ndarray \texorpdfstring{$\vert$}{|} float \texorpdfstring{$\vert$}{|} Na\+TType}]{result,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} None}]{axis,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None}]{mask,  }\item[{tuple\mbox{[}int, ...\mbox{]}}]{shape,  }\item[{int }]{min\+\_\+count = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns
-------
Dtype
    The product of all elements on a given axis. ( NaNs are treated as 1)
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a3e45c3199612b0af815c2dc75bf05d0c}\label{namespacepandas_1_1core_1_1nanops_a3e45c3199612b0af815c2dc75bf05d0c} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_na\_for\_min\_count@{\_na\_for\_min\_count}}
\index{\_na\_for\_min\_count@{\_na\_for\_min\_count}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_na\_for\_min\_count()}{\_na\_for\_min\_count()}}
{\footnotesize\ttfamily  Scalar \texorpdfstring{$\vert$}{|} np.\+ndarray pandas.\+core.\+nanops.\+\_\+na\+\_\+for\+\_\+min\+\_\+count (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} None}]{axis }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return the missing value for `values`.

Parameters
----------
values : ndarray
axis : int or None
    axis for the reduction, required if values.ndim > 1.

Returns
-------
result : scalar or ndarray
    For 1-D values, returns a scalar of the correct missing type.
    For 2-D values, returns a 1-D array where each element is missing.
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a9f3d7b7d7dd3a421376a05cfc3a62d14}\label{namespacepandas_1_1core_1_1nanops_a9f3d7b7d7dd3a421376a05cfc3a62d14} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_na\_ok\_dtype@{\_na\_ok\_dtype}}
\index{\_na\_ok\_dtype@{\_na\_ok\_dtype}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_na\_ok\_dtype()}{\_na\_ok\_dtype()}}
{\footnotesize\ttfamily  bool pandas.\+core.\+nanops.\+\_\+na\+\_\+ok\+\_\+dtype (\begin{DoxyParamCaption}\item[{Dtype\+Obj}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143}\label{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_nanminmax@{\_nanminmax}}
\index{\_nanminmax@{\_nanminmax}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_nanminmax()}{\_nanminmax()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+\_\+nanminmax (\begin{DoxyParamCaption}\item[{}]{meth,  }\item[{}]{fill\+\_\+value\+\_\+typ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a926c4951718f784bc7072a0d2f37c84a}\label{namespacepandas_1_1core_1_1nanops_a926c4951718f784bc7072a0d2f37c84a} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_wrap\_results@{\_wrap\_results}}
\index{\_wrap\_results@{\_wrap\_results}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_wrap\_results()}{\_wrap\_results()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+\_\+wrap\+\_\+results (\begin{DoxyParamCaption}\item[{}]{result,  }\item[{np.\+dtype}]{dtype,  }\item[{}]{fill\+\_\+value = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}wrap our results if needed\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a16f47c0d8a7b3a36de8b219c8aa49d72}\label{namespacepandas_1_1core_1_1nanops_a16f47c0d8a7b3a36de8b219c8aa49d72} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_zero\_out\_fperr@{\_zero\_out\_fperr}}
\index{\_zero\_out\_fperr@{\_zero\_out\_fperr}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_zero\_out\_fperr()}{\_zero\_out\_fperr()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+\_\+zero\+\_\+out\+\_\+fperr (\begin{DoxyParamCaption}\item[{}]{arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a328f3af29479e82a52cc5f3d3ae08763}\label{namespacepandas_1_1core_1_1nanops_a328f3af29479e82a52cc5f3d3ae08763} 
\index{pandas.core.nanops@{pandas.core.nanops}!check\_below\_min\_count@{check\_below\_min\_count}}
\index{check\_below\_min\_count@{check\_below\_min\_count}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{check\_below\_min\_count()}{check\_below\_min\_count()}}
{\footnotesize\ttfamily  bool pandas.\+core.\+nanops.\+check\+\_\+below\+\_\+min\+\_\+count (\begin{DoxyParamCaption}\item[{tuple\mbox{[}int, ...\mbox{]}}]{shape,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None}]{mask,  }\item[{int }]{min\+\_\+count }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check for the `min_count` keyword. Returns True if below `min_count` (when
missing value should be returned from the reduction).

Parameters
----------
shape : tuple
    The shape of the values (`values.shape`).
mask : ndarray[bool] or None
    Boolean numpy array (typically of same shape as `shape`) or None.
min_count : int
    Keyword passed through from sum/prod call.

Returns
-------
bool
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a19358270e13bec4c7711e487d71e69ea}\label{namespacepandas_1_1core_1_1nanops_a19358270e13bec4c7711e487d71e69ea} 
\index{pandas.core.nanops@{pandas.core.nanops}!get\_corr\_func@{get\_corr\_func}}
\index{get\_corr\_func@{get\_corr\_func}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{get\_corr\_func()}{get\_corr\_func()}}
{\footnotesize\ttfamily  Callable\mbox{[}\mbox{[}np.\+ndarray, np.\+ndarray\mbox{]}, float\mbox{]} pandas.\+core.\+nanops.\+get\+\_\+corr\+\_\+func (\begin{DoxyParamCaption}\item[{Correlation\+Method}]{method }\end{DoxyParamCaption})}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a142d0573cb84be54a4f444476b574e11}\label{namespacepandas_1_1core_1_1nanops_a142d0573cb84be54a4f444476b574e11} 
\index{pandas.core.nanops@{pandas.core.nanops}!maybe\_operate\_rowwise@{maybe\_operate\_rowwise}}
\index{maybe\_operate\_rowwise@{maybe\_operate\_rowwise}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{maybe\_operate\_rowwise()}{maybe\_operate\_rowwise()}}
{\footnotesize\ttfamily  F pandas.\+core.\+nanops.\+maybe\+\_\+operate\+\_\+rowwise (\begin{DoxyParamCaption}\item[{F}]{func }\end{DoxyParamCaption})}

\begin{DoxyVerb}NumPy operations on C-contiguous ndarrays with axis=1 can be
very slow if axis 1 >> axis 0.
Operate row-by-row and concatenate the results.
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_ac41fd84812b523fee95d4d87f1b40e35}\label{namespacepandas_1_1core_1_1nanops_ac41fd84812b523fee95d4d87f1b40e35} 
\index{pandas.core.nanops@{pandas.core.nanops}!na\_accum\_func@{na\_accum\_func}}
\index{na\_accum\_func@{na\_accum\_func}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{na\_accum\_func()}{na\_accum\_func()}}
{\footnotesize\ttfamily  Array\+Like pandas.\+core.\+nanops.\+na\+\_\+accum\+\_\+func (\begin{DoxyParamCaption}\item[{Array\+Like}]{values,  }\item[{}]{accum\+\_\+func,  }\item[{\texorpdfstring{$\ast$}{*}bool}]{skipna }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cumulative function with skipna support.

Parameters
----------
values : np.ndarray or ExtensionArray
accum_func : {np.cumprod, np.maximum.accumulate, np.cumsum, np.minimum.accumulate}
skipna : bool

Returns
-------
np.ndarray or ExtensionArray
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a5baeeb6d5a55a8f82d1d340566b6dccf}\label{namespacepandas_1_1core_1_1nanops_a5baeeb6d5a55a8f82d1d340566b6dccf} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanall@{nanall}}
\index{nanall@{nanall}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanall()}{nanall()}}
{\footnotesize\ttfamily  bool pandas.\+core.\+nanops.\+nanall (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if all elements along an axis evaluate to True.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : bool

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, 2, np.nan])
>>> nanops.nanall(s.values)
True

>>> from pandas.core import nanops
>>> s = pd.Series([1, 0])
>>> nanops.nanall(s.values)
False
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a3309db9d87848009d7bc1bd1fbb6ea12}\label{namespacepandas_1_1core_1_1nanops_a3309db9d87848009d7bc1bd1fbb6ea12} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanany@{nanany}}
\index{nanany@{nanany}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanany()}{nanany()}}
{\footnotesize\ttfamily  bool pandas.\+core.\+nanops.\+nanany (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if any elements along an axis evaluate to True.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : bool

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, 2])
>>> nanops.nanany(s.values)
True

>>> from pandas.core import nanops
>>> s = pd.Series([np.nan])
>>> nanops.nanany(s.values)
False
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a0e6890134a5138efe54e26e72403ce76}\label{namespacepandas_1_1core_1_1nanops_a0e6890134a5138efe54e26e72403ce76} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanargmax@{nanargmax}}
\index{nanargmax@{nanargmax}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanargmax()}{nanargmax()}}
{\footnotesize\ttfamily  int \texorpdfstring{$\vert$}{|} np.\+ndarray pandas.\+core.\+nanops.\+nanargmax (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : int or ndarray[int]
    The index/indices  of max value in specified axis or -1 in the NA case

Examples
--------
>>> from pandas.core import nanops
>>> arr = np.array([1, 2, 3, np.nan, 4])
>>> nanops.nanargmax(arr)
4

>>> arr = np.array(range(12), dtype=np.float64).reshape(4, 3)
>>> arr[2:, 2] = np.nan
>>> arr
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7., nan],
       [ 9., 10., nan]])
>>> nanops.nanargmax(arr, axis=1)
array([2, 2, 1, 1])
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_aff8ba31c8c06e13d4f3325f9fd1d6be6}\label{namespacepandas_1_1core_1_1nanops_aff8ba31c8c06e13d4f3325f9fd1d6be6} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanargmin@{nanargmin}}
\index{nanargmin@{nanargmin}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanargmin()}{nanargmin()}}
{\footnotesize\ttfamily  int \texorpdfstring{$\vert$}{|} np.\+ndarray pandas.\+core.\+nanops.\+nanargmin (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : int or ndarray[int]
    The index/indices of min value in specified axis or -1 in the NA case

Examples
--------
>>> from pandas.core import nanops
>>> arr = np.array([1, 2, 3, np.nan, 4])
>>> nanops.nanargmin(arr)
0

>>> arr = np.array(range(12), dtype=np.float64).reshape(4, 3)
>>> arr[2:, 0] = np.nan
>>> arr
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [nan,  7.,  8.],
       [nan, 10., 11.]])
>>> nanops.nanargmin(arr, axis=1)
array([0, 0, 1, 1])
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_afdac9427ff98622a40eadbf79c6944b4}\label{namespacepandas_1_1core_1_1nanops_afdac9427ff98622a40eadbf79c6944b4} 
\index{pandas.core.nanops@{pandas.core.nanops}!nancorr@{nancorr}}
\index{nancorr@{nancorr}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nancorr()}{nancorr()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nancorr (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{a,  }\item[{np.\+ndarray}]{b,  }\item[{\texorpdfstring{$\ast$}{*}Correlation\+Method }]{method = {\ttfamily "{}pearson"{}},  }\item[{int \texorpdfstring{$\vert$}{|} None }]{min\+\_\+periods = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}a, b: ndarrays
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_af7f54b35a6617784f3aaab2f1060263a}\label{namespacepandas_1_1core_1_1nanops_af7f54b35a6617784f3aaab2f1060263a} 
\index{pandas.core.nanops@{pandas.core.nanops}!nancov@{nancov}}
\index{nancov@{nancov}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nancov()}{nancov()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nancov (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{a,  }\item[{np.\+ndarray}]{b,  }\item[{\texorpdfstring{$\ast$}{*}int \texorpdfstring{$\vert$}{|} None }]{min\+\_\+periods = {\ttfamily None},  }\item[{int \texorpdfstring{$\vert$}{|} None }]{ddof = {\ttfamily 1} }\end{DoxyParamCaption})}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a597697d9c6edbe8bcff32e17944bae6d}\label{namespacepandas_1_1core_1_1nanops_a597697d9c6edbe8bcff32e17944bae6d} 
\index{pandas.core.nanops@{pandas.core.nanops}!nankurt@{nankurt}}
\index{nankurt@{nankurt}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nankurt()}{nankurt()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nankurt (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the sample excess kurtosis

The statistic computed here is the adjusted Fisher-Pearson standardized
moment coefficient G2, computed directly from the second and fourth
central moment.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float64
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, np.nan, 1, 3, 2])
>>> nanops.nankurt(s.values)
-1.2892561983471076
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a168a1c4fae3e35839c21e44d44119135}\label{namespacepandas_1_1core_1_1nanops_a168a1c4fae3e35839c21e44d44119135} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanmean@{nanmean}}
\index{nanmean@{nanmean}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanmean()}{nanmean()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nanmean (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the mean of the element along an axis ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, 2, np.nan])
>>> nanops.nanmean(s.values)
1.5
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a2982b6830dd4e8e0f14d4cbacdaeffd9}\label{namespacepandas_1_1core_1_1nanops_a2982b6830dd4e8e0f14d4cbacdaeffd9} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanmedian@{nanmedian}}
\index{nanmedian@{nanmedian}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanmedian()}{nanmedian()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+nanmedian (\begin{DoxyParamCaption}\item[{}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{}]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, np.nan, 2, 2])
>>> nanops.nanmedian(s.values)
2.0
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a14d67520cb32daba37b5d2d90ac7fd1d}\label{namespacepandas_1_1core_1_1nanops_a14d67520cb32daba37b5d2d90ac7fd1d} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanprod@{nanprod}}
\index{nanprod@{nanprod}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanprod()}{nanprod()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nanprod (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{int }]{min\+\_\+count = {\ttfamily 0},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parameters
----------
values : ndarray[dtype]
axis : int, optional
skipna : bool, default True
min_count: int, default 0
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
Dtype
    The product of all elements on a given axis. ( NaNs are treated as 1)

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, 2, 3, np.nan])
>>> nanops.nanprod(s.values)
6.0
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a12034563649d1a56f18c62181fba3d18}\label{namespacepandas_1_1core_1_1nanops_a12034563649d1a56f18c62181fba3d18} 
\index{pandas.core.nanops@{pandas.core.nanops}!nansem@{nansem}}
\index{nansem@{nansem}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nansem()}{nansem()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nansem (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{int }]{ddof = {\ttfamily 1},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the standard error in the mean along given axis while ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
ddof : int, default 1
    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
    where N represents the number of elements.
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float64
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, np.nan, 2, 3])
>>> nanops.nansem(s.values)
 0.5773502691896258
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a1063388926939f4a636fd9bff9b28481}\label{namespacepandas_1_1core_1_1nanops_a1063388926939f4a636fd9bff9b28481} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanskew@{nanskew}}
\index{nanskew@{nanskew}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanskew()}{nanskew()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nanskew (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the sample skewness.

The statistic computed here is the adjusted Fisher-Pearson standardized
moment coefficient G1. The algorithm computes this coefficient directly
from the second and third central moment.

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float64
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, np.nan, 1, 2])
>>> nanops.nanskew(s.values)
1.7320508075688787
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a21c4928fc13111dbcf6247536c1b9c2d}\label{namespacepandas_1_1core_1_1nanops_a21c4928fc13111dbcf6247536c1b9c2d} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanstd@{nanstd}}
\index{nanstd@{nanstd}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanstd()}{nanstd()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+nanstd (\begin{DoxyParamCaption}\item[{}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{int }]{ddof = {\ttfamily 1},  }\item[{}]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the standard deviation along given axis while ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
ddof : int, default 1
    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
    where N represents the number of elements.
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, np.nan, 2, 3])
>>> nanops.nanstd(s.values)
1.0
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_aff0cb58727011947abe4db87c9a15995}\label{namespacepandas_1_1core_1_1nanops_aff0cb58727011947abe4db87c9a15995} 
\index{pandas.core.nanops@{pandas.core.nanops}!nansum@{nansum}}
\index{nansum@{nansum}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nansum()}{nansum()}}
{\footnotesize\ttfamily  float pandas.\+core.\+nanops.\+nansum (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{int }]{min\+\_\+count = {\ttfamily 0},  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} \texorpdfstring{$\vert$}{|} None }]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Sum the elements along an axis ignoring NaNs

Parameters
----------
values : ndarray[dtype]
axis : int, optional
skipna : bool, default True
min_count: int, default 0
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : dtype

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, 2, np.nan])
>>> nanops.nansum(s.values)
3.0
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a445b38d63c0e5acc5928f94bb43a3787}\label{namespacepandas_1_1core_1_1nanops_a445b38d63c0e5acc5928f94bb43a3787} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanvar@{nanvar}}
\index{nanvar@{nanvar}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanvar()}{nanvar()}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+nanvar (\begin{DoxyParamCaption}\item[{np.\+ndarray}]{values,  }\item[{\texorpdfstring{$\ast$}{*}Axis\+Int \texorpdfstring{$\vert$}{|} None }]{axis = {\ttfamily None},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{int }]{ddof = {\ttfamily 1},  }\item[{}]{mask = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the variance along given axis while ignoring NaNs

Parameters
----------
values : ndarray
axis : int, optional
skipna : bool, default True
ddof : int, default 1
    Delta Degrees of Freedom. The divisor used in calculations is N - ddof,
    where N represents the number of elements.
mask : ndarray[bool], optional
    nan-mask if known

Returns
-------
result : float
    Unless input is a float array, in which case use the same
    precision as the input array.

Examples
--------
>>> from pandas.core import nanops
>>> s = pd.Series([1, np.nan, 2, 3])
>>> nanops.nanvar(s.values)
1.0
\end{DoxyVerb}
 \Hypertarget{namespacepandas_1_1core_1_1nanops_a7ba5b317118c1de15bba9b3f11f653bf}\label{namespacepandas_1_1core_1_1nanops_a7ba5b317118c1de15bba9b3f11f653bf} 
\index{pandas.core.nanops@{pandas.core.nanops}!set\_use\_bottleneck@{set\_use\_bottleneck}}
\index{set\_use\_bottleneck@{set\_use\_bottleneck}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{set\_use\_bottleneck()}{set\_use\_bottleneck()}}
{\footnotesize\ttfamily  None pandas.\+core.\+nanops.\+set\+\_\+use\+\_\+bottleneck (\begin{DoxyParamCaption}\item[{bool }]{v = {\ttfamily True} }\end{DoxyParamCaption})}



\doxysubsection{Documentation des variables}
\Hypertarget{namespacepandas_1_1core_1_1nanops_af834bffa987e3ae366d6e953fd4337fb}\label{namespacepandas_1_1core_1_1nanops_af834bffa987e3ae366d6e953fd4337fb} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_BOTTLENECK\_INSTALLED@{\_BOTTLENECK\_INSTALLED}}
\index{\_BOTTLENECK\_INSTALLED@{\_BOTTLENECK\_INSTALLED}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_BOTTLENECK\_INSTALLED}{\_BOTTLENECK\_INSTALLED}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+\_\+\+BOTTLENECK\+\_\+\+INSTALLED = \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a566357757bc906d3485ee21672f17e0e}{bn}} is not None\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a40f162fe703abaee698d911864d454f8}\label{namespacepandas_1_1core_1_1nanops_a40f162fe703abaee698d911864d454f8} 
\index{pandas.core.nanops@{pandas.core.nanops}!\_USE\_BOTTLENECK@{\_USE\_BOTTLENECK}}
\index{\_USE\_BOTTLENECK@{\_USE\_BOTTLENECK}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{\_USE\_BOTTLENECK}{\_USE\_BOTTLENECK}}
{\footnotesize\ttfamily bool pandas.\+core.\+nanops.\+\_\+\+USE\+\_\+\+BOTTLENECK = False\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a566357757bc906d3485ee21672f17e0e}\label{namespacepandas_1_1core_1_1nanops_a566357757bc906d3485ee21672f17e0e} 
\index{pandas.core.nanops@{pandas.core.nanops}!bn@{bn}}
\index{bn@{bn}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{bn}{bn}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+bn = import\+\_\+optional\+\_\+dependency("{}bottleneck"{}, errors="{}warn"{})}

\Hypertarget{namespacepandas_1_1core_1_1nanops_abd9e1a5ebdbb93674e992b54b31c72e4}\label{namespacepandas_1_1core_1_1nanops_abd9e1a5ebdbb93674e992b54b31c72e4} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanmax@{nanmax}}
\index{nanmax@{nanmax}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanmax}{nanmax}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+nanmax = \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143}{\+\_\+nanminmax}}("{}max"{}, fill\+\_\+value\+\_\+typ="{}-\/inf"{})}

\Hypertarget{namespacepandas_1_1core_1_1nanops_a33d06ee1140b9e48e55b314d5039bb29}\label{namespacepandas_1_1core_1_1nanops_a33d06ee1140b9e48e55b314d5039bb29} 
\index{pandas.core.nanops@{pandas.core.nanops}!nanmin@{nanmin}}
\index{nanmin@{nanmin}!pandas.core.nanops@{pandas.core.nanops}}
\doxysubsubsection{\texorpdfstring{nanmin}{nanmin}}
{\footnotesize\ttfamily pandas.\+core.\+nanops.\+nanmin = \mbox{\hyperlink{namespacepandas_1_1core_1_1nanops_a93045b765aeff3805cabfa2720d7a143}{\+\_\+nanminmax}}("{}min"{}, fill\+\_\+value\+\_\+typ="{}+inf"{})}

