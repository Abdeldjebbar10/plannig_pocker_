\doxysection{Référence de l\textquotesingle{}espace de nommage numpy.\+\_\+core.\+numeric}
\hypertarget{namespacenumpy_1_1__core_1_1numeric}{}\label{namespacenumpy_1_1__core_1_1numeric}\index{numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_aeed315fa619da9956246b3267f3b193b}{\+\_\+zeros\+\_\+like\+\_\+dispatcher}} (a, dtype=None, order=None, subok=None, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}=None, \texorpdfstring{$\ast$}{*}device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a8649d4ae61c1d49c5a0d2e9294e14d25}{zeros\+\_\+like}} (a, dtype=None, order=\textquotesingle{}K\textquotesingle{}, subok=True, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}=None, \texorpdfstring{$\ast$}{*}device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a0b6a3662d66df0f58507c38f29644a28}{ones}} (\mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}, dtype=None, order=\textquotesingle{}C\textquotesingle{}, \texorpdfstring{$\ast$}{*}device=None, like=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_acd30c1072e03cffc13c475e00748b8d0}{\+\_\+ones\+\_\+like\+\_\+dispatcher}} (a, dtype=None, order=None, subok=None, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}=None, \texorpdfstring{$\ast$}{*}device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a7849d89208d4e123a5a1e1f3ef59331d}{ones\+\_\+like}} (a, dtype=None, order=\textquotesingle{}K\textquotesingle{}, subok=True, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}=None, \texorpdfstring{$\ast$}{*}device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_aade2724541787543a1827a980c099909}{\+\_\+full\+\_\+dispatcher}} (\mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}, fill\+\_\+value, dtype=None, order=None, \texorpdfstring{$\ast$}{*}device=None, like=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e}{full}} (\mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}, fill\+\_\+value, dtype=None, order=\textquotesingle{}C\textquotesingle{}, \texorpdfstring{$\ast$}{*}device=None, like=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a56166034fc25834a732ef8824e5e4adf}{\+\_\+full\+\_\+like\+\_\+dispatcher}} (a, fill\+\_\+value, dtype=None, order=None, subok=None, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}=None, \texorpdfstring{$\ast$}{*}device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_acc5be41537c4b6ece995a9c08aeb4cdc}{full\+\_\+like}} (a, fill\+\_\+value, dtype=None, order=\textquotesingle{}K\textquotesingle{}, subok=True, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}=None, \texorpdfstring{$\ast$}{*}device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a5899ba323fec4b81329824912f757e87}{\+\_\+count\+\_\+nonzero\+\_\+dispatcher}} (a, axis=None, \texorpdfstring{$\ast$}{*}keepdims=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad282b8e6572c9a069e692377baf1c0eb}{count\+\_\+nonzero}} (a, axis=None, \texorpdfstring{$\ast$}{*}keepdims=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_aad54fed8ccef7c670cd85b52e223ee6e}{isfortran}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a8528e9b74827a402d6d7314a8991a2db}{\+\_\+argwhere\+\_\+dispatcher}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a2a16214d4407259db6612d977478d657}{argwhere}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab8e52645f947f0355aea73fa5a2a600f}{\+\_\+flatnonzero\+\_\+dispatcher}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a287281d96a1e929bf9a65938caa11693}{flatnonzero}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad59bb0fb78cfa6a14fd18ff383e14b0a}{\+\_\+correlate\+\_\+dispatcher}} (a, v, mode=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab618a741d91aa55c546eabab4eaff1ce}{correlate}} (a, v, mode=\textquotesingle{}valid\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_abb48b1e4f36f1b26e12973aa2d657f8e}{\+\_\+convolve\+\_\+dispatcher}} (a, v, mode=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a7f5df8f16494553017d37b8e999dda5a}{convolve}} (a, v, mode=\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e}{full}}\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a3eb1c13fe5dea7d8d0b3ce53bd35d953}{\+\_\+outer\+\_\+dispatcher}} (a, b, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a9f025bfa8623d0e9687cd2e5edd10ffb}{outer}} (a, b, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad9e3bd0b60c5f9736271985bded6b775}{\+\_\+tensordot\+\_\+dispatcher}} (a, b, axes=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad83dbf7e90c8a0b6b6e862530733e965}{tensordot}} (a, b, axes=2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a03557156e381cbb40fd00d7577c54642}{\+\_\+roll\+\_\+dispatcher}} (a, shift, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a92b900df25ac501e7cbff264a87e9aa8}{roll}} (a, shift, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_acabf16070c6467549b0648e1462680c9}{\+\_\+rollaxis\+\_\+dispatcher}} (a, axis, start=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a5bfc842d4d95a565afed341492ccc09f}{rollaxis}} (a, axis, start=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a8d97bd19722098df0f39144bcc89790e}{normalize\+\_\+axis\+\_\+tuple}} (axis, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a4ae8341b31603e733fb920f0ae3a721e}{ndim}}, argname=None, allow\+\_\+duplicate=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a83e1df742dd6652d239ddda4d384d7ad}{\+\_\+moveaxis\+\_\+dispatcher}} (a, source, destination)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a4f3ebb1473edaf76b4fc4b3660a3e5af}{moveaxis}} (a, source, destination)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ae3f32f39d65002f367cf3dafe259eac3}{\+\_\+cross\+\_\+dispatcher}} (a, b, axisa=None, axisb=None, axisc=None, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a2666294076678a3a0b836a7d1ed2c93a}{cross}} (a, b, axisa=-\/1, axisb=-\/1, axisc=-\/1, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a0b306828d5ce3ad50b9d9a3e6f4e052a}{indices}} (dimensions, dtype=int, sparse=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a6efb6d563ebf0761e050a4f60c801877}{fromfunction}} (function, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}, \texorpdfstring{$\ast$}{*}dtype=float, like=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_aa5003e7f6377d960e0373553df288f51}{\+\_\+frombuffer}} (buf, dtype, \mbox{\hyperlink{namespacenumpy_1_1__core_1_1fromnumeric_a0b3042e9298e3d58c791fc29d2efe37e}{shape}}, order)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a3d9db3b3e3bca8791a1cf9df7282b792}{isscalar}} (element)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a754eb0367a6a4f42b59a6ee1b0171e68}{binary\+\_\+repr}} (num, width=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a1d256d9ff8719a2d3388d27cda4c1a85}{base\+\_\+repr}} (number, base=2, padding=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a2cc0547dc7e7775824d90e70382cb913}{\+\_\+maketup}} (descr, val)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a2c0cf3cd9bfa1f6bfe0b91c950d4de12}{identity}} (n, dtype=None, \texorpdfstring{$\ast$}{*}like=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a29ab054e37f9ced16ebbaf3f0f63cf42}{\+\_\+allclose\+\_\+dispatcher}} (a, b, rtol=None, atol=None, equal\+\_\+nan=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a81515572ba267078291d86bfcb490b2d}{allclose}} (a, b, rtol=1.e-\/5, atol=1.e-\/8, equal\+\_\+nan=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_acef6f249ec01e6cceea91036f4802ac3}{\+\_\+isclose\+\_\+dispatcher}} (a, b, rtol=None, atol=None, equal\+\_\+nan=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ae6146a594638338e2887ad6d2e38e8db}{isclose}} (a, b, rtol=1.e-\/5, atol=1.e-\/8, equal\+\_\+nan=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab03e7bab84ca6d71a94f50d99af6ac99}{\+\_\+array\+\_\+equal\+\_\+dispatcher}} (a1, a2, equal\+\_\+nan=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a0813e13054188aca70101e976b68a355}{\+\_\+dtype\+\_\+cannot\+\_\+hold\+\_\+nan}} (dtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a41366df77fc7183a8ca35c9e3a65f602}{array\+\_\+equal}} (a1, a2, equal\+\_\+nan=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_aadf96c8d126b33f8802c1ce5cec26bf5}{\+\_\+array\+\_\+equiv\+\_\+dispatcher}} (a1, a2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_aee0fe97bbeb9259b30cb1c87d2873cd8}{array\+\_\+equiv}} (a1, a2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad2c94ba267da548d4c49d7a16f905994}{\+\_\+astype\+\_\+dispatcher}} (x, dtype, \texorpdfstring{$\ast$}{*}copy=None, device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab976fa8ca600feb358a1fa97c9004b3b}{astype}} (x, dtype, \texorpdfstring{$\ast$}{*}copy=True, device=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a7ec53bee0db31dfb5ded8092cc0eaa06}{extend\+\_\+all}} (module)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad74553aaf1055d53a64fc508c437be6e}{bitwise\+\_\+not}} = invert
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a62a35b09344b5d48609c9255baf6f889}{ufunc}} = type(sin)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ad3ea1ab24ec8a70499d18381b3492a7d}{newaxis}} = None
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_abf0051441237a67299918d153157af1f}{array\+\_\+function\+\_\+dispatch}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a8d174ae9eccce95bcca8717acfac154b}{\+\_\+ones\+\_\+with\+\_\+like}} = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a0b6a3662d66df0f58507c38f29644a28}{ones}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_afdf292bb23e4fdf7047b031f3197efb1}{\+\_\+full\+\_\+with\+\_\+like}} = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e}{full}})
\item 
tuple \mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_af96e870c3d2e0474ad3cba10cae8a084}{little\+\_\+endian}} = (sys.\+byteorder == \textquotesingle{}little\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a6403d0ce77bffba9d51b7980a422ff48}{\+\_\+fromfunction\+\_\+with\+\_\+like}} = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a6efb6d563ebf0761e050a4f60c801877}{fromfunction}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab3869c913b8d2a3480a71d5ae018caf4}{\+\_\+identity\+\_\+with\+\_\+like}} = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a2c0cf3cd9bfa1f6bfe0b91c950d4de12}{identity}})
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a844fe76224368df870c8ec4bc72fa282}{\+\_\+no\+\_\+nan\+\_\+types}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_af9f195f519f3e1db71554550c730c055}{inf}} = PINF
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a76b4bd0b472b665f25a1feeb96d42a6a}{nan}} = NAN
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_af464b7220407b841a4e651eb71b523ed}{False\+\_\+}} = nt.\+bool(False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a55f18cb78115eeea34d34ddaee02db5d}{True\+\_\+}} = nt.\+bool(True)
\end{DoxyCompactItemize}


\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a29ab054e37f9ced16ebbaf3f0f63cf42}\label{namespacenumpy_1_1__core_1_1numeric_a29ab054e37f9ced16ebbaf3f0f63cf42} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_allclose\_dispatcher@{\_allclose\_dispatcher}}
\index{\_allclose\_dispatcher@{\_allclose\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_allclose\_dispatcher()}{\_allclose\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+allclose\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{rtol = {\ttfamily None},  }\item[{}]{atol = {\ttfamily None},  }\item[{}]{equal\+\_\+nan = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a8528e9b74827a402d6d7314a8991a2db}\label{namespacenumpy_1_1__core_1_1numeric_a8528e9b74827a402d6d7314a8991a2db} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_argwhere\_dispatcher@{\_argwhere\_dispatcher}}
\index{\_argwhere\_dispatcher@{\_argwhere\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_argwhere\_dispatcher()}{\_argwhere\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+argwhere\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ab03e7bab84ca6d71a94f50d99af6ac99}\label{namespacenumpy_1_1__core_1_1numeric_ab03e7bab84ca6d71a94f50d99af6ac99} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_array\_equal\_dispatcher@{\_array\_equal\_dispatcher}}
\index{\_array\_equal\_dispatcher@{\_array\_equal\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_array\_equal\_dispatcher()}{\_array\_equal\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+array\+\_\+equal\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a1,  }\item[{}]{a2,  }\item[{}]{equal\+\_\+nan = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_aadf96c8d126b33f8802c1ce5cec26bf5}\label{namespacenumpy_1_1__core_1_1numeric_aadf96c8d126b33f8802c1ce5cec26bf5} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_array\_equiv\_dispatcher@{\_array\_equiv\_dispatcher}}
\index{\_array\_equiv\_dispatcher@{\_array\_equiv\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_array\_equiv\_dispatcher()}{\_array\_equiv\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+array\+\_\+equiv\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a1,  }\item[{}]{a2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad2c94ba267da548d4c49d7a16f905994}\label{namespacenumpy_1_1__core_1_1numeric_ad2c94ba267da548d4c49d7a16f905994} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_astype\_dispatcher@{\_astype\_dispatcher}}
\index{\_astype\_dispatcher@{\_astype\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_astype\_dispatcher()}{\_astype\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+astype\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{dtype,  }\item[{\texorpdfstring{$\ast$}{*}}]{copy = {\ttfamily None},  }\item[{}]{device = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_abb48b1e4f36f1b26e12973aa2d657f8e}\label{namespacenumpy_1_1__core_1_1numeric_abb48b1e4f36f1b26e12973aa2d657f8e} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_convolve\_dispatcher@{\_convolve\_dispatcher}}
\index{\_convolve\_dispatcher@{\_convolve\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_convolve\_dispatcher()}{\_convolve\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+convolve\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad59bb0fb78cfa6a14fd18ff383e14b0a}\label{namespacenumpy_1_1__core_1_1numeric_ad59bb0fb78cfa6a14fd18ff383e14b0a} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_correlate\_dispatcher@{\_correlate\_dispatcher}}
\index{\_correlate\_dispatcher@{\_correlate\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_correlate\_dispatcher()}{\_correlate\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+correlate\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a5899ba323fec4b81329824912f757e87}\label{namespacenumpy_1_1__core_1_1numeric_a5899ba323fec4b81329824912f757e87} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_count\_nonzero\_dispatcher@{\_count\_nonzero\_dispatcher}}
\index{\_count\_nonzero\_dispatcher@{\_count\_nonzero\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_count\_nonzero\_dispatcher()}{\_count\_nonzero\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+count\+\_\+nonzero\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{keepdims = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ae3f32f39d65002f367cf3dafe259eac3}\label{namespacenumpy_1_1__core_1_1numeric_ae3f32f39d65002f367cf3dafe259eac3} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_cross\_dispatcher@{\_cross\_dispatcher}}
\index{\_cross\_dispatcher@{\_cross\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_cross\_dispatcher()}{\_cross\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+cross\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axisa = {\ttfamily None},  }\item[{}]{axisb = {\ttfamily None},  }\item[{}]{axisc = {\ttfamily None},  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a0813e13054188aca70101e976b68a355}\label{namespacenumpy_1_1__core_1_1numeric_a0813e13054188aca70101e976b68a355} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_dtype\_cannot\_hold\_nan@{\_dtype\_cannot\_hold\_nan}}
\index{\_dtype\_cannot\_hold\_nan@{\_dtype\_cannot\_hold\_nan}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_dtype\_cannot\_hold\_nan()}{\_dtype\_cannot\_hold\_nan()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+dtype\+\_\+cannot\+\_\+hold\+\_\+nan (\begin{DoxyParamCaption}\item[{}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ab8e52645f947f0355aea73fa5a2a600f}\label{namespacenumpy_1_1__core_1_1numeric_ab8e52645f947f0355aea73fa5a2a600f} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_flatnonzero\_dispatcher@{\_flatnonzero\_dispatcher}}
\index{\_flatnonzero\_dispatcher@{\_flatnonzero\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_flatnonzero\_dispatcher()}{\_flatnonzero\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+flatnonzero\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_aa5003e7f6377d960e0373553df288f51}\label{namespacenumpy_1_1__core_1_1numeric_aa5003e7f6377d960e0373553df288f51} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_frombuffer@{\_frombuffer}}
\index{\_frombuffer@{\_frombuffer}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_frombuffer()}{\_frombuffer()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+frombuffer (\begin{DoxyParamCaption}\item[{}]{buf,  }\item[{}]{dtype,  }\item[{}]{shape,  }\item[{}]{order }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_aade2724541787543a1827a980c099909}\label{namespacenumpy_1_1__core_1_1numeric_aade2724541787543a1827a980c099909} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_full\_dispatcher@{\_full\_dispatcher}}
\index{\_full\_dispatcher@{\_full\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_full\_dispatcher()}{\_full\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+full\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{shape,  }\item[{}]{fill\+\_\+value,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None},  }\item[{}]{like = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a56166034fc25834a732ef8824e5e4adf}\label{namespacenumpy_1_1__core_1_1numeric_a56166034fc25834a732ef8824e5e4adf} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_full\_like\_dispatcher@{\_full\_like\_dispatcher}}
\index{\_full\_like\_dispatcher@{\_full\_like\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_full\_like\_dispatcher()}{\_full\_like\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+full\+\_\+like\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{fill\+\_\+value,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{subok = {\ttfamily None},  }\item[{}]{shape = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_acef6f249ec01e6cceea91036f4802ac3}\label{namespacenumpy_1_1__core_1_1numeric_acef6f249ec01e6cceea91036f4802ac3} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_isclose\_dispatcher@{\_isclose\_dispatcher}}
\index{\_isclose\_dispatcher@{\_isclose\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_isclose\_dispatcher()}{\_isclose\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+isclose\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{rtol = {\ttfamily None},  }\item[{}]{atol = {\ttfamily None},  }\item[{}]{equal\+\_\+nan = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a2cc0547dc7e7775824d90e70382cb913}\label{namespacenumpy_1_1__core_1_1numeric_a2cc0547dc7e7775824d90e70382cb913} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_maketup@{\_maketup}}
\index{\_maketup@{\_maketup}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_maketup()}{\_maketup()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+maketup (\begin{DoxyParamCaption}\item[{}]{descr,  }\item[{}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a83e1df742dd6652d239ddda4d384d7ad}\label{namespacenumpy_1_1__core_1_1numeric_a83e1df742dd6652d239ddda4d384d7ad} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_moveaxis\_dispatcher@{\_moveaxis\_dispatcher}}
\index{\_moveaxis\_dispatcher@{\_moveaxis\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_moveaxis\_dispatcher()}{\_moveaxis\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+moveaxis\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{source,  }\item[{}]{destination }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_acd30c1072e03cffc13c475e00748b8d0}\label{namespacenumpy_1_1__core_1_1numeric_acd30c1072e03cffc13c475e00748b8d0} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_ones\_like\_dispatcher@{\_ones\_like\_dispatcher}}
\index{\_ones\_like\_dispatcher@{\_ones\_like\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_ones\_like\_dispatcher()}{\_ones\_like\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+ones\+\_\+like\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{subok = {\ttfamily None},  }\item[{}]{shape = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a3eb1c13fe5dea7d8d0b3ce53bd35d953}\label{namespacenumpy_1_1__core_1_1numeric_a3eb1c13fe5dea7d8d0b3ce53bd35d953} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_outer\_dispatcher@{\_outer\_dispatcher}}
\index{\_outer\_dispatcher@{\_outer\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_outer\_dispatcher()}{\_outer\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+outer\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{out = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a03557156e381cbb40fd00d7577c54642}\label{namespacenumpy_1_1__core_1_1numeric_a03557156e381cbb40fd00d7577c54642} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_roll\_dispatcher@{\_roll\_dispatcher}}
\index{\_roll\_dispatcher@{\_roll\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_roll\_dispatcher()}{\_roll\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+roll\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{shift,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_acabf16070c6467549b0648e1462680c9}\label{namespacenumpy_1_1__core_1_1numeric_acabf16070c6467549b0648e1462680c9} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_rollaxis\_dispatcher@{\_rollaxis\_dispatcher}}
\index{\_rollaxis\_dispatcher@{\_rollaxis\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_rollaxis\_dispatcher()}{\_rollaxis\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+rollaxis\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis,  }\item[{}]{start = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad9e3bd0b60c5f9736271985bded6b775}\label{namespacenumpy_1_1__core_1_1numeric_ad9e3bd0b60c5f9736271985bded6b775} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_tensordot\_dispatcher@{\_tensordot\_dispatcher}}
\index{\_tensordot\_dispatcher@{\_tensordot\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_tensordot\_dispatcher()}{\_tensordot\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+tensordot\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axes = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_aeed315fa619da9956246b3267f3b193b}\label{namespacenumpy_1_1__core_1_1numeric_aeed315fa619da9956246b3267f3b193b} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_zeros\_like\_dispatcher@{\_zeros\_like\_dispatcher}}
\index{\_zeros\_like\_dispatcher@{\_zeros\_like\_dispatcher}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_zeros\_like\_dispatcher()}{\_zeros\_like\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+zeros\+\_\+like\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{subok = {\ttfamily None},  }\item[{}]{shape = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a81515572ba267078291d86bfcb490b2d}\label{namespacenumpy_1_1__core_1_1numeric_a81515572ba267078291d86bfcb490b2d} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!allclose@{allclose}}
\index{allclose@{allclose}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{allclose()}{allclose()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+allclose (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{rtol = {\ttfamily 1.e-\/5},  }\item[{}]{atol = {\ttfamily 1.e-\/8},  }\item[{}]{equal\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

.. warning:: The default `atol` is not appropriate for comparing numbers
             with magnitudes much smaller than one (see Notes).

NaNs are treated as equal if they are in the same place and if
``equal_nan=True``.  Infs are treated as equal if they are in the same
place and of the same sign in both arrays.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : array_like
    The relative tolerance parameter (see Notes).
atol : array_like
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

Returns
-------
allclose : bool
    Returns True if the two arrays are equal within the given
    tolerance; False otherwise.

See Also
--------
isclose, all, any, equal

Notes
-----
If the following equation is element-wise True, then allclose returns
True.::

 absolute(a - b) <= (atol + rtol * absolute(b))

The above equation is not symmetric in `a` and `b`, so that
``allclose(a, b)`` might be different from ``allclose(b, a)`` in
some rare cases.

The default value of `atol` is not appropriate when the reference value
`b` has magnitude smaller than one. For example, it is unlikely that
``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
``allclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
to select `atol` for the use case at hand, especially for defining the
threshold below which a non-zero value in `a` will be considered "close"
to a very small or zero value in `b`.

The comparison of `a` and `b` uses standard broadcasting, which
means that `a` and `b` need not have the same shape in order for
``allclose(a, b)`` to evaluate to True.  The same is true for
`equal` but not `array_equal`.

`allclose` is not defined for non-numeric data types.
`bool` is considered a numeric data-type for this purpose.

Examples
--------
>>> import numpy as np
>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False

>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True

>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False

>>> np.allclose([1.0, np.nan], [1.0, np.nan])
False

>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a2a16214d4407259db6612d977478d657}\label{namespacenumpy_1_1__core_1_1numeric_a2a16214d4407259db6612d977478d657} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!argwhere@{argwhere}}
\index{argwhere@{argwhere}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{argwhere()}{argwhere()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+argwhere (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the indices of array elements that are non-zero, grouped by element.

Parameters
----------
a : array_like
    Input data.

Returns
-------
index_array : (N, a.ndim) ndarray
    Indices of elements that are non-zero. Indices are grouped by element.
    This array will have shape ``(N, a.ndim)`` where ``N`` is the number of
    non-zero items.

See Also
--------
where, nonzero

Notes
-----
``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,
but produces a result of the correct shape for a 0D array.

The output of ``argwhere`` is not suitable for indexing arrays.
For this purpose use ``nonzero(a)`` instead.

Examples
--------
>>> import numpy as np
>>> x = np.arange(6).reshape(2,3)
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.argwhere(x>1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a41366df77fc7183a8ca35c9e3a65f602}\label{namespacenumpy_1_1__core_1_1numeric_a41366df77fc7183a8ca35c9e3a65f602} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!array\_equal@{array\_equal}}
\index{array\_equal@{array\_equal}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{array\_equal()}{array\_equal()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+array\+\_\+equal (\begin{DoxyParamCaption}\item[{}]{a1,  }\item[{}]{a2,  }\item[{}]{equal\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}True if two arrays have the same shape and elements, False otherwise.

Parameters
----------
a1, a2 : array_like
    Input arrays.
equal_nan : bool
    Whether to compare NaN's as equal. If the dtype of a1 and a2 is
    complex, values will be considered equal if either the real or the
    imaginary component of a given value is ``nan``.

Returns
-------
b : bool
    Returns True if the arrays are equal.

See Also
--------
allclose: Returns True if two arrays are element-wise equal within a
          tolerance.
array_equiv: Returns True if input arrays are shape consistent and all
             elements equal.

Examples
--------
>>> import numpy as np

>>> np.array_equal([1, 2], [1, 2])
True

>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
True

>>> np.array_equal([1, 2], [1, 2, 3])
False

>>> np.array_equal([1, 2], [1, 4])
False

>>> a = np.array([1, np.nan])
>>> np.array_equal(a, a)
False

>>> np.array_equal(a, a, equal_nan=True)
True

When ``equal_nan`` is True, complex values with nan components are
considered equal if either the real *or* the imaginary components are nan.

>>> a = np.array([1 + 1j])
>>> b = a.copy()
>>> a.real = np.nan
>>> b.imag = np.nan
>>> np.array_equal(a, b, equal_nan=True)
True
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_aee0fe97bbeb9259b30cb1c87d2873cd8}\label{namespacenumpy_1_1__core_1_1numeric_aee0fe97bbeb9259b30cb1c87d2873cd8} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!array\_equiv@{array\_equiv}}
\index{array\_equiv@{array\_equiv}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{array\_equiv()}{array\_equiv()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+array\+\_\+equiv (\begin{DoxyParamCaption}\item[{}]{a1,  }\item[{}]{a2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
out : bool
    True if equivalent, False otherwise.

Examples
--------
>>> import numpy as np
>>> np.array_equiv([1, 2], [1, 2])
True
>>> np.array_equiv([1, 2], [1, 3])
False

Showing the shape equivalence:

>>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
True
>>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
False

>>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_ab976fa8ca600feb358a1fa97c9004b3b}\label{namespacenumpy_1_1__core_1_1numeric_ab976fa8ca600feb358a1fa97c9004b3b} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!astype@{astype}}
\index{astype@{astype}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{astype()}{astype()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+astype (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{dtype,  }\item[{\texorpdfstring{$\ast$}{*}}]{copy = {\ttfamily True},  }\item[{}]{device = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Copies an array to a specified data type.

This function is an Array API compatible alternative to
`numpy.ndarray.astype`.

Parameters
----------
x : ndarray
    Input NumPy array to cast. ``array_likes`` are explicitly not
    supported here.
dtype : dtype
    Data type of the result.
copy : bool, optional
    Specifies whether to copy an array when the specified dtype matches
    the data type of the input array ``x``. If ``True``, a newly allocated
    array must always be returned. If ``False`` and the specified dtype
    matches the data type of the input array, the input array must be
    returned; otherwise, a newly allocated array must be returned.
    Defaults to ``True``.
device : str, optional
    The device on which to place the returned array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.1.0

Returns
-------
out : ndarray
    An array having the specified data type.

See Also
--------
ndarray.astype

Examples
--------
>>> import numpy as np
>>> arr = np.array([1, 2, 3]); arr
array([1, 2, 3])
>>> np.astype(arr, np.float64)
array([1., 2., 3.])

Non-copy case:

>>> arr = np.array([1, 2, 3])
>>> arr_noncpy = np.astype(arr, arr.dtype, copy=False)
>>> np.shares_memory(arr, arr_noncpy)
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a1d256d9ff8719a2d3388d27cda4c1a85}\label{namespacenumpy_1_1__core_1_1numeric_a1d256d9ff8719a2d3388d27cda4c1a85} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!base\_repr@{base\_repr}}
\index{base\_repr@{base\_repr}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{base\_repr()}{base\_repr()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+base\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{number,  }\item[{}]{base = {\ttfamily 2},  }\item[{}]{padding = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string representation of a number in the given base system.

Parameters
----------
number : int
    The value to convert. Positive and negative values are handled.
base : int, optional
    Convert `number` to the `base` number system. The valid range is 2-36,
    the default value is 2.
padding : int, optional
    Number of zeros padded on the left. Default is 0 (no padding).

Returns
-------
out : str
    String representation of `number` in `base` system.

See Also
--------
binary_repr : Faster version of `base_repr` for base 2.

Examples
--------
>>> import numpy as np
>>> np.base_repr(5)
'101'
>>> np.base_repr(6, 5)
'11'
>>> np.base_repr(7, base=5, padding=3)
'00012'

>>> np.base_repr(10, base=16)
'A'
>>> np.base_repr(32, base=16)
'20'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a754eb0367a6a4f42b59a6ee1b0171e68}\label{namespacenumpy_1_1__core_1_1numeric_a754eb0367a6a4f42b59a6ee1b0171e68} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!binary\_repr@{binary\_repr}}
\index{binary\_repr@{binary\_repr}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{binary\_repr()}{binary\_repr()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+binary\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{num,  }\item[{}]{width = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the binary representation of the input number as a string.

For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
num : int
    Only an integer decimal number can be used.
width : int, optional
    The length of the returned string if `num` is positive, or the length
    of the two's complement if `num` is negative, provided that `width` is
    at least a sufficient number of bits for `num` to be represented in
    the designated form. If the `width` value is insufficient, an error is
    raised.

Returns
-------
bin : str
    Binary representation of `num` or two's complement of `num`.

See Also
--------
base_repr: Return a string representation of a number in the given base
           system.
bin: Python's built-in binary representation generator of an integer.

Notes
-----
`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
faster.

References
----------
.. [1] Wikipedia, "Two's complement",
    https://en.wikipedia.org/wiki/Two's_complement

Examples
--------
>>> import numpy as np
>>> np.binary_repr(3)
'11'
>>> np.binary_repr(-3)
'-11'
>>> np.binary_repr(3, width=4)
'0011'

The two's complement is returned when the input number is negative and
width is specified:

>>> np.binary_repr(-3, width=3)
'101'
>>> np.binary_repr(-3, width=5)
'11101'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a7f5df8f16494553017d37b8e999dda5a}\label{namespacenumpy_1_1__core_1_1numeric_a7f5df8f16494553017d37b8e999dda5a} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!convolve@{convolve}}
\index{convolve@{convolve}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{convolve()}{convolve()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+convolve (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily \textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e}{full}}\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the discrete, linear convolution of two one-dimensional sequences.

The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal [1]_.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.

If `v` is longer than `a`, the arrays are swapped before computation.

Parameters
----------
a : (N,) array_like
    First one-dimensional input array.
v : (M,) array_like
    Second one-dimensional input array.
mode : {'full', 'valid', 'same'}, optional
    'full':
      By default, mode is 'full'.  This returns the convolution
      at each point of overlap, with an output shape of (N+M-1,). At
      the end-points of the convolution, the signals do not overlap
      completely, and boundary effects may be seen.

    'same':
      Mode 'same' returns output of length ``max(M, N)``.  Boundary
      effects are still visible.

    'valid':
      Mode 'valid' returns output of length
      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
      for points where the signals overlap completely.  Values outside
      the signal boundary have no effect.

Returns
-------
out : ndarray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
                           Transform.
scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also
          accepts poly1d objects as input.

Notes
-----
The discrete convolution operation is defined as

.. math:: (a * v)_n = \\sum_{m = -\\infty}^{\\infty} a_m v_{n - m}

It can be shown that a convolution :math:`x(t) * y(t)` in time/space
is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function `scipy.signal.fftconvolve` exploits the
FFT to calculate the convolution of large data-sets.

References
----------
.. [1] Wikipedia, "Convolution",
    https://en.wikipedia.org/wiki/Convolution

Examples
--------
Note how the convolution operator flips the second array
before "sliding" the two across one another:

>>> import numpy as np
>>> np.convolve([1, 2, 3], [0, 1, 0.5])
array([0. , 1. , 2.5, 4. , 1.5])

Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:

>>> np.convolve([1,2,3],[0,1,0.5], 'same')
array([1. ,  2.5,  4. ])

The two arrays are of the same length, so there
is only one position where they completely overlap:

>>> np.convolve([1,2,3],[0,1,0.5], 'valid')
array([2.5])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_ab618a741d91aa55c546eabab4eaff1ce}\label{namespacenumpy_1_1__core_1_1numeric_ab618a741d91aa55c546eabab4eaff1ce} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!correlate@{correlate}}
\index{correlate@{correlate}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{correlate()}{correlate()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+correlate (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily \textquotesingle{}valid\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cross-correlation of two 1-dimensional sequences.

This function computes the correlation as generally defined in signal
processing texts [1]_:

.. math:: c_k = \sum_n a_{n+k} \cdot \overline{v}_n

with a and v sequences being zero-padded where necessary and
:math:`\overline v` denoting complex conjugation.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.

Returns
-------
out : ndarray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
convolve : Discrete, linear convolution of two one-dimensional sequences.
scipy.signal.correlate : uses FFT which has superior performance
    on large arrays.

Notes
-----
The definition of correlation above is not unique and sometimes
correlation may be defined differently. Another common definition is [1]_:

.. math:: c'_k = \sum_n a_{n} \cdot \overline{v_{n+k}}

which is related to :math:`c_k` by :math:`c'_k = c_{-k}`.

`numpy.correlate` may perform slowly in large arrays (i.e. n = 1e5)
because it does not use the FFT to compute the convolution; in that case,
`scipy.signal.correlate` might be preferable.

References
----------
.. [1] Wikipedia, "Cross-correlation",
       https://en.wikipedia.org/wiki/Cross-correlation

Examples
--------
>>> import numpy as np
>>> np.correlate([1, 2, 3], [0, 1, 0.5])
array([3.5])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
array([2. ,  3.5,  3. ])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
array([0.5,  2. ,  3.5,  3. ,  0. ])

Using complex sequences:

>>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])

Note that you get the time reversed, complex conjugated result
(:math:`\overline{c_{-k}}`) when the two input sequences a and v change
places:

>>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad282b8e6572c9a069e692377baf1c0eb}\label{namespacenumpy_1_1__core_1_1numeric_ad282b8e6572c9a069e692377baf1c0eb} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!count\_nonzero@{count\_nonzero}}
\index{count\_nonzero@{count\_nonzero}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{count\_nonzero()}{count\_nonzero()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+count\+\_\+nonzero (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{keepdims = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Counts the number of non-zero values in the array ``a``.

The word "non-zero" is in reference to the Python 2.x
built-in method ``__nonzero__()`` (renamed ``__bool__()``
in Python 3.x) of Python objects that tests an object's
"truthfulness". For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in ``a`` (and in
sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
method evaluated to ``True``.

Parameters
----------
a : array_like
    The array for which to count non-zeros.
axis : int or tuple, optional
    Axis or tuple of axes along which to count non-zeros.
    Default is None, meaning that non-zeros will be counted
    along a flattened version of ``a``.
keepdims : bool, optional
    If this is set to True, the axes that are counted are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

Returns
-------
count : int or array of int
    Number of non-zero values in the array along a given axis.
    Otherwise, the total number of non-zero values in the array
    is returned.

See Also
--------
nonzero : Return the coordinates of all the non-zero values.

Examples
--------
>>> import numpy as np
>>> np.count_nonzero(np.eye(4))
4
>>> a = np.array([[0, 1, 7, 0],
...               [3, 0, 2, 19]])
>>> np.count_nonzero(a)
5
>>> np.count_nonzero(a, axis=0)
array([1, 1, 2, 1])
>>> np.count_nonzero(a, axis=1)
array([2, 3])
>>> np.count_nonzero(a, axis=1, keepdims=True)
array([[2],
       [3]])
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a2666294076678a3a0b836a7d1ed2c93a}\label{namespacenumpy_1_1__core_1_1numeric_a2666294076678a3a0b836a7d1ed2c93a} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!cross@{cross}}
\index{cross@{cross}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{cross()}{cross()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+cross (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axisa = {\ttfamily -\/1},  }\item[{}]{axisb = {\ttfamily -\/1},  }\item[{}]{axisc = {\ttfamily -\/1},  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the cross product of two (arrays of) vectors.

The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
are defined by the last axis of `a` and `b` by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.

Parameters
----------
a : array_like
    Components of the first vector(s).
b : array_like
    Components of the second vector(s).
axisa : int, optional
    Axis of `a` that defines the vector(s).  By default, the last axis.
axisb : int, optional
    Axis of `b` that defines the vector(s).  By default, the last axis.
axisc : int, optional
    Axis of `c` containing the cross product vector(s).  Ignored if
    both input vectors have dimension 2, as the return is scalar.
    By default, the last axis.
axis : int, optional
    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.

Returns
-------
c : ndarray
    Vector cross product(s).

Raises
------
ValueError
    When the dimension of the vector(s) in `a` and/or `b` does not
    equal 2 or 3.

See Also
--------
inner : Inner product
outer : Outer product.
linalg.cross : An Array API compatible variation of ``np.cross``,
               which accepts (arrays of) 3-element vectors only.
ix_ : Construct index arrays.

Notes
-----
Supports full broadcasting of the inputs.

Dimension-2 input arrays were deprecated in 2.0.0. If you do need this
functionality, you can use::

    def cross2d(x, y):
        return x[..., 0] * y[..., 1] - x[..., 1] * y[..., 0]

Examples
--------
Vector cross-product.

>>> import numpy as np
>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([-3,  6, -3])

One vector with dimension 2.

>>> x = [1, 2]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])

Equivalently:

>>> x = [1, 2, 0]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])

Both vectors with dimension 2.

>>> x = [1,2]
>>> y = [4,5]
>>> np.cross(x, y)
array(-3)

Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the *right-hand rule*.

>>> x = np.array([[1,2,3], [4,5,6]])
>>> y = np.array([[4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])

The orientation of `c` can be changed using the `axisc` keyword.

>>> np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])

Change the vector definition of `x` and `y` using `axisa` and `axisb`.

>>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
>>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
>>> np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a7ec53bee0db31dfb5ded8092cc0eaa06}\label{namespacenumpy_1_1__core_1_1numeric_a7ec53bee0db31dfb5ded8092cc0eaa06} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!extend\_all@{extend\_all}}
\index{extend\_all@{extend\_all}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{extend\_all()}{extend\_all()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+extend\+\_\+all (\begin{DoxyParamCaption}\item[{}]{module }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a287281d96a1e929bf9a65938caa11693}\label{namespacenumpy_1_1__core_1_1numeric_a287281d96a1e929bf9a65938caa11693} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!flatnonzero@{flatnonzero}}
\index{flatnonzero@{flatnonzero}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{flatnonzero()}{flatnonzero()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+flatnonzero (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return indices that are non-zero in the flattened version of a.

This is equivalent to ``np.nonzero(np.ravel(a))[0]``.

Parameters
----------
a : array_like
    Input data.

Returns
-------
res : ndarray
    Output array, containing the indices of the elements of ``a.ravel()``
    that are non-zero.

See Also
--------
nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.

Examples
--------
>>> import numpy as np
>>> x = np.arange(-2, 3)
>>> x
array([-2, -1,  0,  1,  2])
>>> np.flatnonzero(x)
array([0, 1, 3, 4])

Use the indices of the non-zero elements as an index array to extract
these elements:

>>> x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a6efb6d563ebf0761e050a4f60c801877}\label{namespacenumpy_1_1__core_1_1numeric_a6efb6d563ebf0761e050a4f60c801877} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!fromfunction@{fromfunction}}
\index{fromfunction@{fromfunction}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{fromfunction()}{fromfunction()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+fromfunction (\begin{DoxyParamCaption}\item[{}]{function,  }\item[{}]{shape,  }\item[{\texorpdfstring{$\ast$}{*}}]{dtype = {\ttfamily float},  }\item[{}]{like = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
function : callable
    The function is called with N parameters, where N is the rank of
    `shape`.  Each parameter represents the coordinates of the array
    varying along a specific axis.  For example, if `shape`
    were ``(2, 2)``, then the parameters would be
    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `function`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `function`.
    By default, `dtype` is float.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
fromfunction : any
    The result of the call to `function` is passed back directly.
    Therefore the shape of `fromfunction` is completely determined by
    `function`.  If `function` returns a scalar value, the shape of
    `fromfunction` would not match the `shape` parameter.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `dtype` and `like` are passed to `function`.

Examples
--------
>>> import numpy as np
>>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)
array([[0., 0.],
       [1., 1.]])

>>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)
array([[0., 1.],
       [0., 1.]])

>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e}\label{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!full@{full}}
\index{full@{full}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{full()}{full()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+full (\begin{DoxyParamCaption}\item[{}]{shape,  }\item[{}]{fill\+\_\+value,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}C\textquotesingle{}},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None},  }\item[{}]{like = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new array of given shape and type, filled with `fill_value`.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
fill_value : scalar or array_like
    Fill value.
dtype : data-type, optional
    The desired data-type for the array  The default, None, means
     ``np.array(fill_value).dtype``.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.
device : str, optional
    The device on which to place the created array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.0.0
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    Array of `fill_value` with the given shape, dtype, and order.

See Also
--------
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.

Examples
--------
>>> import numpy as np
>>> np.full((2, 2), np.inf)
array([[inf, inf],
       [inf, inf]])
>>> np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])

>>> np.full((2, 2), [1, 2])
array([[1, 2],
       [1, 2]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_acc5be41537c4b6ece995a9c08aeb4cdc}\label{namespacenumpy_1_1__core_1_1numeric_acc5be41537c4b6ece995a9c08aeb4cdc} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!full\_like@{full\_like}}
\index{full\_like@{full\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{full\_like()}{full\_like()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+full\+\_\+like (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{fill\+\_\+value,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily True},  }\item[{}]{shape = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a full array with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
fill_value : array_like
    Fill value.
dtype : data-type, optional
    Overrides the data type of the result.
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `a`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.
device : str, optional
    The device on which to place the created array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    Array of `fill_value` with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.

Examples
--------
>>> import numpy as np
>>> x = np.arange(6, dtype=int)
>>> np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
>>> np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
>>> np.full_like(x, 0.1, dtype=np.double)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
>>> np.full_like(x, np.nan, dtype=np.double)
array([nan, nan, nan, nan, nan, nan])

>>> y = np.arange(6, dtype=np.double)
>>> np.full_like(y, 0.1)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])

>>> y = np.zeros([2, 2, 3], dtype=int)
>>> np.full_like(y, [0, 0, 255])
array([[[  0,   0, 255],
        [  0,   0, 255]],
       [[  0,   0, 255],
        [  0,   0, 255]]])
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a2c0cf3cd9bfa1f6bfe0b91c950d4de12}\label{namespacenumpy_1_1__core_1_1numeric_a2c0cf3cd9bfa1f6bfe0b91c950d4de12} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!identity@{identity}}
\index{identity@{identity}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{identity()}{identity()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+identity (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{dtype = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{like = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
>>> import numpy as np
>>> np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a0b306828d5ce3ad50b9d9a3e6f4e052a}\label{namespacenumpy_1_1__core_1_1numeric_a0b306828d5ce3ad50b9d9a3e6f4e052a} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!indices@{indices}}
\index{indices@{indices}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{indices()}{indices()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+indices (\begin{DoxyParamCaption}\item[{}]{dimensions,  }\item[{}]{dtype = {\ttfamily int},  }\item[{}]{sparse = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0, 1, ...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.
sparse : boolean, optional
    Return a sparse representation of the grid instead of a dense
    representation. Default is False.

Returns
-------
grid : one ndarray or tuple of ndarrays
    If sparse is False:
        Returns one array of grid indices,
        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
    If sparse is True:
        Returns a tuple of arrays, with
        ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
        dimensions[i] in the ith place

See Also
--------
mgrid, ogrid, meshgrid

Notes
-----
The output shape in the dense case is obtained by prepending the number
of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N, r0, ..., rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k, i0, i1, ..., iN-1] = ik

Examples
--------
>>> import numpy as np
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.

If sparse is set to true, the grid will be returned in a sparse
representation.

>>> i, j = np.indices((2, 3), sparse=True)
>>> i.shape
(2, 1)
>>> j.shape
(1, 3)
>>> i        # row indices
array([[0],
       [1]])
>>> j        # column indices
array([[0, 1, 2]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_ae6146a594638338e2887ad6d2e38e8db}\label{namespacenumpy_1_1__core_1_1numeric_ae6146a594638338e2887ad6d2e38e8db} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!isclose@{isclose}}
\index{isclose@{isclose}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{isclose()}{isclose()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+isclose (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{rtol = {\ttfamily 1.e-\/5},  }\item[{}]{atol = {\ttfamily 1.e-\/8},  }\item[{}]{equal\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a boolean array where two arrays are element-wise equal within a
tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

.. warning:: The default `atol` is not appropriate for comparing numbers
             with magnitudes much smaller than one (see Notes).

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : array_like
    The relative tolerance parameter (see Notes).
atol : array_like
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

Returns
-------
y : array_like
    Returns a boolean array of where `a` and `b` are equal within the
    given tolerance. If both `a` and `b` are scalars, returns a single
    boolean value.

See Also
--------
allclose
math.isclose

Notes
-----
For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.::

 absolute(a - b) <= (atol + rtol * absolute(b))

Unlike the built-in `math.isclose`, the above equation is not symmetric
in `a` and `b` -- it assumes `b` is the reference value -- so that
`isclose(a, b)` might be different from `isclose(b, a)`.

The default value of `atol` is not appropriate when the reference value
`b` has magnitude smaller than one. For example, it is unlikely that
``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
to select `atol` for the use case at hand, especially for defining the
threshold below which a non-zero value in `a` will be considered "close"
to a very small or zero value in `b`.

`isclose` is not defined for non-numeric data types.
:class:`bool` is considered a numeric data-type for this purpose.

Examples
--------
>>> import numpy as np
>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
array([ True, False])

>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
array([ True, True])

>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
array([False,  True])

>>> np.isclose([1.0, np.nan], [1.0, np.nan])
array([ True, False])

>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
array([ True, True])

>>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
array([ True, False])

>>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
array([False, False])

>>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
array([ True,  True])

>>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
array([False,  True])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_aad54fed8ccef7c670cd85b52e223ee6e}\label{namespacenumpy_1_1__core_1_1numeric_aad54fed8ccef7c670cd85b52e223ee6e} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!isfortran@{isfortran}}
\index{isfortran@{isfortran}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{isfortran()}{isfortran()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+isfortran (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if the array is Fortran contiguous but *not* C contiguous.

This function is obsolete. If you only want to check if an array is Fortran
contiguous use ``a.flags.f_contiguous`` instead.

Parameters
----------
a : ndarray
    Input array.

Returns
-------
isfortran : bool
    Returns True if the array is Fortran contiguous but *not* C contiguous.


Examples
--------

np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).

>>> import numpy as np
>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False

>>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
>>> b
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(b)
True


The transpose of a C-ordered array is a FORTRAN-ordered array.

>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False
>>> b = a.T
>>> b
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> np.isfortran(b)
True

C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.

>>> np.isfortran(np.array([1, 2], order='F'))
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a3d9db3b3e3bca8791a1cf9df7282b792}\label{namespacenumpy_1_1__core_1_1numeric_a3d9db3b3e3bca8791a1cf9df7282b792} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!isscalar@{isscalar}}
\index{isscalar@{isscalar}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{isscalar()}{isscalar()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+isscalar (\begin{DoxyParamCaption}\item[{}]{element }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if the type of `element` is a scalar type.

Parameters
----------
element : any
    Input argument, can be of any type and shape.

Returns
-------
val : bool
    True if `element` is a scalar type, False if it is not.

See Also
--------
ndim : Get the number of dimensions of an array

Notes
-----
If you need a stricter way to identify a *numerical* scalar, use
``isinstance(x, numbers.Number)``, as that returns ``False`` for most
non-numerical elements such as strings.

In most cases ``np.ndim(x) == 0`` should be used instead of this function,
as that will also return true for 0d arrays. This is how numpy overloads
functions in the style of the ``dx`` arguments to `gradient` and
the ``bins`` argument to `histogram`. Some key differences:

+------------------------------------+---------------+-------------------+
| x                                  |``isscalar(x)``|``np.ndim(x) == 0``|
+====================================+===============+===================+
| PEP 3141 numeric objects           | ``True``      | ``True``          |
| (including builtins)               |               |                   |
+------------------------------------+---------------+-------------------+
| builtin string and buffer objects  | ``True``      | ``True``          |
+------------------------------------+---------------+-------------------+
| other builtin objects, like        | ``False``     | ``True``          |
| `pathlib.Path`, `Exception`,       |               |                   |
| the result of `re.compile`         |               |                   |
+------------------------------------+---------------+-------------------+
| third-party objects like           | ``False``     | ``True``          |
| `matplotlib.figure.Figure`         |               |                   |
+------------------------------------+---------------+-------------------+
| zero-dimensional numpy arrays      | ``False``     | ``True``          |
+------------------------------------+---------------+-------------------+
| other numpy arrays                 | ``False``     | ``False``         |
+------------------------------------+---------------+-------------------+
| `list`, `tuple`, and other         | ``False``     | ``False``         |
| sequence objects                   |               |                   |
+------------------------------------+---------------+-------------------+

Examples
--------
>>> import numpy as np

>>> np.isscalar(3.1)
True

>>> np.isscalar(np.array(3.1))
False

>>> np.isscalar([3.1])
False

>>> np.isscalar(False)
True

>>> np.isscalar('numpy')
True

NumPy supports PEP 3141 numbers:

>>> from fractions import Fraction
>>> np.isscalar(Fraction(5, 17))
True
>>> from numbers import Number
>>> np.isscalar(Number())
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a4f3ebb1473edaf76b4fc4b3660a3e5af}\label{namespacenumpy_1_1__core_1_1numeric_a4f3ebb1473edaf76b4fc4b3660a3e5af} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!moveaxis@{moveaxis}}
\index{moveaxis@{moveaxis}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{moveaxis()}{moveaxis()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+moveaxis (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{source,  }\item[{}]{destination }\end{DoxyParamCaption})}

\begin{DoxyVerb}Move axes of an array to new positions.

Other axes remain in their original order.

Parameters
----------
a : np.ndarray
    The array whose axes should be reordered.
source : int or sequence of int
    Original positions of the axes to move. These must be unique.
destination : int or sequence of int
    Destination positions for each of the original axes. These must also be
    unique.

Returns
-------
result : np.ndarray
    Array with moved axes. This array is a view of the input array.

See Also
--------
transpose : Permute the dimensions of an array.
swapaxes : Interchange two axes of an array.

Examples
--------
>>> import numpy as np
>>> x = np.zeros((3, 4, 5))
>>> np.moveaxis(x, 0, -1).shape
(4, 5, 3)
>>> np.moveaxis(x, -1, 0).shape
(5, 3, 4)

These all achieve the same result:

>>> np.transpose(x).shape
(5, 4, 3)
>>> np.swapaxes(x, 0, -1).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1], [-1, -2]).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
(5, 4, 3)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a8d97bd19722098df0f39144bcc89790e}\label{namespacenumpy_1_1__core_1_1numeric_a8d97bd19722098df0f39144bcc89790e} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!normalize\_axis\_tuple@{normalize\_axis\_tuple}}
\index{normalize\_axis\_tuple@{normalize\_axis\_tuple}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{normalize\_axis\_tuple()}{normalize\_axis\_tuple()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+normalize\+\_\+axis\+\_\+tuple (\begin{DoxyParamCaption}\item[{}]{axis,  }\item[{}]{ndim,  }\item[{}]{argname = {\ttfamily None},  }\item[{}]{allow\+\_\+duplicate = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Normalizes an axis argument into a tuple of non-negative integer axes.

This handles shorthands such as ``1`` and converts them to ``(1,)``,
as well as performing the handling of negative indices covered by
`normalize_axis_index`.

By default, this forbids axes from being specified multiple times.

Used internally by multi-axis-checking logic.

Parameters
----------
axis : int, iterable of int
    The un-normalized index or indices of the axis.
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against.
argname : str, optional
    A prefix to put before the error message, typically the name of the
    argument.
allow_duplicate : bool, optional
    If False, the default, disallow an axis from being specified twice.

Returns
-------
normalized_axes : tuple of int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If any axis provided is out of range
ValueError
    If an axis is repeated

See also
--------
normalize_axis_index : normalizing a single scalar axis
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a0b6a3662d66df0f58507c38f29644a28}\label{namespacenumpy_1_1__core_1_1numeric_a0b6a3662d66df0f58507c38f29644a28} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!ones@{ones}}
\index{ones@{ones}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{ones()}{ones()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+ones (\begin{DoxyParamCaption}\item[{}]{shape,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}C\textquotesingle{}},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None},  }\item[{}]{like = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.
device : str, optional
    The device on which to place the created array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.0.0
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.

Examples
--------
>>> import numpy as np
>>> np.ones(5)
array([1., 1., 1., 1., 1.])

>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

>>> np.ones((2, 1))
array([[1.],
       [1.]])

>>> s = (2,2)
>>> np.ones(s)
array([[1.,  1.],
       [1.,  1.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a7849d89208d4e123a5a1e1f3ef59331d}\label{namespacenumpy_1_1__core_1_1numeric_a7849d89208d4e123a5a1e1f3ef59331d} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!ones\_like@{ones\_like}}
\index{ones\_like@{ones\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{ones\_like()}{ones\_like()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+ones\+\_\+like (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily True},  }\item[{}]{shape = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array of ones with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `a`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.
device : str, optional
    The device on which to place the created array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    Array of ones with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.

Examples
--------
>>> import numpy as np
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])

>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.ones_like(y)
array([1.,  1.,  1.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a9f025bfa8623d0e9687cd2e5edd10ffb}\label{namespacenumpy_1_1__core_1_1numeric_a9f025bfa8623d0e9687cd2e5edd10ffb} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!outer@{outer}}
\index{outer@{outer}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{outer()}{outer()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+outer (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{out = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the outer product of two vectors.

Given two vectors `a` and `b` of length ``M`` and ``N``, respectively,
the outer product [1]_ is::

  [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]
   [a_1*b_0    .
   [ ...          .
   [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to dimensions other than 1D and other
              operations. ``np.multiply.outer(a.ravel(), b.ravel())``
              is the equivalent.
linalg.outer : An Array API compatible variation of ``np.outer``,
               which accepts 1-dimensional inputs only.
tensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``
            is the equivalent.

References
----------
.. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
       ed., Baltimore, MD, Johns Hopkins University Press, 1996,
       pg. 8.

Examples
--------
Make a (*very* coarse) grid for computing a Mandelbrot set:

>>> import numpy as np
>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a "vector" of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a92b900df25ac501e7cbff264a87e9aa8}\label{namespacenumpy_1_1__core_1_1numeric_a92b900df25ac501e7cbff264a87e9aa8} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!roll@{roll}}
\index{roll@{roll}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{roll()}{roll()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+roll (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{shift,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int or tuple of ints
    The number of places by which elements are shifted.  If a tuple,
    then `axis` must be a tuple of the same size, and each of the
    given axes is shifted by the corresponding number.  If an int
    while `axis` is a tuple of ints, then the same value is used for
    all given axes.
axis : int or tuple of ints, optional
    Axis or axes along which elements are shifted.  By default, the
    array is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Notes
-----
Supports rolling over multiple dimensions simultaneously.

Examples
--------
>>> import numpy as np
>>> x = np.arange(10)
>>> np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
>>> np.roll(x, -2)
array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])

>>> x2 = np.reshape(x, (2, 5))
>>> x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
>>> np.roll(x2, -1)
array([[1, 2, 3, 4, 5],
       [6, 7, 8, 9, 0]])
>>> np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, -1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])
>>> np.roll(x2, -1, axis=1)
array([[1, 2, 3, 4, 0],
       [6, 7, 8, 9, 5]])
>>> np.roll(x2, (1, 1), axis=(1, 0))
array([[9, 5, 6, 7, 8],
       [4, 0, 1, 2, 3]])
>>> np.roll(x2, (2, 1), axis=(1, 0))
array([[8, 9, 5, 6, 7],
       [3, 4, 0, 1, 2]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a5bfc842d4d95a565afed341492ccc09f}\label{namespacenumpy_1_1__core_1_1numeric_a5bfc842d4d95a565afed341492ccc09f} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!rollaxis@{rollaxis}}
\index{rollaxis@{rollaxis}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{rollaxis()}{rollaxis()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+rollaxis (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis,  }\item[{}]{start = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Roll the specified axis backwards, until it lies in a given position.

This function continues to be supported for backward compatibility, but you
should prefer `moveaxis`. The `moveaxis` function was added in NumPy
1.11.

Parameters
----------
a : ndarray
    Input array.
axis : int
    The axis to be rolled. The positions of the other axes do not
    change relative to one another.
start : int, optional
    When ``start <= axis``, the axis is rolled back until it lies in
    this position. When ``start > axis``, the axis is rolled until it
    lies before this position. The default, 0, results in a "complete"
    roll. The following table describes how negative values of ``start``
    are interpreted:

    .. table::
       :align: left

       +-------------------+----------------------+
       |     ``start``     | Normalized ``start`` |
       +===================+======================+
       | ``-(arr.ndim+1)`` | raise ``AxisError``  |
       +-------------------+----------------------+
       | ``-arr.ndim``     | 0                    |
       +-------------------+----------------------+
       | |vdots|           | |vdots|              |
       +-------------------+----------------------+
       | ``-1``            | ``arr.ndim-1``       |
       +-------------------+----------------------+
       | ``0``             | ``0``                |
       +-------------------+----------------------+
       | |vdots|           | |vdots|              |
       +-------------------+----------------------+
       | ``arr.ndim``      | ``arr.ndim``         |
       +-------------------+----------------------+
       | ``arr.ndim + 1``  | raise ``AxisError``  |
       +-------------------+----------------------+

    .. |vdots|   unicode:: U+22EE .. Vertical Ellipsis

Returns
-------
res : ndarray
    For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
    NumPy versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

See Also
--------
moveaxis : Move array axes to new positions.
roll : Roll the elements of an array by a number of positions along a
    given axis.

Examples
--------
>>> import numpy as np
>>> a = np.ones((3,4,5,6))
>>> np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
>>> np.rollaxis(a, 2).shape
(5, 3, 4, 6)
>>> np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad83dbf7e90c8a0b6b6e862530733e965}\label{namespacenumpy_1_1__core_1_1numeric_ad83dbf7e90c8a0b6b6e862530733e965} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!tensordot@{tensordot}}
\index{tensordot@{tensordot}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{tensordot()}{tensordot()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+tensordot (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axes = {\ttfamily 2} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute tensor dot product along specified axes.

Given two tensors, `a` and `b`, and an array_like object containing
two array_like objects, ``(a_axes, b_axes)``, sum the products of
`a`'s and `b`'s elements (components) over the axes specified by
``a_axes`` and ``b_axes``. The third argument can be a single non-negative
integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions
of `a` and the first ``N`` dimensions of `b` are summed over.

Parameters
----------
a, b : array_like
    Tensors to "dot".

axes : int or (2,) array_like
    * integer_like
      If an int N, sum over the last N axes of `a` and the first N axes
      of `b` in order. The sizes of the corresponding axes must match.
    * (2,) array_like
      Or, a list of axes to be summed over, first sequence applying to `a`,
      second to `b`. Both elements array_like must be of the same length.

Returns
-------
output : ndarray
    The tensor dot product of the input.

See Also
--------
dot, einsum

Notes
-----
Three common use cases are:
    * ``axes = 0`` : tensor product :math:`a\\otimes b`
    * ``axes = 1`` : tensor dot product :math:`a\\cdot b`
    * ``axes = 2`` : (default) tensor double contraction :math:`a:b`

When `axes` is integer_like, the sequence of axes for evaluation
will be: from the -Nth axis to the -1th axis in `a`,
and from the 0th axis to (N-1)th axis in `b`.
For example, ``axes = 2`` is the equal to
``axes = [[-2, -1], [0, 1]]``.
When N-1 is smaller than 0, or when -N is larger than -1,
the element of `a` and `b` are defined as the `axes`.

When there is more than one axis to sum over - and they are not the last
(first) axes of `a` (`b`) - the argument `axes` should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.
The calculation can be referred to ``numpy.einsum``.

The shape of the result consists of the non-contracted axes of the
first tensor, followed by the non-contracted axes of the second.

Examples
-------- 
An example on integer_like:

>>> a_0 = np.array([[1, 2], [3, 4]])
>>> b_0 = np.array([[5, 6], [7, 8]])
>>> c_0 = np.tensordot(a_0, b_0, axes=0)
>>> c_0.shape
(2, 2, 2, 2)
>>> c_0
array([[[[ 5,  6],
         [ 7,  8]],
        [[10, 12],
         [14, 16]]],
       [[[15, 18],
         [21, 24]],
        [[20, 24],
         [28, 32]]]])

An example on array_like:

>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
>>> c.shape
(5, 2)
>>> c
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
       
A slower but equivalent way of computing the same...

>>> d = np.zeros((5,2))
>>> for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
>>> c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]])

An extended example taking advantage of the overloading of + and \\*:

>>> a = np.array(range(1, 9))
>>> a.shape = (2, 2, 2)
>>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
>>> A.shape = (2, 2)
>>> a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([['a', 'b'],
       ['c', 'd']], dtype=object)

>>> np.tensordot(a, A) # third argument default is 2 for double-contraction
array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)

>>> np.tensordot(a, A, 1)
array([[['acc', 'bdd'],
        ['aaacccc', 'bbbdddd']],
       [['aaaaacccccc', 'bbbbbdddddd'],
        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)

>>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[['a', 'b'],
          ['c', 'd']],
          ...

>>> np.tensordot(a, A, (0, 1))
array([[['abbbbb', 'cddddd'],
        ['aabbbbbb', 'ccdddddd']],
       [['aaabbbbbbb', 'cccddddddd'],
        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)

>>> np.tensordot(a, A, (2, 1))
array([[['abb', 'cdd'],
        ['aaabbbb', 'cccdddd']],
       [['aaaaabbbbbb', 'cccccdddddd'],
        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)

>>> np.tensordot(a, A, ((0, 1), (0, 1)))
array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)

>>> np.tensordot(a, A, ((2, 1), (1, 0)))
array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1numeric_a8649d4ae61c1d49c5a0d2e9294e14d25}\label{namespacenumpy_1_1__core_1_1numeric_a8649d4ae61c1d49c5a0d2e9294e14d25} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!zeros\_like@{zeros\_like}}
\index{zeros\_like@{zeros\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{zeros\_like()}{zeros\_like()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+zeros\+\_\+like (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily True},  }\item[{}]{shape = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array of zeros with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `a`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.
device : str, optional
    The device on which to place the created array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.0.0

Returns
-------
out : ndarray
    Array of zeros with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.

Examples
--------
>>> import numpy as np
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])

>>> y = np.arange(3, dtype=float)
>>> y
array([0., 1., 2.])
>>> np.zeros_like(y)
array([0.,  0.,  0.])\end{DoxyVerb}
 

\doxysubsection{Documentation des variables}
\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a6403d0ce77bffba9d51b7980a422ff48}\label{namespacenumpy_1_1__core_1_1numeric_a6403d0ce77bffba9d51b7980a422ff48} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_fromfunction\_with\_like@{\_fromfunction\_with\_like}}
\index{\_fromfunction\_with\_like@{\_fromfunction\_with\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_fromfunction\_with\_like}{\_fromfunction\_with\_like}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+fromfunction\+\_\+with\+\_\+like = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a6efb6d563ebf0761e050a4f60c801877}{fromfunction}})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_afdf292bb23e4fdf7047b031f3197efb1}\label{namespacenumpy_1_1__core_1_1numeric_afdf292bb23e4fdf7047b031f3197efb1} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_full\_with\_like@{\_full\_with\_like}}
\index{\_full\_with\_like@{\_full\_with\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_full\_with\_like}{\_full\_with\_like}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+full\+\_\+with\+\_\+like = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_ab5de5aaa71558da1b63d1ac8e8c6c21e}{full}})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ab3869c913b8d2a3480a71d5ae018caf4}\label{namespacenumpy_1_1__core_1_1numeric_ab3869c913b8d2a3480a71d5ae018caf4} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_identity\_with\_like@{\_identity\_with\_like}}
\index{\_identity\_with\_like@{\_identity\_with\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_identity\_with\_like}{\_identity\_with\_like}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+identity\+\_\+with\+\_\+like = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a2c0cf3cd9bfa1f6bfe0b91c950d4de12}{identity}})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a844fe76224368df870c8ec4bc72fa282}\label{namespacenumpy_1_1__core_1_1numeric_a844fe76224368df870c8ec4bc72fa282} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_no\_nan\_types@{\_no\_nan\_types}}
\index{\_no\_nan\_types@{\_no\_nan\_types}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_no\_nan\_types}{\_no\_nan\_types}}
{\footnotesize\ttfamily dict numpy.\+\_\+core.\+numeric.\+\_\+no\+\_\+nan\+\_\+types\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{comment}{\#\ should\ use\ np.dtype.BoolDType,\ but\ as\ of\ writing}}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{comment}{\#\ that\ fails\ the\ reloading\ test.}}
\DoxyCodeLine{00004\ \ \ \ \ type(\mbox{\hyperlink{namespacedtype}{dtype}}(nt.bool)),}
\DoxyCodeLine{00005\ \ \ \ \ type(\mbox{\hyperlink{namespacedtype}{dtype}}(nt.int8)),}
\DoxyCodeLine{00006\ \ \ \ \ type(\mbox{\hyperlink{namespacedtype}{dtype}}(nt.int16)),}
\DoxyCodeLine{00007\ \ \ \ \ type(\mbox{\hyperlink{namespacedtype}{dtype}}(nt.int32)),}
\DoxyCodeLine{00008\ \ \ \ \ type(\mbox{\hyperlink{namespacedtype}{dtype}}(nt.int64)),}
\DoxyCodeLine{00009\ \}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a8d174ae9eccce95bcca8717acfac154b}\label{namespacenumpy_1_1__core_1_1numeric_a8d174ae9eccce95bcca8717acfac154b} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!\_ones\_with\_like@{\_ones\_with\_like}}
\index{\_ones\_with\_like@{\_ones\_with\_like}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{\_ones\_with\_like}{\_ones\_with\_like}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+\_\+ones\+\_\+with\+\_\+like = array\+\_\+function\+\_\+dispatch()(\mbox{\hyperlink{namespacenumpy_1_1__core_1_1numeric_a0b6a3662d66df0f58507c38f29644a28}{ones}})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_abf0051441237a67299918d153157af1f}\label{namespacenumpy_1_1__core_1_1numeric_abf0051441237a67299918d153157af1f} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!array\_function\_dispatch@{array\_function\_dispatch}}
\index{array\_function\_dispatch@{array\_function\_dispatch}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{array\_function\_dispatch}{array\_function\_dispatch}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+array\+\_\+function\+\_\+dispatch}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ functools.partial(}
\DoxyCodeLine{00002\ \ \ \ \ overrides.array\_function\_dispatch,\ module=\textcolor{stringliteral}{'numpy'})}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad74553aaf1055d53a64fc508c437be6e}\label{namespacenumpy_1_1__core_1_1numeric_ad74553aaf1055d53a64fc508c437be6e} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!bitwise\_not@{bitwise\_not}}
\index{bitwise\_not@{bitwise\_not}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{bitwise\_not}{bitwise\_not}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+bitwise\+\_\+not = invert}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_af464b7220407b841a4e651eb71b523ed}\label{namespacenumpy_1_1__core_1_1numeric_af464b7220407b841a4e651eb71b523ed} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!False\_@{False\_}}
\index{False\_@{False\_}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{False\_}{False\_}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+False\+\_\+ = nt.\+bool(False)}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_af9f195f519f3e1db71554550c730c055}\label{namespacenumpy_1_1__core_1_1numeric_af9f195f519f3e1db71554550c730c055} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!inf@{inf}}
\index{inf@{inf}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{inf}{inf}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+inf = PINF}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_af96e870c3d2e0474ad3cba10cae8a084}\label{namespacenumpy_1_1__core_1_1numeric_af96e870c3d2e0474ad3cba10cae8a084} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!little\_endian@{little\_endian}}
\index{little\_endian@{little\_endian}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{little\_endian}{little\_endian}}
{\footnotesize\ttfamily tuple numpy.\+\_\+core.\+numeric.\+little\+\_\+endian = (sys.\+byteorder == \textquotesingle{}little\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a76b4bd0b472b665f25a1feeb96d42a6a}\label{namespacenumpy_1_1__core_1_1numeric_a76b4bd0b472b665f25a1feeb96d42a6a} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!nan@{nan}}
\index{nan@{nan}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{nan}{nan}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+nan = NAN}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_ad3ea1ab24ec8a70499d18381b3492a7d}\label{namespacenumpy_1_1__core_1_1numeric_ad3ea1ab24ec8a70499d18381b3492a7d} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!newaxis@{newaxis}}
\index{newaxis@{newaxis}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{newaxis}{newaxis}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+newaxis = None}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a55f18cb78115eeea34d34ddaee02db5d}\label{namespacenumpy_1_1__core_1_1numeric_a55f18cb78115eeea34d34ddaee02db5d} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!True\_@{True\_}}
\index{True\_@{True\_}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{True\_}{True\_}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+True\+\_\+ = nt.\+bool(True)}

\Hypertarget{namespacenumpy_1_1__core_1_1numeric_a62a35b09344b5d48609c9255baf6f889}\label{namespacenumpy_1_1__core_1_1numeric_a62a35b09344b5d48609c9255baf6f889} 
\index{numpy.\_core.numeric@{numpy.\_core.numeric}!ufunc@{ufunc}}
\index{ufunc@{ufunc}!numpy.\_core.numeric@{numpy.\_core.numeric}}
\doxysubsubsection{\texorpdfstring{ufunc}{ufunc}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+numeric.\+ufunc = type(sin)}

