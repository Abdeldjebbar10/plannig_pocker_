\doxysection{Référence de l\textquotesingle{}espace de nommage numpy.\+ma.\+core}
\hypertarget{namespacenumpy_1_1ma_1_1core}{}\label{namespacenumpy_1_1ma_1_1core}\index{numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__convert2ma}{\+\_\+convert2ma}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainCheckInterval}{\+\_\+\+Domain\+Check\+Interval}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainGreater}{\+\_\+\+Domain\+Greater}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainGreaterEqual}{\+\_\+\+Domain\+Greater\+Equal}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainTan}{\+\_\+\+Domain\+Tan}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__extrema__operation}{\+\_\+extrema\+\_\+operation}}
\begin{DoxyCompactList}\small\item\em Extrema functions \#. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}
\begin{DoxyCompactList}\small\item\em Definition of functions from the corresponding methods \#. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedPrintOption}{\+\_\+\+Masked\+Print\+Option}}
\begin{DoxyCompactList}\small\item\em Printing options \#. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUFunc}{\+\_\+\+Masked\+UFunc}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MAError}{MAError}}
\begin{DoxyCompactList}\small\item\em Exceptions \#. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedArray}{Masked\+Array}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedArrayFutureWarning}{Masked\+Array\+Future\+Warning}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedConstant}{Masked\+Constant}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedIterator}{Masked\+Iterator}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskError}{Mask\+Error}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1mvoid}{mvoid}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4d19719f38f796d17fa3f3c231f5fd96}{\+\_\+deprecate\+\_\+argsort\+\_\+axis}} (arr)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6f0e91b54079800992bd9aa38f331d5e}{doc\+\_\+note}} (initialdoc, note)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a26eaadcf12b8f2ec709d24024f259d25}{get\+\_\+object\+\_\+signature}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4e73ff4b624e111b40e3c79cd30a707a}{\+\_\+recursive\+\_\+fill\+\_\+value}} (dtype, f)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab6e93adf36070b07dcc2ceef04b7c016}{\+\_\+get\+\_\+dtype\+\_\+of}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad5a02ac1caadf6d733568327c2c43a46}{default\+\_\+fill\+\_\+value}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acf15b04d4be006c0fea37195c4a33ccf}{\+\_\+extremum\+\_\+fill\+\_\+value}} (obj, extremum, extremum\+\_\+name)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1d560799762530922722ed03e325bf75}{minimum\+\_\+fill\+\_\+value}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a09e1df3c10c1071ab491b82adc781cce}{maximum\+\_\+fill\+\_\+value}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a521adf7968e7831e37ed30aa16a8792a}{\+\_\+recursive\+\_\+set\+\_\+fill\+\_\+value}} (fillvalue, dt)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abf23859aa65813277e652bd503d650dc}{\+\_\+check\+\_\+fill\+\_\+value}} (fill\+\_\+value, ndtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a025416440c17c2e87de81627cbdae280}{set\+\_\+fill\+\_\+value}} (a, fill\+\_\+value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af6954f803de9662fc6d6590f5192b963}{get\+\_\+fill\+\_\+value}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac3da570ac32589600012584bcd7c26d5}{common\+\_\+fill\+\_\+value}} (a, b)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9bf4d0cb73db89ca836e1b10f6901b8a}{filled}} (a, fill\+\_\+value=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a51a67076b6cd7f08b2524bb4f66e12fc}{get\+\_\+masked\+\_\+subclass}} (\texorpdfstring{$\ast$}{*}arrays)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4c058cfe52befdaf7bc1beb8c06e3b0d}{getdata}} (a, subok=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abd0dc2488d85131a27e4304fbfa4eded}{fix\+\_\+invalid}} (a, mask=\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa}{nomask}}, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True, fill\+\_\+value=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad1904aae3d2b0ea006529da02fdf31a4}{is\+\_\+string\+\_\+or\+\_\+list\+\_\+of\+\_\+strings}} (val)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a45ba8078d1c5287aeece0211bc1c1496}{\+\_\+replace\+\_\+dtype\+\_\+fields\+\_\+recursive}} (dtype, primitive\+\_\+dtype)
\begin{DoxyCompactList}\small\item\em Mask creation functions \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a55a386d96641acbe3530419a3f4a4265}{\+\_\+replace\+\_\+dtype\+\_\+fields}} (dtype, primitive\+\_\+dtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad1c6f760a012ec3ff9e7973f81280d58}{make\+\_\+mask\+\_\+descr}} (ndtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aee4137f8256ee554372b8e0629355971}{getmask}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_adb1639d29d31fafd121ba5ac18236508}{getmaskarray}} (arr)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6f3563a212ab5fc2d2950d9db6e2f6b6}{is\+\_\+mask}} (m)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a006d08297579b9505140ea2077624f9f}{\+\_\+shrink\+\_\+mask}} (m)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4ae90c998c906a7187d527d5d6f2e6f9}{make\+\_\+mask}} (m, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=False, shrink=True, dtype=\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e}{Mask\+Type}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a77ea7516f02c355e1cab8bfa2d33d0b6}{make\+\_\+mask\+\_\+none}} (newshape, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad55e17d10825815f634cbc51d99c8c64}{\+\_\+recursive\+\_\+mask\+\_\+or}} (m1, m2, newmask)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3ae4789ed03e5ef62b95d1bdaea0f00e}{mask\+\_\+or}} (m1, m2, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=False, shrink=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0bff3f782fbb208507113978d1946731}{flatten\+\_\+mask}} (mask)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1c43e9eda4bc2703b2e4d3f9f8271e21}{\+\_\+check\+\_\+mask\+\_\+axis}} (mask, axis, keepdims=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4ccd4eab4a2c1bce757e4bec345e124c}{masked\+\_\+where}} (condition, a, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\begin{DoxyCompactList}\small\item\em Masking functions \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa13f9e12a8640e931a458e7762f8570d}{masked\+\_\+greater}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1384d301a60a61d10d03a83814d00107}{masked\+\_\+greater\+\_\+equal}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3ffd24d88cda8514693ca8cbb430017c}{masked\+\_\+less}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a7eea3b4a436087a24b1b71b224ce0b51}{masked\+\_\+less\+\_\+equal}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab5f5bd748d2cb9eda89ace0abb746c8a}{masked\+\_\+not\+\_\+equal}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad90f5527d29b15ef09fc83ae7634a0e0}{masked\+\_\+equal}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4028ee50d27de9c451a87613e52c1387}{masked\+\_\+inside}} (x, v1, v2, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a2efd6920394b3b5ca0db83e4d09f6160}{masked\+\_\+outside}} (x, v1, v2, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a909d623a46766a5d7f9a879e060a941f}{masked\+\_\+object}} (x, value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True, shrink=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a937c0a505425aea93f5931565f1db053}{masked\+\_\+values}} (x, value, rtol=1e-\/5, atol=1e-\/8, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True, shrink=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6aacabf412258dd22ad182492abff10d}{masked\+\_\+invalid}} (a, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a80881151b0d3d0ef37bde1e9716bdb77}{\+\_\+recursive\+\_\+printoption}} (result, mask, printopt)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1f9f00fc9f048afa9362cfcf97ec8665}{\+\_\+recursive\+\_\+filled}} (a, mask, fill\+\_\+value)
\begin{DoxyCompactList}\small\item\em Masked\+Array class \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a2c5384e6a47a6f88b63da86dcd621f43}{flatten\+\_\+structured\+\_\+array}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6c70ff423faf6dd181ef44fc4ba740e4}{\+\_\+arraymethod}} (funcname, onmask=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_afb5ff8fe78cc5c726b4de9fd6dcc1c63}{\+\_\+mareconstruct}} (subtype, baseclass, baseshape, basetype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e}{is\+Masked\+Array}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0a839d6f59d4481fc3405f0c38aec044}{array}} (data, dtype=None, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}}=False, order=None, mask=\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa}{nomask}}, fill\+\_\+value=None, keep\+\_\+mask=True, hard\+\_\+mask=False, shrink=True, subok=True, ndmin=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3297519ebd20de2f25f5fb4f80668a8e}{is\+\_\+masked}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad91233be8c9d9f06637174005076d095}{min}} (obj, axis=None, out=None, fill\+\_\+value=None, keepdims=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6f0ad1868d46bb532dbe832435aa5b2f}{max}} (obj, axis=None, out=None, fill\+\_\+value=None, keepdims=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acbfc9290966b2a34f909ec4d772500bb}{ptp}} (obj, axis=None, out=None, fill\+\_\+value=None, keepdims=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_afdb2f3a1791f064380994eb871fd2447}{take}} (a, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1cba93d768a61f51e74e5c5f7e8233f7}{indices}}, axis=None, out=None, mode=\textquotesingle{}raise\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4eb881434d6debf955d0acc5f0ab9dca}{power}} (a, b, third=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae1b895f987ca5bb03524e0d7324d83e3}{argsort}} (a, axis=np.\+\_\+\+No\+Value, kind=None, order=None, endwith=True, fill\+\_\+value=None, \texorpdfstring{$\ast$}{*}stable=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae116f01504dfade82c7ce9ab4e096c07}{sort}} (a, axis=-\/1, kind=None, order=None, endwith=True, fill\+\_\+value=None, \texorpdfstring{$\ast$}{*}stable=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3b0776037b5ae1986b4385e1f67ec028}{compressed}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3509218a0b44b803c13b0e4110f13f10}{concatenate}} (arrays, axis=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab3368dd2555ba4ec5e1da5e9fcaba2a0}{diag}} (v, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af00289d0d6b524db91f71f89f78bb682}{left\+\_\+shift}} (a, n)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a63451a2bb0d513878157e1a7e04ec986}{right\+\_\+shift}} (a, n)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a82ed417314a668683badd0478d7ea35b}{put}} (a, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1cba93d768a61f51e74e5c5f7e8233f7}{indices}}, values, mode=\textquotesingle{}raise\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a06f416f62cb106290855d2eab7ddbb1e}{putmask}} (a, mask, values)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af18bd0eecdb65207fb8ee124353a602b}{transpose}} (a, axes=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a94145a691745d920c49da604cf501e27}{reshape}} (a, new\+\_\+shape, order=\textquotesingle{}C\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4860bbf1250c53668c51db869e9bcbdd}{resize}} (x, new\+\_\+shape)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a747a1d813cd4f02f0d7a160ad3db54c6}{ndim}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a63d4f6a70c6dd38ef30778526006bd8d}{shape}} (obj)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a382020a304ed520a0853d3603a609478}{size}} (obj, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a06f276c8db95a032269ebd2463b46ff3}{diff}} (a, n=1, axis=-\/1, prepend=np.\+\_\+\+No\+Value, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1d9dce7af4836e53297697234f2c3c6a}{append}}=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae03373b142277fe573d18d4719a063d9}{where}} (condition, x=\+\_\+\+No\+Value, y=\+\_\+\+No\+Value)
\begin{DoxyCompactList}\small\item\em Extra functions \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac838e8bfe1023c704fe75ae9fd4d3eb0}{choose}} (\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1cba93d768a61f51e74e5c5f7e8233f7}{indices}}, choices, out=None, mode=\textquotesingle{}raise\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab65dc83aa506b08f16d69e23a24c7765}{round\+\_\+}} (a, decimals=0, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a2a579b5d3237be07668c5b22218d1bab}{\+\_\+mask\+\_\+propagate}} (a, axis)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6281cff9d348f621ed71cbbf8399ac39}{dot}} (a, b, strict=False, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a70b1e7c1e7cd6089d61329228470907e}{inner}} (a, b)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af2f6d2c8970c6ad528639810df1d9e6c}{outer}} (a, b)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0afdf92b74d870989e00e1016978f84c}{\+\_\+convolve\+\_\+or\+\_\+correlate}} (f, a, v, mode, propagate\+\_\+mask)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a19b3312e7c0d0e9ffa0911c91a095f17}{correlate}} (a, v, mode=\textquotesingle{}valid\textquotesingle{}, propagate\+\_\+mask=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aadf0ba5e946ec7682c2ebecd726c7139}{convolve}} (a, v, mode=\textquotesingle{}full\textquotesingle{}, propagate\+\_\+mask=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a40941b55c634d680617c73fae1ce7f73}{allequal}} (a, b, fill\+\_\+value=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa73814f68c47a0cbf4b86a24fbaffd83}{allclose}} (a, b, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad90f5527d29b15ef09fc83ae7634a0e0}{masked\+\_\+equal}}=True, rtol=1e-\/5, atol=1e-\/8)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aabc3d18f0d2aa0309397b4d17d83dfb4}{asarray}} (a, dtype=None, order=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a393b347bd5a52ed9fddf4d5473384053}{asanyarray}} (a, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a88211fe629ec66c81f9bff690cf515c6}{fromfile}} (file, dtype=float, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_affe86f6f5e44d61ddd92f35726b9e626}{count}}=-\/1, sep=\textquotesingle{}\textquotesingle{})
\begin{DoxyCompactList}\small\item\em Pickling \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acf3e8f70cdcea57b5844edd6e05d9ff4}{fromflex}} (fxarray)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1d9dce7af4836e53297697234f2c3c6a}{append}} (a, b, axis=None)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e}{Mask\+Type}} = np.\+bool
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa}{nomask}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e}{Mask\+Type}}(0)
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a5f60b1b8ceec4a93750b6e6742ac2c3f}{default\+\_\+filler}}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad943fb8cd3ae928889bcb9bb46cbe50e}{float\+\_\+types\+\_\+list}}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa870f600996814468ff2c6c5e373d84a}{\+\_\+minvals}} = \{\}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a52e0aa8235d8e8866c4f93132ea361a5}{\+\_\+maxvals}} = \{\}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a50c62686f6332c6c784d556e249bb780}{scalar\+\_\+dtype}} = np.\+dtype(sctype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af5b70aab8e0b4e834b26e3ee8b671deb}{info}} = np.\+iinfo(np.\+int64)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a565120922b2e50b2f9040265b1f921fc}{min\+\_\+val}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a62a7d8c694b3891ba4a473dee4f2f6d6}{max\+\_\+val}}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a115e8a82d45c099a3ca87ac53e088196}{max\+\_\+filler}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa870f600996814468ff2c6c5e373d84a}{\+\_\+minvals}}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af2700e38d027bf2fd011e296af3201cc}{min\+\_\+filler}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a52e0aa8235d8e8866c4f93132ea361a5}{\+\_\+maxvals}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0970cd0b8e0192e47258bafe5b940051}{get\+\_\+data}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4c058cfe52befdaf7bc1beb8c06e3b0d}{getdata}}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad413190a3c501d5f20cc1b97c6c4417e}{ufunc\+\_\+domain}} = \{\}
\begin{DoxyCompactList}\small\item\em Ufuncs \#. \end{DoxyCompactList}\item 
dict \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1ef6b945fc572f9141935e8d192acb9d}{ufunc\+\_\+fills}} = \{\}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a05913f2c71220208666e6b54d6b26a30}{exp}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+exp)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9e3086fcb820a1aab1c950f12f42f08d}{conjugate}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+conjugate)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9011f3b810867bc580b530fd7e301f5b}{sin}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+sin)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a62ff030940780df90c92ab873cb2338e}{cos}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+cos)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_afccd755361a7cca556f2ed2e09407c24}{arctan}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+arctan)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a94826c0e4e388f94cedaa323379a5b4e}{arcsinh}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+arcsinh)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad4a0e34a99e04590b9523a40b66a929e}{sinh}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+sinh)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac4d18040290f60f23634da777ae79abd}{cosh}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+cosh)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6afd07da1a3d4b9585669fc115a8ce02}{tanh}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+tanh)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a5526d131af851bed792d8a7885f164cb}{abs}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+absolute)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a232b83f8caa3318472917df9a42eda3a}{angle}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(angle)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aefeeee05847dbaa7e6d14d3690ffd236}{fabs}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+fabs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3f3c3cdb93ef35eff48a3607fe63065d}{negative}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+negative)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa95f1e6c62f4f6c457b4f9d470fe9bbe}{floor}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+floor)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a694b148708c4de2aaf00c26ffe1dc473}{ceil}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+ceil)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a8783a7d1996d8c33a17bdc31e2754a6c}{around}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(np.\+around)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4c8e7fc0f6ae775e89c5d5e3657d5431}{logical\+\_\+not}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+logical\+\_\+not)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_afaf4f80457e478c88bb42ebe6a09c8aa}{sqrt}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a3f5dfa023ac8ef0d85c02e582f867159}{log}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af55e1ce23ec62714eb7e94bf28a46971}{log2}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aab50cb82e4a184528e6d179de1a457c1}{log10}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acf722039ca4f5f079ec956da05738e52}{tan}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a13af3437e857b31052d3da00fe9bdfb6}{arcsin}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a485e28a53428db6f3a42d6a762b40a11}{arccos}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a90a03d5744cdf4988583f0e2f3ec60e4}{arccosh}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab83170ddb7014759bfe64ec1fde05554}{arctanh}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aecc95edb3fa065575d468d2d8f3eab9f}{add}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+add)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6f98e92563a77b193c897b57b29616be}{subtract}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+subtract)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a904cfee6a443856d8f28bcabdc581ca3}{multiply}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+multiply, 1, 1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a8811be62d89efd0e21008f1e510c2293}{arctan2}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+arctan2, 0.\+0, 1.\+0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9120f89faa4eceb8a018859bed4526f7}{equal}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+equal)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a47e9cb4bc6277b24b219f6794480c811}{reduce}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac48abe6f0d8fe084e093b892a3f6204a}{not\+\_\+equal}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+not\+\_\+equal)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a373aad430737172328d07d67264945fe}{less\+\_\+equal}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+less\+\_\+equal)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a17ae5bf50a52d8ee4720dddaa7779823}{greater\+\_\+equal}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+greater\+\_\+equal)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae7e7a3dc955065407c7d0801906173b5}{less}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+less)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af46d1de5e4c57b6eb70f8c1130da875d}{greater}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+greater)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af2548e3983fe07d9f740ea481a916a6f}{logical\+\_\+and}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+and)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a585600a338f60b69602822fb04e1432e}{alltrue}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+and, 1, 1).\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a47e9cb4bc6277b24b219f6794480c811}{reduce}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad225eefaa421cafecf2ced8cc45374be}{logical\+\_\+or}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+or)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_afd9e0f9fd48cfc33ec5a3f2f5787c24a}{sometrue}} = logical\+\_\+or.\+reduce
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a7df643d412aa21b4b8c01c8dd88bf6e6}{logical\+\_\+xor}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+xor)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af3458ab5027fb34dff52c63a6d40936d}{bitwise\+\_\+and}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+bitwise\+\_\+and)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a03a17b72b4c278c3ab5e9d9ff421c51a}{bitwise\+\_\+or}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+bitwise\+\_\+or)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a460d7c8700cd51ed007f9570aaa22dc2}{bitwise\+\_\+xor}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+bitwise\+\_\+xor)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a835f29ad53957419c0ff51f0199ce412}{hypot}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+hypot)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a29bf5b3bb49649e6c084120be48dc302}{divide}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}(umath.\+divide, \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}(), 0, 1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1212505d2325c633277326ea6ff0ceb1}{true\+\_\+divide}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aab4ab1ae0c9d8f94ed7b688e8419ccfd}{floor\+\_\+divide}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af9ec8885ec7e33164ab240325c62cb91}{remainder}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa399d2d1f4e648e9ce4930b1212b3498}{fmod}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}(umath.\+fmod, \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}(), 0, 1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a35d11841e3187865b34bdc56062e28f8}{mod}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}(umath.\+mod, \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}(), 0, 1)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a089c465f38e219e618241a2bd6706a72}{get\+\_\+mask}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aee4137f8256ee554372b8e0629355971}{getmask}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a42b4fb5861601e58f9e118e6630187b2}{masked\+\_\+print\+\_\+option}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedPrintOption}{\+\_\+\+Masked\+Print\+Option}}(\textquotesingle{}-\/-\/\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af584319c358a9b0c16d1ff59873d46fa}{\+\_\+legacy\+\_\+print\+\_\+templates}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a350a49b5091ca75bba5576eca2a22404}{isarray}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e}{is\+Masked\+Array}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a51934f356f9682f4347d725747b4bfef}{is\+MA}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e}{is\+Masked\+Array}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad49455d80ed35dc668673068a0fd6129}{masked}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedConstant}{Masked\+Constant}}()
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0462968b90d3e1a2aa6c54845c45f5da}{masked\+\_\+array}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedArray}{Masked\+Array}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a45b43786ae893dd0a3a7e113ccb00ee9}{all}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}all\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae502a3b30272ef3afe2f3514f5ff2805}{anomalies}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}anom\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_afa19956e2746e9587488c89a7a7bb5eb}{any}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}any\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a7308818dc67dd4eedf1abd3b0f98bb7d}{compress}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}compress\textquotesingle{}, reversed=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6ace0c3b2fcc8279b5ace7d6df57ae47}{cumprod}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}cumprod\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a7c85a9bb14cd25cd30ac0e2b4e187fcc}{cumsum}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}cumsum\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}{copy}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}copy\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acc4f0cf7239063df79ce982f246f59e2}{diagonal}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}diagonal\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac9aabccbd3643ebffc834e4d576e3e3b}{harden\+\_\+mask}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}harden\+\_\+mask\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a90dd821d3c2af4142e801072150bb3f1}{ids}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}ids\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af5e69f0e12633758a7f1b414f0fa1bc6}{maximum}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__extrema__operation}{\+\_\+extrema\+\_\+operation}}(umath.\+maximum, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af46d1de5e4c57b6eb70f8c1130da875d}{greater}}, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a09e1df3c10c1071ab491b82adc781cce}{maximum\+\_\+fill\+\_\+value}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a46ebf9733bc25babd0aa8f08ae17e9b7}{mean}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}mean\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aeb2ba5831680f4c8197597059511b49a}{minimum}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__extrema__operation}{\+\_\+extrema\+\_\+operation}}(umath.\+minimum, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae7e7a3dc955065407c7d0801906173b5}{less}}, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1d560799762530922722ed03e325bf75}{minimum\+\_\+fill\+\_\+value}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a157435586edf14697eb861bf883f53a5}{nonzero}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}nonzero\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acd937c16ef10fa2184bb450224be6603}{prod}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}prod\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a5b7331c8be2833e3cb23d3aff257f193}{product}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acd937c16ef10fa2184bb450224be6603}{prod}}\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ad95c8d874cf47e68e31d3129b3339634}{ravel}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}ravel\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae0c207c42a170872500d93cf9e8b8751}{repeat}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}repeat\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab9777efc4fb11b7132de51052e367be2}{shrink\+\_\+mask}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}shrink\+\_\+mask\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a254c1fa90224b11d8cb149f0e21f6161}{soften\+\_\+mask}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}soften\+\_\+mask\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6218f021e131e27eea147e501b183a08}{std}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}std\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a009376cf93afe2abb614042bb8da83f4}{sum}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}sum\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a305644a52798502115b3b3f2a6a9b056}{swapaxes}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}swapaxes\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a724ae498510cf6c1dafdc266c64d744f}{trace}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}trace\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6250d7311d9a85a9e0e016ecc4312496}{var}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}var\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_affe86f6f5e44d61ddd92f35726b9e626}{count}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}count\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1842cdbdf9607539230cc097195df3e8}{argmin}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}argmin\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a8bff7b7b01e335828e68e522e950cfaf}{argmax}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}argmax\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a80eee7765e1c59f3e9d47062c1ab80f4}{round}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab65dc83aa506b08f16d69e23a24c7765}{round\+\_\+}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4065d4c56178ab45dc4c09a3341f4464}{innerproduct}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a70b1e7c1e7cd6089d61329228470907e}{inner}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aca2cd675f56afaf40f368db1b4736046}{outerproduct}} = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af2f6d2c8970c6ad528639810df1d9e6c}{outer}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a890b773f294d111805d66e989f43d59c}{arange}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a6a32b49c7bed820a336049f0be631d33}{clip}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a905d491ab2a9d4394e947fa11e963c34}{empty}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aca11985b88d3f8506c30ea9063dc58e8}{empty\+\_\+like}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1447273a76e349a77bc1d85596c83209}{frombuffer}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_adf0d2913ba7e564eff28cd7c243eec62}{fromfunction}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a27d92b83c7d72381405190793a1fbd10}{identity}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1cba93d768a61f51e74e5c5f7e8233f7}{indices}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac7e1120e60c622054350c7e6e1ca62c2}{ones}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ac83bf6449039f715038b5aafb1b4c052}{ones\+\_\+like}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a25bd219452b8eb46a2888a83ddac4961}{squeeze}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a20bba9e970ae1fccfa1bbb87e82a53ac}{zeros}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae42b665e6fa6c8fcebe20cac5a452be4}{zeros\+\_\+like}}
\end{DoxyCompactItemize}


\doxysubsection{Description détaillée}
\begin{DoxyVerb}numpy.ma : a package to handle missing or invalid values.

This package was initially written for numarray by Paul F. Dubois
at Lawrence Livermore National Laboratory.
In 2006, the package was completely rewritten by Pierre Gerard-Marchant
(University of Georgia) to make the MaskedArray class a subclass of ndarray,
and to improve support of structured arrays.


Copyright 1999, 2000, 2001 Regents of the University of California.
Released for unlimited redistribution.

* Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.
* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant
  (pgmdevlist_AT_gmail_DOT_com)
* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com)

.. moduleauthor:: Pierre Gerard-Marchant\end{DoxyVerb}
 

\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a6c70ff423faf6dd181ef44fc4ba740e4}\label{namespacenumpy_1_1ma_1_1core_a6c70ff423faf6dd181ef44fc4ba740e4} 
\index{numpy.ma.core@{numpy.ma.core}!\_arraymethod@{\_arraymethod}}
\index{\_arraymethod@{\_arraymethod}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_arraymethod()}{\_arraymethod()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+arraymethod (\begin{DoxyParamCaption}\item[{}]{funcname,  }\item[{}]{onmask = {\ttfamily True} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return a class method wrapper around a basic array method.

Creates a class method which returns a masked array, where the new
``_data`` array is the output of the corresponding basic method called
on the original ``_data``.

If `onmask` is True, the new mask is the output of the method called
on the initial mask. Otherwise, the new mask is just a reference
to the initial mask.

Parameters
----------
funcname : str
    Name of the function to apply on data.
onmask : bool
    Whether the mask must be processed also (True) or left
    alone (False). Default is True. Make available as `_onmask`
    attribute.

Returns
-------
method : instancemethod
    Class method wrapper of the specified basic array method.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_abf23859aa65813277e652bd503d650dc}\label{namespacenumpy_1_1ma_1_1core_abf23859aa65813277e652bd503d650dc} 
\index{numpy.ma.core@{numpy.ma.core}!\_check\_fill\_value@{\_check\_fill\_value}}
\index{\_check\_fill\_value@{\_check\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_check\_fill\_value()}{\_check\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+check\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{fill\+\_\+value,  }\item[{}]{ndtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Private function validating the given `fill_value` for the given dtype.

If fill_value is None, it is set to the default corresponding to the dtype.

If fill_value is not None, its value is forced to the given dtype.

The result is always a 0d array.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a1c43e9eda4bc2703b2e4d3f9f8271e21}\label{namespacenumpy_1_1ma_1_1core_a1c43e9eda4bc2703b2e4d3f9f8271e21} 
\index{numpy.ma.core@{numpy.ma.core}!\_check\_mask\_axis@{\_check\_mask\_axis}}
\index{\_check\_mask\_axis@{\_check\_mask\_axis}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_check\_mask\_axis()}{\_check\_mask\_axis()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+check\+\_\+mask\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{mask,  }\item[{}]{axis,  }\item[{}]{keepdims = {\ttfamily np.\+\_\+NoValue} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a0afdf92b74d870989e00e1016978f84c}\label{namespacenumpy_1_1ma_1_1core_a0afdf92b74d870989e00e1016978f84c} 
\index{numpy.ma.core@{numpy.ma.core}!\_convolve\_or\_correlate@{\_convolve\_or\_correlate}}
\index{\_convolve\_or\_correlate@{\_convolve\_or\_correlate}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_convolve\_or\_correlate()}{\_convolve\_or\_correlate()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+convolve\+\_\+or\+\_\+correlate (\begin{DoxyParamCaption}\item[{}]{f,  }\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode,  }\item[{}]{propagate\+\_\+mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function for ma.correlate and ma.convolve
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4d19719f38f796d17fa3f3c231f5fd96}\label{namespacenumpy_1_1ma_1_1core_a4d19719f38f796d17fa3f3c231f5fd96} 
\index{numpy.ma.core@{numpy.ma.core}!\_deprecate\_argsort\_axis@{\_deprecate\_argsort\_axis}}
\index{\_deprecate\_argsort\_axis@{\_deprecate\_argsort\_axis}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_deprecate\_argsort\_axis()}{\_deprecate\_argsort\_axis()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+deprecate\+\_\+argsort\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{arr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Adjust the axis passed to argsort, warning if necessary

Parameters
----------
arr
    The array which argsort was called on

np.ma.argsort has a long-term bug where the default of the axis argument
is wrong (gh-8701), which now must be kept for backwards compatibility.
Thankfully, this only makes a difference when arrays are 2- or more-
dimensional, so we only need a warning then.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_acf15b04d4be006c0fea37195c4a33ccf}\label{namespacenumpy_1_1ma_1_1core_acf15b04d4be006c0fea37195c4a33ccf} 
\index{numpy.ma.core@{numpy.ma.core}!\_extremum\_fill\_value@{\_extremum\_fill\_value}}
\index{\_extremum\_fill\_value@{\_extremum\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_extremum\_fill\_value()}{\_extremum\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+extremum\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{obj,  }\item[{}]{extremum,  }\item[{}]{extremum\+\_\+name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ab6e93adf36070b07dcc2ceef04b7c016}\label{namespacenumpy_1_1ma_1_1core_ab6e93adf36070b07dcc2ceef04b7c016} 
\index{numpy.ma.core@{numpy.ma.core}!\_get\_dtype\_of@{\_get\_dtype\_of}}
\index{\_get\_dtype\_of@{\_get\_dtype\_of}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_get\_dtype\_of()}{\_get\_dtype\_of()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+get\+\_\+dtype\+\_\+of (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} Convert the argument for *_fill_value into a dtype \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_afb5ff8fe78cc5c726b4de9fd6dcc1c63}\label{namespacenumpy_1_1ma_1_1core_afb5ff8fe78cc5c726b4de9fd6dcc1c63} 
\index{numpy.ma.core@{numpy.ma.core}!\_mareconstruct@{\_mareconstruct}}
\index{\_mareconstruct@{\_mareconstruct}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_mareconstruct()}{\_mareconstruct()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+mareconstruct (\begin{DoxyParamCaption}\item[{}]{subtype,  }\item[{}]{baseclass,  }\item[{}]{baseshape,  }\item[{}]{basetype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Internal function that builds a new MaskedArray from the
information stored in a pickle.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a2a579b5d3237be07668c5b22218d1bab}\label{namespacenumpy_1_1ma_1_1core_a2a579b5d3237be07668c5b22218d1bab} 
\index{numpy.ma.core@{numpy.ma.core}!\_mask\_propagate@{\_mask\_propagate}}
\index{\_mask\_propagate@{\_mask\_propagate}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_mask\_propagate()}{\_mask\_propagate()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+mask\+\_\+propagate (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Mask whole 1-d vectors of an array that contain masked values.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4e73ff4b624e111b40e3c79cd30a707a}\label{namespacenumpy_1_1ma_1_1core_a4e73ff4b624e111b40e3c79cd30a707a} 
\index{numpy.ma.core@{numpy.ma.core}!\_recursive\_fill\_value@{\_recursive\_fill\_value}}
\index{\_recursive\_fill\_value@{\_recursive\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_recursive\_fill\_value()}{\_recursive\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+recursive\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{dtype,  }\item[{}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Recursively produce a fill value for `dtype`, calling f on scalar dtypes
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a1f9f00fc9f048afa9362cfcf97ec8665}\label{namespacenumpy_1_1ma_1_1core_a1f9f00fc9f048afa9362cfcf97ec8665} 
\index{numpy.ma.core@{numpy.ma.core}!\_recursive\_filled@{\_recursive\_filled}}
\index{\_recursive\_filled@{\_recursive\_filled}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_recursive\_filled()}{\_recursive\_filled()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+recursive\+\_\+filled (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{mask,  }\item[{}]{fill\+\_\+value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Masked\+Array class \#. 

\begin{DoxyVerb}Recursively fill `a` with `fill_value`.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ad55e17d10825815f634cbc51d99c8c64}\label{namespacenumpy_1_1ma_1_1core_ad55e17d10825815f634cbc51d99c8c64} 
\index{numpy.ma.core@{numpy.ma.core}!\_recursive\_mask\_or@{\_recursive\_mask\_or}}
\index{\_recursive\_mask\_or@{\_recursive\_mask\_or}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_recursive\_mask\_or()}{\_recursive\_mask\_or()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+recursive\+\_\+mask\+\_\+or (\begin{DoxyParamCaption}\item[{}]{m1,  }\item[{}]{m2,  }\item[{}]{newmask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a80881151b0d3d0ef37bde1e9716bdb77}\label{namespacenumpy_1_1ma_1_1core_a80881151b0d3d0ef37bde1e9716bdb77} 
\index{numpy.ma.core@{numpy.ma.core}!\_recursive\_printoption@{\_recursive\_printoption}}
\index{\_recursive\_printoption@{\_recursive\_printoption}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_recursive\_printoption()}{\_recursive\_printoption()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+recursive\+\_\+printoption (\begin{DoxyParamCaption}\item[{}]{result,  }\item[{}]{mask,  }\item[{}]{printopt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Puts printoptions in result where mask is True.

Private function allowing for recursion\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a521adf7968e7831e37ed30aa16a8792a}\label{namespacenumpy_1_1ma_1_1core_a521adf7968e7831e37ed30aa16a8792a} 
\index{numpy.ma.core@{numpy.ma.core}!\_recursive\_set\_fill\_value@{\_recursive\_set\_fill\_value}}
\index{\_recursive\_set\_fill\_value@{\_recursive\_set\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_recursive\_set\_fill\_value()}{\_recursive\_set\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+recursive\+\_\+set\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{fillvalue,  }\item[{}]{dt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Create a fill value for a structured dtype.

Parameters
----------
fillvalue : scalar or array_like
    Scalar or array representing the fill value. If it is of shorter
    length than the number of fields in dt, it will be resized.
dt : dtype
    The structured dtype for which to create the fill value.

Returns
-------
val : tuple
    A tuple of values corresponding to the structured fill value.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a55a386d96641acbe3530419a3f4a4265}\label{namespacenumpy_1_1ma_1_1core_a55a386d96641acbe3530419a3f4a4265} 
\index{numpy.ma.core@{numpy.ma.core}!\_replace\_dtype\_fields@{\_replace\_dtype\_fields}}
\index{\_replace\_dtype\_fields@{\_replace\_dtype\_fields}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_replace\_dtype\_fields()}{\_replace\_dtype\_fields()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+replace\+\_\+dtype\+\_\+fields (\begin{DoxyParamCaption}\item[{}]{dtype,  }\item[{}]{primitive\+\_\+dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Construct a dtype description list from a given dtype.

Returns a new dtype object, with all fields and subtypes in the given type
recursively replaced with `primitive_dtype`.

Arguments are coerced to dtypes first.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a45ba8078d1c5287aeece0211bc1c1496}\label{namespacenumpy_1_1ma_1_1core_a45ba8078d1c5287aeece0211bc1c1496} 
\index{numpy.ma.core@{numpy.ma.core}!\_replace\_dtype\_fields\_recursive@{\_replace\_dtype\_fields\_recursive}}
\index{\_replace\_dtype\_fields\_recursive@{\_replace\_dtype\_fields\_recursive}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_replace\_dtype\_fields\_recursive()}{\_replace\_dtype\_fields\_recursive()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+replace\+\_\+dtype\+\_\+fields\+\_\+recursive (\begin{DoxyParamCaption}\item[{}]{dtype,  }\item[{}]{primitive\+\_\+dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Mask creation functions \#. 

\Hypertarget{namespacenumpy_1_1ma_1_1core_a006d08297579b9505140ea2077624f9f}\label{namespacenumpy_1_1ma_1_1core_a006d08297579b9505140ea2077624f9f} 
\index{numpy.ma.core@{numpy.ma.core}!\_shrink\_mask@{\_shrink\_mask}}
\index{\_shrink\_mask@{\_shrink\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_shrink\_mask()}{\_shrink\_mask()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+shrink\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Shrink a mask to nomask if possible
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_aa73814f68c47a0cbf4b86a24fbaffd83}\label{namespacenumpy_1_1ma_1_1core_aa73814f68c47a0cbf4b86a24fbaffd83} 
\index{numpy.ma.core@{numpy.ma.core}!allclose@{allclose}}
\index{allclose@{allclose}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{allclose()}{allclose()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+allclose (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{masked\+\_\+equal = {\ttfamily True},  }\item[{}]{rtol = {\ttfamily 1e-\/5},  }\item[{}]{atol = {\ttfamily 1e-\/8} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if two arrays are element-wise equal within a tolerance.

This function is equivalent to `allclose` except that masked values
are treated as equal (default) or unequal, depending on the `masked_equal`
argument.

Parameters
----------
a, b : array_like
    Input arrays to compare.
masked_equal : bool, optional
    Whether masked values in `a` and `b` are considered equal (True) or not
    (False). They are considered equal by default.
rtol : float, optional
    Relative tolerance. The relative difference is equal to ``rtol * b``.
    Default is 1e-5.
atol : float, optional
    Absolute tolerance. The absolute difference is equal to `atol`.
    Default is 1e-8.

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN, then
    False is returned.

See Also
--------
all, any
numpy.allclose : the non-masked `allclose`.

Notes
-----
If the following equation is element-wise True, then `allclose` returns
True::

  absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

Return True if all elements of `a` and `b` are equal subject to
given tolerances.

Examples
--------
>>> import numpy as np
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)
>>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
False

>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False

Masked values are not compared directly.

>>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
>>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
>>> np.ma.allclose(a, b)
True
>>> np.ma.allclose(a, b, masked_equal=False)
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a40941b55c634d680617c73fae1ce7f73}\label{namespacenumpy_1_1ma_1_1core_a40941b55c634d680617c73fae1ce7f73} 
\index{numpy.ma.core@{numpy.ma.core}!allequal@{allequal}}
\index{allequal@{allequal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{allequal()}{allequal()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+allequal (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{fill\+\_\+value = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True if all entries of a and b are equal, using
fill_value as a truth value where either or both are masked.

Parameters
----------
a, b : array_like
    Input arrays to compare.
fill_value : bool, optional
    Whether masked values in a or b are considered equal (True) or not
    (False).

Returns
-------
y : bool
    Returns True if the two arrays are equal within the given
    tolerance, False otherwise. If either array contains NaN,
    then False is returned.

See Also
--------
all, any
numpy.ma.allclose

Examples
--------
>>> import numpy as np
>>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
>>> a
masked_array(data=[10000000000.0, 1e-07, --],
             mask=[False, False,  True],
       fill_value=1e+20)

>>> b = np.array([1e10, 1e-7, -42.0])
>>> b
array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
>>> np.ma.allequal(a, b, fill_value=False)
False
>>> np.ma.allequal(a, b)
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a1d9dce7af4836e53297697234f2c3c6a}\label{namespacenumpy_1_1ma_1_1core_a1d9dce7af4836e53297697234f2c3c6a} 
\index{numpy.ma.core@{numpy.ma.core}!append@{append}}
\index{append@{append}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{append()}{append()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+append (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Append values to the end of an array.

Parameters
----------
a : array_like
    Values are appended to a copy of this array.
b : array_like
    These values are appended to a copy of `a`.  It must be of the
    correct shape (the same shape as `a`, excluding `axis`).  If `axis`
    is not specified, `b` can be any shape and will be flattened
    before use.
axis : int, optional
    The axis along which `v` are appended.  If `axis` is not given,
    both `a` and `b` are flattened before use.

Returns
-------
append : MaskedArray
    A copy of `a` with `b` appended to `axis`.  Note that `append`
    does not occur in-place: a new array is allocated and filled.  If
    `axis` is None, the result is a flattened array.

See Also
--------
numpy.append : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_values([1, 2, 3], 2)
>>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
>>> ma.append(a, b)
masked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],
             mask=[False,  True, False, False, False, False,  True, False,
                   False],
       fill_value=999999)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ae1b895f987ca5bb03524e0d7324d83e3}\label{namespacenumpy_1_1ma_1_1core_ae1b895f987ca5bb03524e0d7324d83e3} 
\index{numpy.ma.core@{numpy.ma.core}!argsort@{argsort}}
\index{argsort@{argsort}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{argsort()}{argsort()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+argsort (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily np.\+\_\+NoValue},  }\item[{}]{kind = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{endwith = {\ttfamily True},  }\item[{}]{fill\+\_\+value = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{stable = {\ttfamily None} }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a0a839d6f59d4481fc3405f0c38aec044}\label{namespacenumpy_1_1ma_1_1core_a0a839d6f59d4481fc3405f0c38aec044} 
\index{numpy.ma.core@{numpy.ma.core}!array@{array}}
\index{array@{array}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{array()}{array()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+array (\begin{DoxyParamCaption}\item[{}]{data,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{copy = {\ttfamily False},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{mask = {\ttfamily \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa}{nomask}}},  }\item[{}]{fill\+\_\+value = {\ttfamily None},  }\item[{}]{keep\+\_\+mask = {\ttfamily True},  }\item[{}]{hard\+\_\+mask = {\ttfamily False},  }\item[{}]{shrink = {\ttfamily True},  }\item[{}]{subok = {\ttfamily True},  }\item[{}]{ndmin = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Shortcut to MaskedArray.

The options are in a different order for convenience and backwards
compatibility.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a393b347bd5a52ed9fddf4d5473384053}\label{namespacenumpy_1_1ma_1_1core_a393b347bd5a52ed9fddf4d5473384053} 
\index{numpy.ma.core@{numpy.ma.core}!asanyarray@{asanyarray}}
\index{asanyarray@{asanyarray}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{asanyarray()}{asanyarray()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+asanyarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert the input to a masked array, conserving subclasses.

If `a` is a subclass of `MaskedArray`, its class is conserved.
No copy is performed if the input is already an `ndarray`.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    MaskedArray interpretation of `a`.

See Also
--------
asarray : Similar to `asanyarray`, but does not conserve subclass.

Examples
--------
>>> import numpy as np
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asanyarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asanyarray(x))
<class 'numpy.ma.MaskedArray'>\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_aabc3d18f0d2aa0309397b4d17d83dfb4}\label{namespacenumpy_1_1ma_1_1core_aabc3d18f0d2aa0309397b4d17d83dfb4} 
\index{numpy.ma.core@{numpy.ma.core}!asarray@{asarray}}
\index{asarray@{asarray}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{asarray()}{asarray()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+asarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert the input to a masked array of the given data-type.

No copy is performed if the input is already an `ndarray`. If `a` is
a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to a masked array. This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists, ndarrays and masked arrays.
dtype : dtype, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major ('C') or column-major ('FORTRAN') memory
    representation.  Default is 'C'.

Returns
-------
out : MaskedArray
    Masked array interpretation of `a`.

See Also
--------
asanyarray : Similar to `asarray`, but conserves subclasses.

Examples
--------
>>> import numpy as np
>>> x = np.arange(10.).reshape(2, 5)
>>> x
array([[0., 1., 2., 3., 4.],
       [5., 6., 7., 8., 9.]])
>>> np.ma.asarray(x)
masked_array(
  data=[[0., 1., 2., 3., 4.],
        [5., 6., 7., 8., 9.]],
  mask=False,
  fill_value=1e+20)
>>> type(np.ma.asarray(x))
<class 'numpy.ma.MaskedArray'>\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ac838e8bfe1023c704fe75ae9fd4d3eb0}\label{namespacenumpy_1_1ma_1_1core_ac838e8bfe1023c704fe75ae9fd4d3eb0} 
\index{numpy.ma.core@{numpy.ma.core}!choose@{choose}}
\index{choose@{choose}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{choose()}{choose()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+choose (\begin{DoxyParamCaption}\item[{}]{indices,  }\item[{}]{choices,  }\item[{}]{out = {\ttfamily None},  }\item[{}]{mode = {\ttfamily \textquotesingle{}raise\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Use an index array to construct a new array from a list of choices.

Given an array of integers and a list of n choice arrays, this method
will create a new array that merges each of the choice arrays.  Where a
value in `index` is i, the new array will have the value that choices[i]
contains in the same place.

Parameters
----------
indices : ndarray of ints
    This array must contain integers in ``[0, n-1]``, where n is the
    number of choices.
choices : sequence of arrays
    Choice arrays. The index array and all of the choices should be
    broadcastable to the same shape.
out : array, optional
    If provided, the result will be inserted into this array. It should
    be of the appropriate shape and `dtype`.
mode : {'raise', 'wrap', 'clip'}, optional
    Specifies how out-of-bounds indices will behave.

    * 'raise' : raise an error
    * 'wrap' : wrap around
    * 'clip' : clip to the range

Returns
-------
merged_array : array

See Also
--------
choose : equivalent function

Examples
--------
>>> import numpy as np
>>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
>>> a = np.array([2, 1, 0])
>>> np.ma.choose(a, choice)
masked_array(data=[3, 2, 1],
             mask=False,
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ac3da570ac32589600012584bcd7c26d5}\label{namespacenumpy_1_1ma_1_1core_ac3da570ac32589600012584bcd7c26d5} 
\index{numpy.ma.core@{numpy.ma.core}!common\_fill\_value@{common\_fill\_value}}
\index{common\_fill\_value@{common\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{common\_fill\_value()}{common\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+common\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the common filling value of two masked arrays, if any.

If ``a.fill_value == b.fill_value``, return the fill value,
otherwise return None.

Parameters
----------
a, b : MaskedArray
    The masked arrays for which to compare fill values.

Returns
-------
fill_value : scalar or None
    The common fill value, or None.

Examples
--------
>>> import numpy as np
>>> x = np.ma.array([0, 1.], fill_value=3)
>>> y = np.ma.array([0, 1.], fill_value=3)
>>> np.ma.common_fill_value(x, y)
3.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a3b0776037b5ae1986b4385e1f67ec028}\label{namespacenumpy_1_1ma_1_1core_a3b0776037b5ae1986b4385e1f67ec028} 
\index{numpy.ma.core@{numpy.ma.core}!compressed@{compressed}}
\index{compressed@{compressed}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{compressed()}{compressed()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+compressed (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return all the non-masked data as a 1-D array.

This function is equivalent to calling the "compressed" method of a
`ma.MaskedArray`, see `ma.MaskedArray.compressed` for details.

See Also
--------
ma.MaskedArray.compressed : Equivalent method.

Examples
--------
>>> import numpy as np

Create an array with negative values masked:

>>> import numpy as np
>>> x = np.array([[1, -1, 0], [2, -1, 3], [7, 4, -1]])
>>> masked_x = np.ma.masked_array(x, mask=x < 0)
>>> masked_x
masked_array(
  data=[[1, --, 0],
        [2, --, 3],
        [7, 4, --]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False, False,  True]],
  fill_value=999999)

Compress the masked array into a 1-D array of non-masked values:

>>> np.ma.compressed(masked_x)
array([1, 0, 2, 3, 7, 4])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a3509218a0b44b803c13b0e4110f13f10}\label{namespacenumpy_1_1ma_1_1core_a3509218a0b44b803c13b0e4110f13f10} 
\index{numpy.ma.core@{numpy.ma.core}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{concatenate()}{concatenate()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+concatenate (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Concatenate a sequence of arrays along the given axis.

Parameters
----------
arrays : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined. Default is 0.

Returns
-------
result : MaskedArray
    The concatenated array with any masked entries preserved.

See Also
--------
numpy.concatenate : Equivalent function in the top-level NumPy module.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.arange(3)
>>> a[1] = ma.masked
>>> b = ma.arange(2, 5)
>>> a
masked_array(data=[0, --, 2],
             mask=[False,  True, False],
       fill_value=999999)
>>> b
masked_array(data=[2, 3, 4],
             mask=False,
       fill_value=999999)
>>> ma.concatenate([a, b])
masked_array(data=[0, --, 2, 2, 3, 4],
             mask=[False,  True, False, False, False, False],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_aadf0ba5e946ec7682c2ebecd726c7139}\label{namespacenumpy_1_1ma_1_1core_aadf0ba5e946ec7682c2ebecd726c7139} 
\index{numpy.ma.core@{numpy.ma.core}!convolve@{convolve}}
\index{convolve@{convolve}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{convolve()}{convolve()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+convolve (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily \textquotesingle{}full\textquotesingle{}},  }\item[{}]{propagate\+\_\+mask = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the discrete, linear convolution of two one-dimensional sequences.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `np.convolve` docstring.
propagate_mask : bool
    If True, then if any masked element is included in the sum for a result
    element, then the result is masked.
    If False, then the result element is only masked if no non-masked cells
    contribute towards it

Returns
-------
out : MaskedArray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
numpy.convolve : Equivalent function in the top-level NumPy module.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a19b3312e7c0d0e9ffa0911c91a095f17}\label{namespacenumpy_1_1ma_1_1core_a19b3312e7c0d0e9ffa0911c91a095f17} 
\index{numpy.ma.core@{numpy.ma.core}!correlate@{correlate}}
\index{correlate@{correlate}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{correlate()}{correlate()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+correlate (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily \textquotesingle{}valid\textquotesingle{}},  }\item[{}]{propagate\+\_\+mask = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cross-correlation of two 1-dimensional sequences.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `np.convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.
propagate_mask : bool
    If True, then a result element is masked if any masked element contributes towards it.
    If False, then a result element is only masked if no non-masked element
    contribute towards it

Returns
-------
out : MaskedArray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
numpy.correlate : Equivalent function in the top-level NumPy module.

Examples
--------
Basic correlation:

>>> a = np.ma.array([1, 2, 3])
>>> v = np.ma.array([0, 1, 0])
>>> np.ma.correlate(a, v, mode='valid')
masked_array(data=[2],
             mask=[False],
       fill_value=999999)

Correlation with masked elements:

>>> a = np.ma.array([1, 2, 3], mask=[False, True, False])
>>> v = np.ma.array([0, 1, 0])
>>> np.ma.correlate(a, v, mode='valid', propagate_mask=True)
masked_array(data=[--],
             mask=[ True],
       fill_value=999999,
            dtype=int64)

Correlation with different modes and mixed array types:

>>> a = np.ma.array([1, 2, 3])
>>> v = np.ma.array([0, 1, 0])
>>> np.ma.correlate(a, v, mode='full')
masked_array(data=[0, 1, 2, 3, 0],
             mask=[False, False, False, False, False],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ad5a02ac1caadf6d733568327c2c43a46}\label{namespacenumpy_1_1ma_1_1core_ad5a02ac1caadf6d733568327c2c43a46} 
\index{numpy.ma.core@{numpy.ma.core}!default\_fill\_value@{default\_fill\_value}}
\index{default\_fill\_value@{default\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{default\_fill\_value()}{default\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+default\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the default fill value for the argument object.

The default filling value depends on the datatype of the input
array or the type of the input scalar:

   ========  ========
   datatype  default
   ========  ========
   bool      True
   int       999999
   float     1.e20
   complex   1.e20+0j
   object    '?'
   string    'N/A'
   ========  ========

For structured types, a structured scalar is returned, with each field the
default fill value for its type.

For subarray types, the fill value is an array of the same size containing
the default scalar fill value.

Parameters
----------
obj : ndarray, dtype or scalar
    The array data-type or scalar for which the default fill value
    is returned.

Returns
-------
fill_value : scalar
    The default fill value.

Examples
--------
>>> import numpy as np
>>> np.ma.default_fill_value(1)
999999
>>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
1e+20
>>> np.ma.default_fill_value(np.dtype(complex))
(1e+20+0j)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ab3368dd2555ba4ec5e1da5e9fcaba2a0}\label{namespacenumpy_1_1ma_1_1core_ab3368dd2555ba4ec5e1da5e9fcaba2a0} 
\index{numpy.ma.core@{numpy.ma.core}!diag@{diag}}
\index{diag@{diag}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{diag()}{diag()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+diag (\begin{DoxyParamCaption}\item[{}]{v,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Extract a diagonal or construct a diagonal array.

This function is the equivalent of `numpy.diag` that takes masked
values into account, see `numpy.diag` for details.

See Also
--------
numpy.diag : Equivalent function for ndarrays.

Examples
--------
>>> import numpy as np

Create an array with negative values masked:

>>> import numpy as np
>>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])
>>> masked_x = np.ma.masked_array(x, mask=x < 0)
>>> masked_x
masked_array(
  data=[[11.2, --, 18.0],
        [0.801, --, 12.0],
        [7.0, 33.0, --]],
  mask=[[False,  True, False],
        [False,  True, False],
        [False, False,  True]],
  fill_value=1e+20)

Isolate the main diagonal from the masked array:

>>> np.ma.diag(masked_x)
masked_array(data=[11.2, --, --],
             mask=[False,  True,  True],
       fill_value=1e+20)

Isolate the first diagonal below the main diagonal:

>>> np.ma.diag(masked_x, -1)
masked_array(data=[0.801, 33.0],
             mask=[False, False],
       fill_value=1e+20)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a06f276c8db95a032269ebd2463b46ff3}\label{namespacenumpy_1_1ma_1_1core_a06f276c8db95a032269ebd2463b46ff3} 
\index{numpy.ma.core@{numpy.ma.core}!diff@{diff}}
\index{diff@{diff}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{diff()}{diff()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+diff (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{n = {\ttfamily 1},  }\item[{}]{axis = {\ttfamily -\/1},  }\item[{}]{prepend = {\ttfamily np.\+\_\+NoValue},  }\item[{}]{append = {\ttfamily np.\+\_\+NoValue} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate the n-th discrete difference along the given axis.
The first difference is given by ``out[i] = a[i+1] - a[i]`` along
the given axis, higher differences are calculated by using `diff`
recursively.
Preserves the input mask.

Parameters
----------
a : array_like
    Input array
n : int, optional
    The number of times values are differenced. If zero, the input
    is returned as-is.
axis : int, optional
    The axis along which the difference is taken, default is the
    last axis.
prepend, append : array_like, optional
    Values to prepend or append to `a` along axis prior to
    performing the difference.  Scalar values are expanded to
    arrays with length 1 in the direction of axis and the shape
    of the input array in along all other axes.  Otherwise the
    dimension and shape must match `a` except along axis.

Returns
-------
diff : MaskedArray
    The n-th differences. The shape of the output is the same as `a`
    except along `axis` where the dimension is smaller by `n`. The
    type of the output is the same as the type of the difference
    between any two elements of `a`. This is the same as the type of
    `a` in most cases. A notable exception is `datetime64`, which
    results in a `timedelta64` output array.

See Also
--------
numpy.diff : Equivalent function in the top-level NumPy module.

Notes
-----
Type is preserved for boolean arrays, so the result will contain
`False` when consecutive elements are the same and `True` when they
differ.

For unsigned integer arrays, the results will also be unsigned. This
should not be surprising, as the result is consistent with
calculating the difference directly:

>>> u8_arr = np.array([1, 0], dtype=np.uint8)
>>> np.ma.diff(u8_arr)
masked_array(data=[255],
             mask=False,
       fill_value=np.uint64(999999),
            dtype=uint8)
>>> u8_arr[1,...] - u8_arr[0,...]
np.uint8(255)

If this is not desirable, then the array should be cast to a larger
integer type first:

>>> i16_arr = u8_arr.astype(np.int16)
>>> np.ma.diff(i16_arr)
masked_array(data=[-1],
             mask=False,
       fill_value=np.int64(999999),
            dtype=int16)

Examples
--------
>>> import numpy as np
>>> a = np.array([1, 2, 3, 4, 7, 0, 2, 3])
>>> x = np.ma.masked_where(a < 2, a)
>>> np.ma.diff(x)
masked_array(data=[--, 1, 1, 3, --, --, 1],
        mask=[ True, False, False, False,  True,  True, False],
    fill_value=999999)

>>> np.ma.diff(x, n=2)
masked_array(data=[--, 0, 2, --, --, --],
            mask=[ True, False, False,  True,  True,  True],
    fill_value=999999)

>>> a = np.array([[1, 3, 1, 5, 10], [0, 1, 5, 6, 8]])
>>> x = np.ma.masked_equal(a, value=1)
>>> np.ma.diff(x)
masked_array(
    data=[[--, --, --, 5],
            [--, --, 1, 2]],
    mask=[[ True,  True,  True, False],
            [ True,  True, False, False]],
    fill_value=1)

>>> np.ma.diff(x, axis=0)
masked_array(data=[[--, --, --, 1, -2]],
        mask=[[ True,  True,  True, False, False]],
    fill_value=1)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a6f0e91b54079800992bd9aa38f331d5e}\label{namespacenumpy_1_1ma_1_1core_a6f0e91b54079800992bd9aa38f331d5e} 
\index{numpy.ma.core@{numpy.ma.core}!doc\_note@{doc\_note}}
\index{doc\_note@{doc\_note}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{doc\_note()}{doc\_note()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+doc\+\_\+note (\begin{DoxyParamCaption}\item[{}]{initialdoc,  }\item[{}]{note }\end{DoxyParamCaption})}

\begin{DoxyVerb}Adds a Notes section to an existing docstring.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a6281cff9d348f621ed71cbbf8399ac39}\label{namespacenumpy_1_1ma_1_1core_a6281cff9d348f621ed71cbbf8399ac39} 
\index{numpy.ma.core@{numpy.ma.core}!dot@{dot}}
\index{dot@{dot}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{dot()}{dot()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+dot (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{strict = {\ttfamily False},  }\item[{}]{out = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the dot product of two arrays.

This function is the equivalent of `numpy.dot` that takes masked values
into account. Note that `strict` and `out` are in different position
than in the method version. In order to maintain compatibility with the
corresponding method, it is recommended that the optional arguments be
treated as keyword only.  At some point that may be mandatory.

Parameters
----------
a, b : masked_array_like
    Inputs arrays.
strict : bool, optional
    Whether masked data are propagated (True) or set to 0 (False) for
    the computation. Default is False.  Propagating the mask means that
    if a masked value appears in a row or column, the whole row or
    column is considered masked.
out : masked_array, optional
    Output argument. This must have the exact kind that would be returned
    if it was not used. In particular, it must have the right type, must be
    C-contiguous, and its dtype must be the dtype that would be returned
    for `dot(a,b)`. This is a performance feature. Therefore, if these
    conditions are not met, an exception is raised, instead of attempting
    to be flexible.

See Also
--------
numpy.dot : Equivalent function for ndarrays.

Examples
--------
>>> import numpy as np
>>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
>>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
>>> np.ma.dot(a, b)
masked_array(
  data=[[21, 26],
        [45, 64]],
  mask=[[False, False],
        [False, False]],
  fill_value=999999)
>>> np.ma.dot(a, b, strict=True)
masked_array(
  data=[[--, --],
        [--, 64]],
  mask=[[ True,  True],
        [ True, False]],
  fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a9bf4d0cb73db89ca836e1b10f6901b8a}\label{namespacenumpy_1_1ma_1_1core_a9bf4d0cb73db89ca836e1b10f6901b8a} 
\index{numpy.ma.core@{numpy.ma.core}!filled@{filled}}
\index{filled@{filled}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{filled()}{filled()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+filled (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{fill\+\_\+value = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return input as an `~numpy.ndarray`, with masked values replaced by
`fill_value`.

If `a` is not a `MaskedArray`, `a` itself is returned.
If `a` is a `MaskedArray` with no masked values, then ``a.data`` is
returned.
If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
``a.fill_value``.

Parameters
----------
a : MaskedArray or array_like
    An input object.
fill_value : array_like, optional.
    Can be scalar or non-scalar. If non-scalar, the
    resulting filled array should be broadcastable
    over input array. Default is None.

Returns
-------
a : ndarray
    The filled array.

See Also
--------
compressed

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                [1, 0, 0],
...                                                [0, 0, 0]])
>>> x.filled()
array([[999999,      1,      2],
       [999999,      4,      5],
       [     6,      7,      8]])
>>> x.filled(fill_value=333)
array([[333,   1,   2],
       [333,   4,   5],
       [  6,   7,   8]])
>>> x.filled(fill_value=np.arange(3))
array([[0, 1, 2],
       [0, 4, 5],
       [6, 7, 8]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_abd0dc2488d85131a27e4304fbfa4eded}\label{namespacenumpy_1_1ma_1_1core_abd0dc2488d85131a27e4304fbfa4eded} 
\index{numpy.ma.core@{numpy.ma.core}!fix\_invalid@{fix\_invalid}}
\index{fix\_invalid@{fix\_invalid}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{fix\_invalid()}{fix\_invalid()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+fix\+\_\+invalid (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{mask = {\ttfamily \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa}{nomask}}},  }\item[{}]{copy = {\ttfamily True},  }\item[{}]{fill\+\_\+value = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return input with invalid data masked and replaced by a fill value.

Invalid data means values of `nan`, `inf`, etc.

Parameters
----------
a : array_like
    Input array, a (subclass of) ndarray.
mask : sequence, optional
    Mask. Must be convertible to an array of booleans with the same
    shape as `data`. True indicates a masked (i.e. invalid) data.
copy : bool, optional
    Whether to use a copy of `a` (True) or to fix `a` in place (False).
    Default is True.
fill_value : scalar, optional
    Value used for fixing invalid data. Default is None, in which case
    the ``a.fill_value`` is used.

Returns
-------
b : MaskedArray
    The input array with invalid entries fixed.

Notes
-----
A copy is performed by default.

Examples
--------
>>> import numpy as np
>>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
>>> x
masked_array(data=[--, -1.0, nan, inf],
             mask=[ True, False, False, False],
       fill_value=1e+20)
>>> np.ma.fix_invalid(x)
masked_array(data=[--, -1.0, --, --],
             mask=[ True, False,  True,  True],
       fill_value=1e+20)

>>> fixed = np.ma.fix_invalid(x)
>>> fixed.data
array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])
>>> x.data
array([ 1., -1., nan, inf])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a0bff3f782fbb208507113978d1946731}\label{namespacenumpy_1_1ma_1_1core_a0bff3f782fbb208507113978d1946731} 
\index{numpy.ma.core@{numpy.ma.core}!flatten\_mask@{flatten\_mask}}
\index{flatten\_mask@{flatten\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{flatten\_mask()}{flatten\_mask()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+flatten\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{mask }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a completely flattened version of the mask, where nested fields
are collapsed.

Parameters
----------
mask : array_like
    Input array, which will be interpreted as booleans.

Returns
-------
flattened_mask : ndarray of bools
    The flattened input.

Examples
--------
>>> import numpy as np
>>> mask = np.array([0, 0, 1])
>>> np.ma.flatten_mask(mask)
array([False, False,  True])

>>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
>>> np.ma.flatten_mask(mask)
array([False, False, False,  True])

>>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
>>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
>>> np.ma.flatten_mask(mask)
array([False, False, False, False, False,  True])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a2c5384e6a47a6f88b63da86dcd621f43}\label{namespacenumpy_1_1ma_1_1core_a2c5384e6a47a6f88b63da86dcd621f43} 
\index{numpy.ma.core@{numpy.ma.core}!flatten\_structured\_array@{flatten\_structured\_array}}
\index{flatten\_structured\_array@{flatten\_structured\_array}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{flatten\_structured\_array()}{flatten\_structured\_array()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+flatten\+\_\+structured\+\_\+array (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Flatten a structured array.

The data type of the output is chosen such that it can represent all of the
(nested) fields.

Parameters
----------
a : structured array

Returns
-------
output : masked array or ndarray
    A flattened masked array if the input is a masked array, otherwise a
    standard ndarray.

Examples
--------
>>> import numpy as np
>>> ndtype = [('a', int), ('b', float)]
>>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
>>> np.ma.flatten_structured_array(a)
array([[1., 1.],
       [2., 2.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a88211fe629ec66c81f9bff690cf515c6}\label{namespacenumpy_1_1ma_1_1core_a88211fe629ec66c81f9bff690cf515c6} 
\index{numpy.ma.core@{numpy.ma.core}!fromfile@{fromfile}}
\index{fromfile@{fromfile}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{fromfile()}{fromfile()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+fromfile (\begin{DoxyParamCaption}\item[{}]{file,  }\item[{}]{dtype = {\ttfamily float},  }\item[{}]{count = {\ttfamily -\/1},  }\item[{}]{sep = {\ttfamily \textquotesingle{}\textquotesingle{}} }\end{DoxyParamCaption})}



Pickling \#. 

\Hypertarget{namespacenumpy_1_1ma_1_1core_acf3e8f70cdcea57b5844edd6e05d9ff4}\label{namespacenumpy_1_1ma_1_1core_acf3e8f70cdcea57b5844edd6e05d9ff4} 
\index{numpy.ma.core@{numpy.ma.core}!fromflex@{fromflex}}
\index{fromflex@{fromflex}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{fromflex()}{fromflex()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+fromflex (\begin{DoxyParamCaption}\item[{}]{fxarray }\end{DoxyParamCaption})}

\begin{DoxyVerb}Build a masked array from a suitable flexible-type array.

The input array has to have a data-type with ``_data`` and ``_mask``
fields. This type of array is output by `MaskedArray.toflex`.

Parameters
----------
fxarray : ndarray
    The structured input array, containing ``_data`` and ``_mask``
    fields. If present, other fields are discarded.

Returns
-------
result : MaskedArray
    The constructed masked array.

See Also
--------
MaskedArray.toflex : Build a flexible-type array from a masked array.

Examples
--------
>>> import numpy as np
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
>>> rec = x.toflex()
>>> rec
array([[(0, False), (1,  True), (2, False)],
       [(3,  True), (4, False), (5,  True)],
       [(6, False), (7,  True), (8, False)]],
      dtype=[('_data', '<i8'), ('_mask', '?')])
>>> x2 = np.ma.fromflex(rec)
>>> x2
masked_array(
  data=[[0, --, 2],
        [--, 4, --],
        [6, --, 8]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=999999)

Extra fields can be present in the structured array but are discarded:

>>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
>>> rec2 = np.zeros((2, 2), dtype=dt)
>>> rec2
array([[(0, False, 0.), (0, False, 0.)],
       [(0, False, 0.), (0, False, 0.)]],
      dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])
>>> y = np.ma.fromflex(rec2)
>>> y
masked_array(
  data=[[0, 0],
        [0, 0]],
  mask=[[False, False],
        [False, False]],
  fill_value=np.int64(999999),
  dtype=int32)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_af6954f803de9662fc6d6590f5192b963}\label{namespacenumpy_1_1ma_1_1core_af6954f803de9662fc6d6590f5192b963} 
\index{numpy.ma.core@{numpy.ma.core}!get\_fill\_value@{get\_fill\_value}}
\index{get\_fill\_value@{get\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{get\_fill\_value()}{get\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+get\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the filling value of a, if any.  Otherwise, returns the
default filling value for that type.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a51a67076b6cd7f08b2524bb4f66e12fc}\label{namespacenumpy_1_1ma_1_1core_a51a67076b6cd7f08b2524bb4f66e12fc} 
\index{numpy.ma.core@{numpy.ma.core}!get\_masked\_subclass@{get\_masked\_subclass}}
\index{get\_masked\_subclass@{get\_masked\_subclass}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{get\_masked\_subclass()}{get\_masked\_subclass()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+get\+\_\+masked\+\_\+subclass (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arrays }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the youngest subclass of MaskedArray from a list of (masked) arrays.

In case of siblings, the first listed takes over.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a26eaadcf12b8f2ec709d24024f259d25}\label{namespacenumpy_1_1ma_1_1core_a26eaadcf12b8f2ec709d24024f259d25} 
\index{numpy.ma.core@{numpy.ma.core}!get\_object\_signature@{get\_object\_signature}}
\index{get\_object\_signature@{get\_object\_signature}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{get\_object\_signature()}{get\_object\_signature()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+get\+\_\+object\+\_\+signature (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}Get the signature from obj\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4c058cfe52befdaf7bc1beb8c06e3b0d}\label{namespacenumpy_1_1ma_1_1core_a4c058cfe52befdaf7bc1beb8c06e3b0d} 
\index{numpy.ma.core@{numpy.ma.core}!getdata@{getdata}}
\index{getdata@{getdata}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{getdata()}{getdata()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+getdata (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{subok = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the data of a masked array as an ndarray.

Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
else return `a` as a ndarray or subclass (depending on `subok`) if not.

Parameters
----------
a : array_like
    Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
subok : bool
    Whether to force the output to be a `pure` ndarray (False) or to
    return a subclass of ndarray if appropriate (True, default).

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getdata(a)
array([[1, 2],
       [3, 4]])

Equivalently use the ``MaskedArray`` `data` attribute.

>>> a.data
array([[1, 2],
       [3, 4]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_aee4137f8256ee554372b8e0629355971}\label{namespacenumpy_1_1ma_1_1core_aee4137f8256ee554372b8e0629355971} 
\index{numpy.ma.core@{numpy.ma.core}!getmask@{getmask}}
\index{getmask@{getmask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{getmask()}{getmask()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+getmask (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the mask of a masked array, or nomask.

Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
mask is not `nomask`, else return `nomask`. To guarantee a full array
of booleans of the same shape as a, use `getmaskarray`.

Parameters
----------
a : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getdata : Return the data of a masked array as an ndarray.
getmaskarray : Return the mask of a masked array, or full array of False.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmask(a)
array([[False,  True],
       [False, False]])

Equivalently use the `MaskedArray` `mask` attribute.

>>> a.mask
array([[False,  True],
       [False, False]])

Result when mask == `nomask`

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.nomask
False
>>> ma.getmask(b) == ma.nomask
True
>>> b.mask == ma.nomask
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_adb1639d29d31fafd121ba5ac18236508}\label{namespacenumpy_1_1ma_1_1core_adb1639d29d31fafd121ba5ac18236508} 
\index{numpy.ma.core@{numpy.ma.core}!getmaskarray@{getmaskarray}}
\index{getmaskarray@{getmaskarray}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{getmaskarray()}{getmaskarray()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+getmaskarray (\begin{DoxyParamCaption}\item[{}]{arr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the mask of a masked array, or full boolean array of False.

Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
the mask is not `nomask`, else return a full boolean array of False of
the same shape as `arr`.

Parameters
----------
arr : array_like
    Input `MaskedArray` for which the mask is required.

See Also
--------
getmask : Return the mask of a masked array, or nomask.
getdata : Return the data of a masked array as an ndarray.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.masked_equal([[1,2],[3,4]], 2)
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=2)
>>> ma.getmaskarray(a)
array([[False,  True],
       [False, False]])

Result when mask == ``nomask``

>>> b = ma.masked_array([[1,2],[3,4]])
>>> b
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)
>>> ma.getmaskarray(b)
array([[False, False],
       [False, False]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a70b1e7c1e7cd6089d61329228470907e}\label{namespacenumpy_1_1ma_1_1core_a70b1e7c1e7cd6089d61329228470907e} 
\index{numpy.ma.core@{numpy.ma.core}!inner@{inner}}
\index{inner@{inner}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{inner()}{inner()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+inner (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the inner product of a and b for arrays of floating point types.

Like the generic NumPy equivalent the product sum is over the last dimension
of a and b. The first argument is not conjugated.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a6f3563a212ab5fc2d2950d9db6e2f6b6}\label{namespacenumpy_1_1ma_1_1core_a6f3563a212ab5fc2d2950d9db6e2f6b6} 
\index{numpy.ma.core@{numpy.ma.core}!is\_mask@{is\_mask}}
\index{is\_mask@{is\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{is\_mask()}{is\_mask()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+is\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True if m is a valid, standard mask.

This function does not check the contents of the input, only that the
type is MaskType. In particular, this function returns False if the
mask has a flexible dtype.

Parameters
----------
m : array_like
    Array to test.

Returns
-------
result : bool
    True if `m.dtype.type` is MaskType, False otherwise.

See Also
--------
ma.isMaskedArray : Test whether input is an instance of MaskedArray.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> m
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_mask(m)
False
>>> ma.is_mask(m.mask)
True

Input must be an ndarray (or have similar attributes)
for it to be considered a valid mask.

>>> m = [False, True, False]
>>> ma.is_mask(m)
False
>>> m = np.array([False, True, False])
>>> m
array([False,  True, False])
>>> ma.is_mask(m)
True

Arrays with complex dtypes don't return True.

>>> dtype = np.dtype({'names':['monty', 'pithon'],
...                   'formats':[bool, bool]})
>>> dtype
dtype([('monty', '|b1'), ('pithon', '|b1')])
>>> m = np.array([(True, False), (False, True), (True, False)],
...              dtype=dtype)
>>> m
array([( True, False), (False,  True), ( True, False)],
      dtype=[('monty', '?'), ('pithon', '?')])
>>> ma.is_mask(m)
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a3297519ebd20de2f25f5fb4f80668a8e}\label{namespacenumpy_1_1ma_1_1core_a3297519ebd20de2f25f5fb4f80668a8e} 
\index{numpy.ma.core@{numpy.ma.core}!is\_masked@{is\_masked}}
\index{is\_masked@{is\_masked}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{is\_masked()}{is\_masked()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+is\+\_\+masked (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Determine whether input has masked values.

Accepts any object as input, but always returns False unless the
input is a MaskedArray containing masked values.

Parameters
----------
x : array_like
    Array to check for masked values.

Returns
-------
result : bool
    True if `x` is a MaskedArray with masked values, False otherwise.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
>>> x
masked_array(data=[--, 1, --, 2, 3],
             mask=[ True, False,  True, False, False],
       fill_value=0)
>>> ma.is_masked(x)
True
>>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
>>> x
masked_array(data=[0, 1, 0, 2, 3],
             mask=False,
       fill_value=42)
>>> ma.is_masked(x)
False

Always returns False if `x` isn't a MaskedArray.

>>> x = [False, True, False]
>>> ma.is_masked(x)
False
>>> x = 'a string'
>>> ma.is_masked(x)
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ad1904aae3d2b0ea006529da02fdf31a4}\label{namespacenumpy_1_1ma_1_1core_ad1904aae3d2b0ea006529da02fdf31a4} 
\index{numpy.ma.core@{numpy.ma.core}!is\_string\_or\_list\_of\_strings@{is\_string\_or\_list\_of\_strings}}
\index{is\_string\_or\_list\_of\_strings@{is\_string\_or\_list\_of\_strings}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{is\_string\_or\_list\_of\_strings()}{is\_string\_or\_list\_of\_strings()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+is\+\_\+string\+\_\+or\+\_\+list\+\_\+of\+\_\+strings (\begin{DoxyParamCaption}\item[{}]{val }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e}\label{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e} 
\index{numpy.ma.core@{numpy.ma.core}!isMaskedArray@{isMaskedArray}}
\index{isMaskedArray@{isMaskedArray}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{isMaskedArray()}{isMaskedArray()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+is\+Masked\+Array (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Test whether input is an instance of MaskedArray.

This function returns True if `x` is an instance of MaskedArray
and returns False otherwise.  Any object is accepted as input.

Parameters
----------
x : object
    Object to test.

Returns
-------
result : bool
    True if `x` is a MaskedArray.

See Also
--------
isMA : Alias to isMaskedArray.
isarray : Alias to isMaskedArray.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.eye(3, 3)
>>> a
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
>>> m = ma.masked_values(a, 0)
>>> m
masked_array(
  data=[[1.0, --, --],
        [--, 1.0, --],
        [--, --, 1.0]],
  mask=[[False,  True,  True],
        [ True, False,  True],
        [ True,  True, False]],
  fill_value=0.0)
>>> ma.isMaskedArray(a)
False
>>> ma.isMaskedArray(m)
True
>>> ma.isMaskedArray([0, 1, 2])
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_af00289d0d6b524db91f71f89f78bb682}\label{namespacenumpy_1_1ma_1_1core_af00289d0d6b524db91f71f89f78bb682} 
\index{numpy.ma.core@{numpy.ma.core}!left\_shift@{left\_shift}}
\index{left\_shift@{left\_shift}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{left\_shift()}{left\_shift()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+left\+\_\+shift (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{n }\end{DoxyParamCaption})}

\begin{DoxyVerb}Shift the bits of an integer to the left.

This is the masked array version of `numpy.left_shift`, for details
see that function.

See Also
--------
numpy.left_shift

Examples
--------
Shift with a masked array:

>>> arr = np.ma.array([10, 20, 30], mask=[False, True, False])
>>> np.ma.left_shift(arr, 1)
masked_array(data=[20, --, 60],
             mask=[False,  True, False],
       fill_value=999999)

Large shift:

>>> np.ma.left_shift(10, 10)
masked_array(data=10240,
             mask=False,
       fill_value=999999)

Shift with a scalar and an array:

>>> scalar = 10
>>> arr = np.ma.array([1, 2, 3], mask=[False, True, False])
>>> np.ma.left_shift(scalar, arr)
masked_array(data=[20, --, 80],
             mask=[False,  True, False],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4ae90c998c906a7187d527d5d6f2e6f9}\label{namespacenumpy_1_1ma_1_1core_a4ae90c998c906a7187d527d5d6f2e6f9} 
\index{numpy.ma.core@{numpy.ma.core}!make\_mask@{make\_mask}}
\index{make\_mask@{make\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{make\_mask()}{make\_mask()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+make\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{m,  }\item[{}]{copy = {\ttfamily False},  }\item[{}]{shrink = {\ttfamily True},  }\item[{}]{dtype = {\ttfamily \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e}{Mask\+Type}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a boolean mask from an array.

Return `m` as a boolean mask, creating a copy if necessary or requested.
The function can accept any sequence that is convertible to integers,
or ``nomask``.  Does not require that contents must be 0s and 1s, values
of 0 are interpreted as False, everything else as True.

Parameters
----------
m : array_like
    Potential mask.
copy : bool, optional
    Whether to return a copy of `m` (True) or `m` itself (False).
shrink : bool, optional
    Whether to shrink `m` to ``nomask`` if all its values are False.
dtype : dtype, optional
    Data-type of the output mask. By default, the output mask has a
    dtype of MaskType (bool). If the dtype is flexible, each field has
    a boolean dtype. This is ignored when `m` is ``nomask``, in which
    case ``nomask`` is always returned.

Returns
-------
result : ndarray
    A boolean mask derived from `m`.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> m = [True, False, True, True]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 1, 1]
>>> ma.make_mask(m)
array([ True, False,  True,  True])
>>> m = [1, 0, 2, -3]
>>> ma.make_mask(m)
array([ True, False,  True,  True])

Effect of the `shrink` parameter.

>>> m = np.zeros(4)
>>> m
array([0., 0., 0., 0.])
>>> ma.make_mask(m)
False
>>> ma.make_mask(m, shrink=False)
array([False, False, False, False])

Using a flexible `dtype`.

>>> m = [1, 0, 1, 1]
>>> n = [0, 1, 0, 0]
>>> arr = []
>>> for man, mouse in zip(m, n):
...     arr.append((man, mouse))
>>> arr
[(1, 0), (0, 1), (1, 0), (1, 0)]
>>> dtype = np.dtype({'names':['man', 'mouse'],
...                   'formats':[np.int64, np.int64]})
>>> arr = np.array(arr, dtype=dtype)
>>> arr
array([(1, 0), (0, 1), (1, 0), (1, 0)],
      dtype=[('man', '<i8'), ('mouse', '<i8')])
>>> ma.make_mask(arr, dtype=dtype)
array([(True, False), (False, True), (True, False), (True, False)],
      dtype=[('man', '|b1'), ('mouse', '|b1')])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ad1c6f760a012ec3ff9e7973f81280d58}\label{namespacenumpy_1_1ma_1_1core_ad1c6f760a012ec3ff9e7973f81280d58} 
\index{numpy.ma.core@{numpy.ma.core}!make\_mask\_descr@{make\_mask\_descr}}
\index{make\_mask\_descr@{make\_mask\_descr}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{make\_mask\_descr()}{make\_mask\_descr()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+make\+\_\+mask\+\_\+descr (\begin{DoxyParamCaption}\item[{}]{ndtype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Construct a dtype description list from a given dtype.

Returns a new dtype object, with the type of all fields in `ndtype` to a
boolean type. Field names are not altered.

Parameters
----------
ndtype : dtype
    The dtype to convert.

Returns
-------
result : dtype
    A dtype that looks like `ndtype`, the type of all fields is boolean.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_descr(dtype)
dtype([('foo', '|b1'), ('bar', '|b1')])
>>> ma.make_mask_descr(np.float32)
dtype('bool')\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a77ea7516f02c355e1cab8bfa2d33d0b6}\label{namespacenumpy_1_1ma_1_1core_a77ea7516f02c355e1cab8bfa2d33d0b6} 
\index{numpy.ma.core@{numpy.ma.core}!make\_mask\_none@{make\_mask\_none}}
\index{make\_mask\_none@{make\_mask\_none}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{make\_mask\_none()}{make\_mask\_none()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+make\+\_\+mask\+\_\+none (\begin{DoxyParamCaption}\item[{}]{newshape,  }\item[{}]{dtype = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a boolean mask of the given shape, filled with False.

This function returns a boolean ndarray with all entries False, that can
be used in common mask manipulations. If a complex dtype is specified, the
type of each field is converted to a boolean type.

Parameters
----------
newshape : tuple
    A tuple indicating the shape of the mask.
dtype : {None, dtype}, optional
    If None, use a MaskType instance. Otherwise, use a new datatype with
    the same fields as `dtype`, converted to boolean types.

Returns
-------
result : ndarray
    An ndarray of appropriate shape and dtype, filled with False.

See Also
--------
make_mask : Create a boolean mask from an array.
make_mask_descr : Construct a dtype description list from a given dtype.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> ma.make_mask_none((3,))
array([False, False, False])

Defining a more complex dtype.

>>> dtype = np.dtype({'names':['foo', 'bar'],
...                   'formats':[np.float32, np.int64]})
>>> dtype
dtype([('foo', '<f4'), ('bar', '<i8')])
>>> ma.make_mask_none((3,), dtype=dtype)
array([(False, False), (False, False), (False, False)],
      dtype=[('foo', '|b1'), ('bar', '|b1')])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a3ae4789ed03e5ef62b95d1bdaea0f00e}\label{namespacenumpy_1_1ma_1_1core_a3ae4789ed03e5ef62b95d1bdaea0f00e} 
\index{numpy.ma.core@{numpy.ma.core}!mask\_or@{mask\_or}}
\index{mask\_or@{mask\_or}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{mask\_or()}{mask\_or()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+mask\+\_\+or (\begin{DoxyParamCaption}\item[{}]{m1,  }\item[{}]{m2,  }\item[{}]{copy = {\ttfamily False},  }\item[{}]{shrink = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Combine two masks with the ``logical_or`` operator.

The result may be a view on `m1` or `m2` if the other is `nomask`
(i.e. False).

Parameters
----------
m1, m2 : array_like
    Input masks.
copy : bool, optional
    If copy is False and one of the inputs is `nomask`, return a view
    of the other input mask. Defaults to False.
shrink : bool, optional
    Whether to shrink the output to `nomask` if all its values are
    False. Defaults to True.

Returns
-------
mask : output mask
    The result masks values that are masked in either `m1` or `m2`.

Raises
------
ValueError
    If `m1` and `m2` have different flexible dtypes.

Examples
--------
>>> import numpy as np
>>> m1 = np.ma.make_mask([0, 1, 1, 0])
>>> m2 = np.ma.make_mask([1, 0, 0, 0])
>>> np.ma.mask_or(m1, m2)
array([ True,  True,  True, False])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ad90f5527d29b15ef09fc83ae7634a0e0}\label{namespacenumpy_1_1ma_1_1core_ad90f5527d29b15ef09fc83ae7634a0e0} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_equal@{masked\_equal}}
\index{masked\_equal@{masked\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_equal()}{masked\_equal()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+equal (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where equal to a given value.

Return a MaskedArray, masked where the data in array `x` are
equal to `value`. The fill_value of the returned MaskedArray
is set to `value`.

For floating point arrays, consider using ``masked_values(x, value)``.

See Also
--------
masked_where : Mask where a condition is met.
masked_values : Mask using floating point equality.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_equal(a, 2)
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=2)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_aa13f9e12a8640e931a458e7762f8570d}\label{namespacenumpy_1_1ma_1_1core_aa13f9e12a8640e931a458e7762f8570d} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_greater@{masked\_greater}}
\index{masked\_greater@{masked\_greater}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_greater()}{masked\_greater()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+greater (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where greater than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x > value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater(a, 2)
masked_array(data=[0, 1, 2, --],
             mask=[False, False, False,  True],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a1384d301a60a61d10d03a83814d00107}\label{namespacenumpy_1_1ma_1_1core_a1384d301a60a61d10d03a83814d00107} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_greater\_equal@{masked\_greater\_equal}}
\index{masked\_greater\_equal@{masked\_greater\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_greater\_equal()}{masked\_greater\_equal()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+greater\+\_\+equal (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where greater than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x >= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_greater_equal(a, 2)
masked_array(data=[0, 1, --, --],
             mask=[False, False,  True,  True],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4028ee50d27de9c451a87613e52c1387}\label{namespacenumpy_1_1ma_1_1core_a4028ee50d27de9c451a87613e52c1387} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_inside@{masked\_inside}}
\index{masked\_inside@{masked\_inside}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_inside()}{masked\_inside()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+inside (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{v1,  }\item[{}]{v2,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array inside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` inside
the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`
can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_inside(x, -0.3, 0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

>>> ma.masked_inside(x, 0.3, -0.3)
masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
             mask=[False, False,  True,  True, False, False],
       fill_value=1e+20)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a6aacabf412258dd22ad182492abff10d}\label{namespacenumpy_1_1ma_1_1core_a6aacabf412258dd22ad182492abff10d} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_invalid@{masked\_invalid}}
\index{masked\_invalid@{masked\_invalid}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_invalid()}{masked\_invalid()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+invalid (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where invalid values occur (NaNs or infs).

This function is a shortcut to ``masked_where``, with
`condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
Only applies to arrays with a dtype where NaNs or infs make sense
(i.e. floating point types), but accepts any array_like object.

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(5, dtype=float)
>>> a[2] = np.nan
>>> a[3] = np.inf
>>> a
array([ 0.,  1., nan, inf,  4.])
>>> ma.masked_invalid(a)
masked_array(data=[0.0, 1.0, --, --, 4.0],
             mask=[False, False,  True,  True, False],
       fill_value=1e+20)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a3ffd24d88cda8514693ca8cbb430017c}\label{namespacenumpy_1_1ma_1_1core_a3ffd24d88cda8514693ca8cbb430017c} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_less@{masked\_less}}
\index{masked\_less@{masked\_less}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_less()}{masked\_less()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+less (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where less than a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x < value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less(a, 2)
masked_array(data=[--, --, 2, 3],
             mask=[ True,  True, False, False],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a7eea3b4a436087a24b1b71b224ce0b51}\label{namespacenumpy_1_1ma_1_1core_a7eea3b4a436087a24b1b71b224ce0b51} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_less\_equal@{masked\_less\_equal}}
\index{masked\_less\_equal@{masked\_less\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_less\_equal()}{masked\_less\_equal()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+less\+\_\+equal (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where less than or equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x <= value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_less_equal(a, 2)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ab5f5bd748d2cb9eda89ace0abb746c8a}\label{namespacenumpy_1_1ma_1_1core_ab5f5bd748d2cb9eda89ace0abb746c8a} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_not\_equal@{masked\_not\_equal}}
\index{masked\_not\_equal@{masked\_not\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_not\_equal()}{masked\_not\_equal()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+not\+\_\+equal (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array where *not* equal to a given value.

This function is a shortcut to ``masked_where``, with
`condition` = (x != value).

See Also
--------
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_not_equal(a, 2)
masked_array(data=[--, --, 2, --],
             mask=[ True,  True, False,  True],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a909d623a46766a5d7f9a879e060a941f}\label{namespacenumpy_1_1ma_1_1core_a909d623a46766a5d7f9a879e060a941f} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_object@{masked\_object}}
\index{masked\_object@{masked\_object}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_object()}{masked\_object()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+object (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{copy = {\ttfamily True},  }\item[{}]{shrink = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask the array `x` where the data are exactly equal to value.

This function is similar to `masked_values`, but only suitable
for object arrays: for floating point, use `masked_values` instead.

Parameters
----------
x : array_like
    Array to mask
value : object
    Comparison value
copy : {True, False}, optional
    Whether to return a copy of `x`.
shrink : {True, False}, optional
    Whether to collapse a mask full of False to nomask

Returns
-------
result : MaskedArray
    The result of masking `x` where equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).
masked_values : Mask using floating point equality.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> food = np.array(['green_eggs', 'ham'], dtype=object)
>>> # don't eat spoiled food
>>> eat = ma.masked_object(food, 'green_eggs')
>>> eat
masked_array(data=[--, 'ham'],
             mask=[ True, False],
       fill_value='green_eggs',
            dtype=object)
>>> # plain ol` ham is boring
>>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
>>> eat = ma.masked_object(fresh_food, 'green_eggs')
>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)

Note that `mask` is set to ``nomask`` if possible.

>>> eat
masked_array(data=['cheese', 'ham', 'pineapple'],
             mask=False,
       fill_value='green_eggs',
            dtype=object)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a2efd6920394b3b5ca0db83e4d09f6160}\label{namespacenumpy_1_1ma_1_1core_a2efd6920394b3b5ca0db83e4d09f6160} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_outside@{masked\_outside}}
\index{masked\_outside@{masked\_outside}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_outside()}{masked\_outside()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+outside (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{v1,  }\item[{}]{v2,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask an array outside a given interval.

Shortcut to ``masked_where``, where `condition` is True for `x` outside
the interval [v1,v2] (x < v1)|(x > v2).
The boundaries `v1` and `v2` can be given in either order.

See Also
--------
masked_where : Mask where a condition is met.

Notes
-----
The array `x` is prefilled with its filling value.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
>>> ma.masked_outside(x, -0.3, 0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)

The order of `v1` and `v2` doesn't matter.

>>> ma.masked_outside(x, 0.3, -0.3)
masked_array(data=[--, --, 0.01, 0.2, --, --],
             mask=[ True,  True, False, False,  True,  True],
       fill_value=1e+20)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a937c0a505425aea93f5931565f1db053}\label{namespacenumpy_1_1ma_1_1core_a937c0a505425aea93f5931565f1db053} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_values@{masked\_values}}
\index{masked\_values@{masked\_values}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_values()}{masked\_values()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+values (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{value,  }\item[{}]{rtol = {\ttfamily 1e-\/5},  }\item[{}]{atol = {\ttfamily 1e-\/8},  }\item[{}]{copy = {\ttfamily True},  }\item[{}]{shrink = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask using floating point equality.

Return a MaskedArray, masked where the data in array `x` are approximately
equal to `value`, determined using `isclose`. The default tolerances for
`masked_values` are the same as those for `isclose`.

For integer types, exact equality is used, in the same way as
`masked_equal`.

The fill_value is set to `value` and the mask is set to ``nomask`` if
possible.

Parameters
----------
x : array_like
    Array to mask.
value : float
    Masking value.
rtol, atol : float, optional
    Tolerance parameters passed on to `isclose`
copy : bool, optional
    Whether to return a copy of `x`.
shrink : bool, optional
    Whether to collapse a mask full of False to ``nomask``.

Returns
-------
result : MaskedArray
    The result of masking `x` where approximately equal to `value`.

See Also
--------
masked_where : Mask where a condition is met.
masked_equal : Mask where equal to a given value (integers).

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = np.array([1, 1.1, 2, 1.1, 3])
>>> ma.masked_values(x, 1.1)
masked_array(data=[1.0, --, 2.0, --, 3.0],
             mask=[False,  True, False,  True, False],
       fill_value=1.1)

Note that `mask` is set to ``nomask`` if possible.

>>> ma.masked_values(x, 2.1)
masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],
             mask=False,
       fill_value=2.1)

Unlike `masked_equal`, `masked_values` can perform approximate equalities.

>>> ma.masked_values(x, 2.1, atol=1e-1)
masked_array(data=[1.0, 1.1, --, 1.1, 3.0],
             mask=[False, False,  True, False, False],
       fill_value=2.1)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4ccd4eab4a2c1bce757e4bec345e124c}\label{namespacenumpy_1_1ma_1_1core_a4ccd4eab4a2c1bce757e4bec345e124c} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_where@{masked\_where}}
\index{masked\_where@{masked\_where}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_where()}{masked\_where()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+where (\begin{DoxyParamCaption}\item[{}]{condition,  }\item[{}]{a,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}



Masking functions \#. 

\begin{DoxyVerb}Mask an array where a condition is met.

Return `a` as an array masked where `condition` is True.
Any masked values of `a` or `condition` are also masked in the output.

Parameters
----------
condition : array_like
    Masking condition.  When `condition` tests floating point values for
    equality, consider using ``masked_values`` instead.
a : array_like
    Array to mask.
copy : bool
    If True (default) make a copy of `a` in the result.  If False modify
    `a` in place and return a view.

Returns
-------
result : MaskedArray
    The result of masking `a` where `condition` is True.

See Also
--------
masked_values : Mask using floating point equality.
masked_equal : Mask where equal to a given value.
masked_not_equal : Mask where *not* equal to a given value.
masked_less_equal : Mask where less than or equal to a given value.
masked_greater_equal : Mask where greater than or equal to a given value.
masked_less : Mask where less than a given value.
masked_greater : Mask where greater than a given value.
masked_inside : Mask inside a given interval.
masked_outside : Mask outside a given interval.
masked_invalid : Mask invalid values (NaNs or infs).

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> ma.masked_where(a <= 2, a)
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)

Mask array `b` conditional on `a`.

>>> b = ['a', 'b', 'c', 'd']
>>> ma.masked_where(a == 2, b)
masked_array(data=['a', 'b', --, 'd'],
             mask=[False, False,  True, False],
       fill_value='N/A',
            dtype='<U1')

Effect of the `copy` argument.

>>> c = ma.masked_where(a <= 2, a)
>>> c
masked_array(data=[--, --, --, 3],
             mask=[ True,  True,  True, False],
       fill_value=999999)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([0, 1, 2, 3])
>>> c = ma.masked_where(a <= 2, a, copy=False)
>>> c[0] = 99
>>> c
masked_array(data=[99, --, --, 3],
             mask=[False,  True,  True, False],
       fill_value=999999)
>>> a
array([99,  1,  2,  3])

When `condition` or `a` contain masked values.

>>> a = np.arange(4)
>>> a = ma.masked_where(a == 2, a)
>>> a
masked_array(data=[0, 1, --, 3],
             mask=[False, False,  True, False],
       fill_value=999999)
>>> b = np.arange(4)
>>> b = ma.masked_where(b == 0, b)
>>> b
masked_array(data=[--, 1, 2, 3],
             mask=[ True, False, False, False],
       fill_value=999999)
>>> ma.masked_where(a == 3, b)
masked_array(data=[--, 1, --, --],
             mask=[ True, False,  True,  True],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a6f0ad1868d46bb532dbe832435aa5b2f}\label{namespacenumpy_1_1ma_1_1core_a6f0ad1868d46bb532dbe832435aa5b2f} 
\index{numpy.ma.core@{numpy.ma.core}!max@{max}}
\index{max@{max}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{max()}{max()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+max (\begin{DoxyParamCaption}\item[{}]{obj,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{}]{fill\+\_\+value = {\ttfamily None},  }\item[{}]{keepdims = {\ttfamily np.\+\_\+NoValue} }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a09e1df3c10c1071ab491b82adc781cce}\label{namespacenumpy_1_1ma_1_1core_a09e1df3c10c1071ab491b82adc781cce} 
\index{numpy.ma.core@{numpy.ma.core}!maximum\_fill\_value@{maximum\_fill\_value}}
\index{maximum\_fill\_value@{maximum\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{maximum\_fill\_value()}{maximum\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+maximum\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the minimum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the maximum of an array with a given dtype.

Parameters
----------
obj : ndarray, dtype or scalar
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The minimum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
minimum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.maximum_fill_value(a)
-128
>>> a = np.int32()
>>> ma.maximum_fill_value(a)
-2147483648

An array of numeric data can also be passed.

>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.maximum_fill_value(a)
-128
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.maximum_fill_value(a)
-inf\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ad91233be8c9d9f06637174005076d095}\label{namespacenumpy_1_1ma_1_1core_ad91233be8c9d9f06637174005076d095} 
\index{numpy.ma.core@{numpy.ma.core}!min@{min}}
\index{min@{min}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{min()}{min()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+min (\begin{DoxyParamCaption}\item[{}]{obj,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{}]{fill\+\_\+value = {\ttfamily None},  }\item[{}]{keepdims = {\ttfamily np.\+\_\+NoValue} }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a1d560799762530922722ed03e325bf75}\label{namespacenumpy_1_1ma_1_1core_a1d560799762530922722ed03e325bf75} 
\index{numpy.ma.core@{numpy.ma.core}!minimum\_fill\_value@{minimum\_fill\_value}}
\index{minimum\_fill\_value@{minimum\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{minimum\_fill\_value()}{minimum\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+minimum\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the maximum value that can be represented by the dtype of an object.

This function is useful for calculating a fill value suitable for
taking the minimum of an array with a given dtype.

Parameters
----------
obj : ndarray, dtype or scalar
    An object that can be queried for it's numeric type.

Returns
-------
val : scalar
    The maximum representable value.

Raises
------
TypeError
    If `obj` isn't a suitable numeric type.

See Also
--------
maximum_fill_value : The inverse function.
set_fill_value : Set the filling value of a masked array.
MaskedArray.fill_value : Return current fill value.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.int8()
>>> ma.minimum_fill_value(a)
127
>>> a = np.int32()
>>> ma.minimum_fill_value(a)
2147483647

An array of numeric data can also be passed.

>>> a = np.array([1, 2, 3], dtype=np.int8)
>>> ma.minimum_fill_value(a)
127
>>> a = np.array([1, 2, 3], dtype=np.float32)
>>> ma.minimum_fill_value(a)
inf\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a747a1d813cd4f02f0d7a160ad3db54c6}\label{namespacenumpy_1_1ma_1_1core_a747a1d813cd4f02f0d7a160ad3db54c6} 
\index{numpy.ma.core@{numpy.ma.core}!ndim@{ndim}}
\index{ndim@{ndim}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ndim()}{ndim()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ndim (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}maskedarray version of the numpy function.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_af2f6d2c8970c6ad528639810df1d9e6c}\label{namespacenumpy_1_1ma_1_1core_af2f6d2c8970c6ad528639810df1d9e6c} 
\index{numpy.ma.core@{numpy.ma.core}!outer@{outer}}
\index{outer@{outer}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{outer()}{outer()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+outer (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a4eb881434d6debf955d0acc5f0ab9dca}\label{namespacenumpy_1_1ma_1_1core_a4eb881434d6debf955d0acc5f0ab9dca} 
\index{numpy.ma.core@{numpy.ma.core}!power@{power}}
\index{power@{power}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{power()}{power()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+power (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{third = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns element-wise base array raised to power from second array.

This is the masked array version of `numpy.power`. For details see
`numpy.power`.

See Also
--------
numpy.power

Notes
-----
The *out* argument to `numpy.power` is not supported, `third` has to be
None.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)
>>> ma.power(masked_x, 2)
masked_array(data=[125.43999999999998, 15.784728999999999,
               0.6416010000000001, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)
>>> y = [-0.5, 2, 0, 17]
>>> masked_y = ma.masked_array(y, mask)
>>> masked_y
masked_array(data=[-0.5, 2.0, 0.0, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)
>>> ma.power(masked_x, masked_y)
masked_array(data=[0.2988071523335984, 15.784728999999999, 1.0, --],
         mask=[False, False, False,  True],
   fill_value=1e+20)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_acbfc9290966b2a34f909ec4d772500bb}\label{namespacenumpy_1_1ma_1_1core_acbfc9290966b2a34f909ec4d772500bb} 
\index{numpy.ma.core@{numpy.ma.core}!ptp@{ptp}}
\index{ptp@{ptp}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ptp()}{ptp()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ptp (\begin{DoxyParamCaption}\item[{}]{obj,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{}]{fill\+\_\+value = {\ttfamily None},  }\item[{}]{keepdims = {\ttfamily np.\+\_\+NoValue} }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a82ed417314a668683badd0478d7ea35b}\label{namespacenumpy_1_1ma_1_1core_a82ed417314a668683badd0478d7ea35b} 
\index{numpy.ma.core@{numpy.ma.core}!put@{put}}
\index{put@{put}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{put()}{put()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+put (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{indices,  }\item[{}]{values,  }\item[{}]{mode = {\ttfamily \textquotesingle{}raise\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set storage-indexed locations to corresponding values.

This function is equivalent to `MaskedArray.put`, see that method
for details.

See Also
--------
MaskedArray.put

Examples
--------
Putting values in a masked array:

>>> a = np.ma.array([1, 2, 3, 4], mask=[False, True, False, False])
>>> np.ma.put(a, [1, 3], [10, 30])
>>> a
masked_array(data=[ 1, 10,  3, 30],
             mask=False,
       fill_value=999999)

Using put with a 2D array:

>>> b = np.ma.array([[1, 2], [3, 4]], mask=[[False, True], [False, False]])
>>> np.ma.put(b, [[0, 1], [1, 0]], [[10, 20], [30, 40]])
>>> b
masked_array(
  data=[[40, 30],
        [ 3,  4]],
  mask=False,
  fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a06f416f62cb106290855d2eab7ddbb1e}\label{namespacenumpy_1_1ma_1_1core_a06f416f62cb106290855d2eab7ddbb1e} 
\index{numpy.ma.core@{numpy.ma.core}!putmask@{putmask}}
\index{putmask@{putmask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{putmask()}{putmask()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+putmask (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{mask,  }\item[{}]{values }\end{DoxyParamCaption})}

\begin{DoxyVerb}Changes elements of an array based on conditional and input values.

This is the masked array version of `numpy.putmask`, for details see
`numpy.putmask`.

See Also
--------
numpy.putmask

Notes
-----
Using a masked array as `values` will **not** transform a `ndarray` into
a `MaskedArray`.

Examples
--------
>>> import numpy as np
>>> arr = [[1, 2], [3, 4]]
>>> mask = [[1, 0], [0, 0]]
>>> x = np.ma.array(arr, mask=mask)
>>> np.ma.putmask(x, x < 4, 10*x)
>>> x
masked_array(
  data=[[--, 20],
        [30, 4]],
  mask=[[ True, False],
        [False, False]],
  fill_value=999999)
>>> x.data
array([[10, 20],
       [30,  4]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a94145a691745d920c49da604cf501e27}\label{namespacenumpy_1_1ma_1_1core_a94145a691745d920c49da604cf501e27} 
\index{numpy.ma.core@{numpy.ma.core}!reshape@{reshape}}
\index{reshape@{reshape}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{reshape()}{reshape()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+reshape (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{new\+\_\+shape,  }\item[{}]{order = {\ttfamily \textquotesingle{}C\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns an array containing the same data with a new shape.

Refer to `MaskedArray.reshape` for full documentation.

See Also
--------
MaskedArray.reshape : equivalent function

Examples
--------
Reshaping a 1-D array:

>>> a = np.ma.array([1, 2, 3, 4])
>>> np.ma.reshape(a, (2, 2))
masked_array(
  data=[[1, 2],
        [3, 4]],
  mask=False,
  fill_value=999999)

Reshaping a 2-D array:

>>> b = np.ma.array([[1, 2], [3, 4]])
>>> np.ma.reshape(b, (1, 4))
masked_array(data=[[1, 2, 3, 4]],
             mask=False,
       fill_value=999999)

Reshaping a 1-D array with a mask:

>>> c = np.ma.array([1, 2, 3, 4], mask=[False, True, False, False])
>>> np.ma.reshape(c, (2, 2))
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a4860bbf1250c53668c51db869e9bcbdd}\label{namespacenumpy_1_1ma_1_1core_a4860bbf1250c53668c51db869e9bcbdd} 
\index{numpy.ma.core@{numpy.ma.core}!resize@{resize}}
\index{resize@{resize}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+resize (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{new\+\_\+shape }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new masked array with the specified size and shape.

This is the masked equivalent of the `numpy.resize` function. The new
array is filled with repeated copies of `x` (in the order that the
data are stored in memory). If `x` is masked, the new array will be
masked, and the new mask will be a repetition of the old one.

See Also
--------
numpy.resize : Equivalent function in the top level NumPy module.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = ma.array([[1, 2] ,[3, 4]])
>>> a[0, 1] = ma.masked
>>> a
masked_array(
  data=[[1, --],
        [3, 4]],
  mask=[[False,  True],
        [False, False]],
  fill_value=999999)
>>> np.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, --, 3],
        [4, 1, --],
        [3, 4, 1]],
  mask=[[False,  True, False],
        [False, False,  True],
        [False, False, False]],
  fill_value=999999)

A MaskedArray is always returned, regardless of the input type.

>>> a = np.array([[1, 2] ,[3, 4]])
>>> ma.resize(a, (3, 3))
masked_array(
  data=[[1, 2, 3],
        [4, 1, 2],
        [3, 4, 1]],
  mask=False,
  fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a63451a2bb0d513878157e1a7e04ec986}\label{namespacenumpy_1_1ma_1_1core_a63451a2bb0d513878157e1a7e04ec986} 
\index{numpy.ma.core@{numpy.ma.core}!right\_shift@{right\_shift}}
\index{right\_shift@{right\_shift}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{right\_shift()}{right\_shift()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+right\+\_\+shift (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{n }\end{DoxyParamCaption})}

\begin{DoxyVerb}Shift the bits of an integer to the right.

This is the masked array version of `numpy.right_shift`, for details
see that function.

See Also
--------
numpy.right_shift

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11, 3, 8, 1]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11, 3, 8, --],
             mask=[False, False, False,  True],
       fill_value=999999)
>>> ma.right_shift(masked_x,1)
masked_array(data=[5, 1, 4, --],
             mask=[False, False, False,  True],
       fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ab65dc83aa506b08f16d69e23a24c7765}\label{namespacenumpy_1_1ma_1_1core_ab65dc83aa506b08f16d69e23a24c7765} 
\index{numpy.ma.core@{numpy.ma.core}!round\_@{round\_}}
\index{round\_@{round\_}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{round\_()}{round\_()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+round\+\_\+ (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{decimals = {\ttfamily 0},  }\item[{}]{out = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a copy of a, rounded to 'decimals' places.

When 'decimals' is negative, it specifies the number of positions
to the left of the decimal point.  The real and imaginary parts of
complex numbers are rounded separately. Nothing is done if the
array is not of float type and 'decimals' is greater than or equal
to 0.

Parameters
----------
decimals : int
    Number of decimals to round to. May be negative.
out : array_like
    Existing array to use for output.
    If not given, returns a default copy of a.

Notes
-----
If out is given and does not have a mask attribute, the mask of a
is lost!

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round_(masked_x)
masked_array(data=[11.0, -4.0, 1.0, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round(masked_x, decimals=1)
masked_array(data=[11.2, -4.0, 0.8, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
>>> ma.round_(masked_x, decimals=-1)
masked_array(data=[10.0, -0.0, 0.0, --],
             mask=[False, False, False, True],
    fill_value=1e+20)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a025416440c17c2e87de81627cbdae280}\label{namespacenumpy_1_1ma_1_1core_a025416440c17c2e87de81627cbdae280} 
\index{numpy.ma.core@{numpy.ma.core}!set\_fill\_value@{set\_fill\_value}}
\index{set\_fill\_value@{set\_fill\_value}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{set\_fill\_value()}{set\_fill\_value()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+set\+\_\+fill\+\_\+value (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{fill\+\_\+value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the filling value of a, if a is a masked array.

This function changes the fill value of the masked array `a` in place.
If `a` is not a masked array, the function returns silently, without
doing anything.

Parameters
----------
a : array_like
    Input array.
fill_value : dtype
    Filling value. A consistency test is performed to make sure
    the value is compatible with the dtype of `a`.

Returns
-------
None
    Nothing returned by this function.

See Also
--------
maximum_fill_value : Return the default fill value for a dtype.
MaskedArray.fill_value : Return current fill value.
MaskedArray.set_fill_value : Equivalent method.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a = ma.masked_where(a < 3, a)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=999999)
>>> ma.set_fill_value(a, -999)
>>> a
masked_array(data=[--, --, --, 3, 4],
             mask=[ True,  True,  True, False, False],
       fill_value=-999)

Nothing happens if `a` is not a masked array.

>>> a = list(range(5))
>>> a
[0, 1, 2, 3, 4]
>>> ma.set_fill_value(a, 100)
>>> a
[0, 1, 2, 3, 4]
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> ma.set_fill_value(a, 100)
>>> a
array([0, 1, 2, 3, 4])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_a63d4f6a70c6dd38ef30778526006bd8d}\label{namespacenumpy_1_1ma_1_1core_a63d4f6a70c6dd38ef30778526006bd8d} 
\index{numpy.ma.core@{numpy.ma.core}!shape@{shape}}
\index{shape@{shape}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{shape()}{shape()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+shape (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a382020a304ed520a0853d3603a609478}\label{namespacenumpy_1_1ma_1_1core_a382020a304ed520a0853d3603a609478} 
\index{numpy.ma.core@{numpy.ma.core}!size@{size}}
\index{size@{size}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+size (\begin{DoxyParamCaption}\item[{}]{obj,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ae116f01504dfade82c7ce9ab4e096c07}\label{namespacenumpy_1_1ma_1_1core_ae116f01504dfade82c7ce9ab4e096c07} 
\index{numpy.ma.core@{numpy.ma.core}!sort@{sort}}
\index{sort@{sort}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+sort (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily -\/1},  }\item[{}]{kind = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{endwith = {\ttfamily True},  }\item[{}]{fill\+\_\+value = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{stable = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a sorted copy of the masked array.

Equivalent to creating a copy of the array
and applying the  MaskedArray ``sort()`` method.

Refer to ``MaskedArray.sort`` for the full documentation

See Also
--------
MaskedArray.sort : equivalent method

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = [11.2, -3.973, 0.801, -1.41]
>>> mask = [0, 0, 0, 1]
>>> masked_x = ma.masked_array(x, mask)
>>> masked_x
masked_array(data=[11.2, -3.973, 0.801, --],
             mask=[False, False, False,  True],
       fill_value=1e+20)
>>> ma.sort(masked_x)
masked_array(data=[-3.973, 0.801, 11.2, --],
             mask=[False, False, False,  True],
       fill_value=1e+20)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_afdb2f3a1791f064380994eb871fd2447}\label{namespacenumpy_1_1ma_1_1core_afdb2f3a1791f064380994eb871fd2447} 
\index{numpy.ma.core@{numpy.ma.core}!take@{take}}
\index{take@{take}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{take()}{take()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+take (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{indices,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{}]{mode = {\ttfamily \textquotesingle{}raise\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_af18bd0eecdb65207fb8ee124353a602b}\label{namespacenumpy_1_1ma_1_1core_af18bd0eecdb65207fb8ee124353a602b} 
\index{numpy.ma.core@{numpy.ma.core}!transpose@{transpose}}
\index{transpose@{transpose}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{transpose()}{transpose()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+transpose (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axes = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Permute the dimensions of an array.

This function is exactly equivalent to `numpy.transpose`.

See Also
--------
numpy.transpose : Equivalent function in top-level NumPy module.

Examples
--------
>>> import numpy as np
>>> import numpy.ma as ma
>>> x = ma.arange(4).reshape((2,2))
>>> x[1, 1] = ma.masked
>>> x
masked_array(
  data=[[0, 1],
        [2, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)

>>> ma.transpose(x)
masked_array(
  data=[[0, 2],
        [1, --]],
  mask=[[False, False],
        [False,  True]],
  fill_value=999999)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1core_ae03373b142277fe573d18d4719a063d9}\label{namespacenumpy_1_1ma_1_1core_ae03373b142277fe573d18d4719a063d9} 
\index{numpy.ma.core@{numpy.ma.core}!where@{where}}
\index{where@{where}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{where()}{where()}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+where (\begin{DoxyParamCaption}\item[{}]{condition,  }\item[{}]{x = {\ttfamily \+\_\+NoValue},  }\item[{}]{y = {\ttfamily \+\_\+NoValue} }\end{DoxyParamCaption})}



Extra functions \#. 

\begin{DoxyVerb}Return a masked array with elements from `x` or `y`, depending on condition.

.. note::
    When only `condition` is provided, this function is identical to
    `nonzero`. The rest of this documentation covers only the case where
    all three arguments are provided.

Parameters
----------
condition : array_like, bool
    Where True, yield `x`, otherwise yield `y`.
x, y : array_like, optional
    Values from which to choose. `x`, `y` and `condition` need to be
    broadcastable to some shape.

Returns
-------
out : MaskedArray
    An masked array with `masked` elements where the condition is masked,
    elements from `x` where `condition` is True, and elements from `y`
    elsewhere.

See Also
--------
numpy.where : Equivalent function in the top-level NumPy module.
nonzero : The function that is called when x and y are omitted

Examples
--------
>>> import numpy as np
>>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
...                                                    [1, 0, 1],
...                                                    [0, 1, 0]])
>>> x
masked_array(
  data=[[0.0, --, 2.0],
        [--, 4.0, --],
        [6.0, --, 8.0]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=1e+20)
>>> np.ma.where(x > 5, x, -3.1416)
masked_array(
  data=[[-3.1416, --, -3.1416],
        [--, -3.1416, --],
        [6.0, --, 8.0]],
  mask=[[False,  True, False],
        [ True, False,  True],
        [False,  True, False]],
  fill_value=1e+20)\end{DoxyVerb}
 

\doxysubsection{Documentation des variables}
\Hypertarget{namespacenumpy_1_1ma_1_1core_af584319c358a9b0c16d1ff59873d46fa}\label{namespacenumpy_1_1ma_1_1core_af584319c358a9b0c16d1ff59873d46fa} 
\index{numpy.ma.core@{numpy.ma.core}!\_legacy\_print\_templates@{\_legacy\_print\_templates}}
\index{\_legacy\_print\_templates@{\_legacy\_print\_templates}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_legacy\_print\_templates}{\_legacy\_print\_templates}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+\_\+legacy\+\_\+print\+\_\+templates\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ dict(}
\DoxyCodeLine{00002\ \ \ \ \ long\_std=textwrap.dedent(),}
\DoxyCodeLine{00003\ \ \ \ \ long\_flx=textwrap.dedent(),}
\DoxyCodeLine{00004\ \ \ \ \ short\_std=textwrap.dedent(),}
\DoxyCodeLine{00005\ \ \ \ \ short\_flx=textwrap.dedent()}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a52e0aa8235d8e8866c4f93132ea361a5}\label{namespacenumpy_1_1ma_1_1core_a52e0aa8235d8e8866c4f93132ea361a5} 
\index{numpy.ma.core@{numpy.ma.core}!\_maxvals@{\_maxvals}}
\index{\_maxvals@{\_maxvals}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_maxvals}{\_maxvals}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+\_\+maxvals = \{\}\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_aa870f600996814468ff2c6c5e373d84a}\label{namespacenumpy_1_1ma_1_1core_aa870f600996814468ff2c6c5e373d84a} 
\index{numpy.ma.core@{numpy.ma.core}!\_minvals@{\_minvals}}
\index{\_minvals@{\_minvals}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{\_minvals}{\_minvals}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+\_\+minvals = \{\}\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a5526d131af851bed792d8a7885f164cb}\label{namespacenumpy_1_1ma_1_1core_a5526d131af851bed792d8a7885f164cb} 
\index{numpy.ma.core@{numpy.ma.core}!abs@{abs}}
\index{abs@{abs}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{abs}{abs}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+abs = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+absolute)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_aecc95edb3fa065575d468d2d8f3eab9f}\label{namespacenumpy_1_1ma_1_1core_aecc95edb3fa065575d468d2d8f3eab9f} 
\index{numpy.ma.core@{numpy.ma.core}!add@{add}}
\index{add@{add}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{add}{add}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+add = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+add)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a45b43786ae893dd0a3a7e113ccb00ee9}\label{namespacenumpy_1_1ma_1_1core_a45b43786ae893dd0a3a7e113ccb00ee9} 
\index{numpy.ma.core@{numpy.ma.core}!all@{all}}
\index{all@{all}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{all}{all}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+all = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}all\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a585600a338f60b69602822fb04e1432e}\label{namespacenumpy_1_1ma_1_1core_a585600a338f60b69602822fb04e1432e} 
\index{numpy.ma.core@{numpy.ma.core}!alltrue@{alltrue}}
\index{alltrue@{alltrue}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{alltrue}{alltrue}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+alltrue = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+and, 1, 1).\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a47e9cb4bc6277b24b219f6794480c811}{reduce}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a232b83f8caa3318472917df9a42eda3a}\label{namespacenumpy_1_1ma_1_1core_a232b83f8caa3318472917df9a42eda3a} 
\index{numpy.ma.core@{numpy.ma.core}!angle@{angle}}
\index{angle@{angle}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{angle}{angle}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+angle = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(angle)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ae502a3b30272ef3afe2f3514f5ff2805}\label{namespacenumpy_1_1ma_1_1core_ae502a3b30272ef3afe2f3514f5ff2805} 
\index{numpy.ma.core@{numpy.ma.core}!anomalies@{anomalies}}
\index{anomalies@{anomalies}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{anomalies}{anomalies}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+anomalies = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}anom\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_afa19956e2746e9587488c89a7a7bb5eb}\label{namespacenumpy_1_1ma_1_1core_afa19956e2746e9587488c89a7a7bb5eb} 
\index{numpy.ma.core@{numpy.ma.core}!any@{any}}
\index{any@{any}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{any}{any}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+any = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}any\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a890b773f294d111805d66e989f43d59c}\label{namespacenumpy_1_1ma_1_1core_a890b773f294d111805d66e989f43d59c} 
\index{numpy.ma.core@{numpy.ma.core}!arange@{arange}}
\index{arange@{arange}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arange}{arange}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arange}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'arange'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'arange\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'arange\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a485e28a53428db6f3a42d6a762b40a11}\label{namespacenumpy_1_1ma_1_1core_a485e28a53428db6f3a42d6a762b40a11} 
\index{numpy.ma.core@{numpy.ma.core}!arccos@{arccos}}
\index{arccos@{arccos}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arccos}{arccos}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arccos}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.arccos,\ 0.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainCheckInterval(-\/1.0,\ 1.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a90a03d5744cdf4988583f0e2f3ec60e4}\label{namespacenumpy_1_1ma_1_1core_a90a03d5744cdf4988583f0e2f3ec60e4} 
\index{numpy.ma.core@{numpy.ma.core}!arccosh@{arccosh}}
\index{arccosh@{arccosh}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arccosh}{arccosh}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arccosh}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.arccosh,\ 1.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainGreaterEqual(1.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a13af3437e857b31052d3da00fe9bdfb6}\label{namespacenumpy_1_1ma_1_1core_a13af3437e857b31052d3da00fe9bdfb6} 
\index{numpy.ma.core@{numpy.ma.core}!arcsin@{arcsin}}
\index{arcsin@{arcsin}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arcsin}{arcsin}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arcsin}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.arcsin,\ 0.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainCheckInterval(-\/1.0,\ 1.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a94826c0e4e388f94cedaa323379a5b4e}\label{namespacenumpy_1_1ma_1_1core_a94826c0e4e388f94cedaa323379a5b4e} 
\index{numpy.ma.core@{numpy.ma.core}!arcsinh@{arcsinh}}
\index{arcsinh@{arcsinh}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arcsinh}{arcsinh}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arcsinh = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+arcsinh)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_afccd755361a7cca556f2ed2e09407c24}\label{namespacenumpy_1_1ma_1_1core_afccd755361a7cca556f2ed2e09407c24} 
\index{numpy.ma.core@{numpy.ma.core}!arctan@{arctan}}
\index{arctan@{arctan}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arctan}{arctan}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arctan = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+arctan)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a8811be62d89efd0e21008f1e510c2293}\label{namespacenumpy_1_1ma_1_1core_a8811be62d89efd0e21008f1e510c2293} 
\index{numpy.ma.core@{numpy.ma.core}!arctan2@{arctan2}}
\index{arctan2@{arctan2}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arctan2}{arctan2}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arctan2 = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+arctan2, 0.\+0, 1.\+0)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ab83170ddb7014759bfe64ec1fde05554}\label{namespacenumpy_1_1ma_1_1core_ab83170ddb7014759bfe64ec1fde05554} 
\index{numpy.ma.core@{numpy.ma.core}!arctanh@{arctanh}}
\index{arctanh@{arctanh}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{arctanh}{arctanh}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+arctanh}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.arctanh,\ 0.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainCheckInterval(-\/1.0\ +\ 1e-\/15,\ 1.0\ -\/\ 1e-\/15))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a8bff7b7b01e335828e68e522e950cfaf}\label{namespacenumpy_1_1ma_1_1core_a8bff7b7b01e335828e68e522e950cfaf} 
\index{numpy.ma.core@{numpy.ma.core}!argmax@{argmax}}
\index{argmax@{argmax}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{argmax}{argmax}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+argmax = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}argmax\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a1842cdbdf9607539230cc097195df3e8}\label{namespacenumpy_1_1ma_1_1core_a1842cdbdf9607539230cc097195df3e8} 
\index{numpy.ma.core@{numpy.ma.core}!argmin@{argmin}}
\index{argmin@{argmin}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{argmin}{argmin}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+argmin = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}argmin\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a8783a7d1996d8c33a17bdc31e2754a6c}\label{namespacenumpy_1_1ma_1_1core_a8783a7d1996d8c33a17bdc31e2754a6c} 
\index{numpy.ma.core@{numpy.ma.core}!around@{around}}
\index{around@{around}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{around}{around}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+around = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(np.\+around)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_af3458ab5027fb34dff52c63a6d40936d}\label{namespacenumpy_1_1ma_1_1core_af3458ab5027fb34dff52c63a6d40936d} 
\index{numpy.ma.core@{numpy.ma.core}!bitwise\_and@{bitwise\_and}}
\index{bitwise\_and@{bitwise\_and}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{bitwise\_and}{bitwise\_and}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+bitwise\+\_\+and = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+bitwise\+\_\+and)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a03a17b72b4c278c3ab5e9d9ff421c51a}\label{namespacenumpy_1_1ma_1_1core_a03a17b72b4c278c3ab5e9d9ff421c51a} 
\index{numpy.ma.core@{numpy.ma.core}!bitwise\_or@{bitwise\_or}}
\index{bitwise\_or@{bitwise\_or}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{bitwise\_or}{bitwise\_or}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+bitwise\+\_\+or = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+bitwise\+\_\+or)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a460d7c8700cd51ed007f9570aaa22dc2}\label{namespacenumpy_1_1ma_1_1core_a460d7c8700cd51ed007f9570aaa22dc2} 
\index{numpy.ma.core@{numpy.ma.core}!bitwise\_xor@{bitwise\_xor}}
\index{bitwise\_xor@{bitwise\_xor}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{bitwise\_xor}{bitwise\_xor}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+bitwise\+\_\+xor = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+bitwise\+\_\+xor)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a694b148708c4de2aaf00c26ffe1dc473}\label{namespacenumpy_1_1ma_1_1core_a694b148708c4de2aaf00c26ffe1dc473} 
\index{numpy.ma.core@{numpy.ma.core}!ceil@{ceil}}
\index{ceil@{ceil}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ceil}{ceil}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ceil = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+ceil)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a6a32b49c7bed820a336049f0be631d33}\label{namespacenumpy_1_1ma_1_1core_a6a32b49c7bed820a336049f0be631d33} 
\index{numpy.ma.core@{numpy.ma.core}!clip@{clip}}
\index{clip@{clip}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{clip}{clip}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+clip}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'clip'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'clipped\_array\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'clipped\_array\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a7308818dc67dd4eedf1abd3b0f98bb7d}\label{namespacenumpy_1_1ma_1_1core_a7308818dc67dd4eedf1abd3b0f98bb7d} 
\index{numpy.ma.core@{numpy.ma.core}!compress@{compress}}
\index{compress@{compress}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{compress}{compress}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+compress = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}compress\textquotesingle{}, reversed=True)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a9e3086fcb820a1aab1c950f12f42f08d}\label{namespacenumpy_1_1ma_1_1core_a9e3086fcb820a1aab1c950f12f42f08d} 
\index{numpy.ma.core@{numpy.ma.core}!conjugate@{conjugate}}
\index{conjugate@{conjugate}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{conjugate}{conjugate}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+conjugate = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+conjugate)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d}\label{namespacenumpy_1_1ma_1_1core_a9eadff0419a718d13488bd60175f825d} 
\index{numpy.ma.core@{numpy.ma.core}!copy@{copy}}
\index{copy@{copy}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{copy}{copy}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+copy = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}copy\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a62ff030940780df90c92ab873cb2338e}\label{namespacenumpy_1_1ma_1_1core_a62ff030940780df90c92ab873cb2338e} 
\index{numpy.ma.core@{numpy.ma.core}!cos@{cos}}
\index{cos@{cos}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{cos}{cos}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+cos = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+cos)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ac4d18040290f60f23634da777ae79abd}\label{namespacenumpy_1_1ma_1_1core_ac4d18040290f60f23634da777ae79abd} 
\index{numpy.ma.core@{numpy.ma.core}!cosh@{cosh}}
\index{cosh@{cosh}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{cosh}{cosh}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+cosh = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+cosh)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_affe86f6f5e44d61ddd92f35726b9e626}\label{namespacenumpy_1_1ma_1_1core_affe86f6f5e44d61ddd92f35726b9e626} 
\index{numpy.ma.core@{numpy.ma.core}!count@{count}}
\index{count@{count}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{count}{count}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+count = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}count\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a6ace0c3b2fcc8279b5ace7d6df57ae47}\label{namespacenumpy_1_1ma_1_1core_a6ace0c3b2fcc8279b5ace7d6df57ae47} 
\index{numpy.ma.core@{numpy.ma.core}!cumprod@{cumprod}}
\index{cumprod@{cumprod}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{cumprod}{cumprod}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+cumprod = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}cumprod\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a7c85a9bb14cd25cd30ac0e2b4e187fcc}\label{namespacenumpy_1_1ma_1_1core_a7c85a9bb14cd25cd30ac0e2b4e187fcc} 
\index{numpy.ma.core@{numpy.ma.core}!cumsum@{cumsum}}
\index{cumsum@{cumsum}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{cumsum}{cumsum}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+cumsum = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}cumsum\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a5f60b1b8ceec4a93750b6e6742ac2c3f}\label{namespacenumpy_1_1ma_1_1core_a5f60b1b8ceec4a93750b6e6742ac2c3f} 
\index{numpy.ma.core@{numpy.ma.core}!default\_filler@{default\_filler}}
\index{default\_filler@{default\_filler}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{default\_filler}{default\_filler}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+default\+\_\+filler}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'b'}:\ \textcolor{keyword}{True},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'c'}:\ 1.e20\ +\ 0.0j,}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'f'}:\ 1.e20,}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'i'}:\ 999999,}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'O'}:\ \textcolor{stringliteral}{'?'},}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'S'}:\ b\textcolor{stringliteral}{'N/A'},}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'u'}:\ 999999,}
\DoxyCodeLine{00008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'V'}:\ b\textcolor{stringliteral}{'???'},}
\DoxyCodeLine{00009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'U'}:\ \textcolor{stringliteral}{'N/A'}}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_acc4f0cf7239063df79ce982f246f59e2}\label{namespacenumpy_1_1ma_1_1core_acc4f0cf7239063df79ce982f246f59e2} 
\index{numpy.ma.core@{numpy.ma.core}!diagonal@{diagonal}}
\index{diagonal@{diagonal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{diagonal}{diagonal}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+diagonal = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}diagonal\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a29bf5b3bb49649e6c084120be48dc302}\label{namespacenumpy_1_1ma_1_1core_a29bf5b3bb49649e6c084120be48dc302} 
\index{numpy.ma.core@{numpy.ma.core}!divide@{divide}}
\index{divide@{divide}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{divide}{divide}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+divide = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}(umath.\+divide, \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}(), 0, 1)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a905d491ab2a9d4394e947fa11e963c34}\label{namespacenumpy_1_1ma_1_1core_a905d491ab2a9d4394e947fa11e963c34} 
\index{numpy.ma.core@{numpy.ma.core}!empty@{empty}}
\index{empty@{empty}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{empty}{empty}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+empty}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'empty'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_aca11985b88d3f8506c30ea9063dc58e8}\label{namespacenumpy_1_1ma_1_1core_aca11985b88d3f8506c30ea9063dc58e8} 
\index{numpy.ma.core@{numpy.ma.core}!empty\_like@{empty\_like}}
\index{empty\_like@{empty\_like}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{empty\_like}{empty\_like}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+empty\+\_\+like}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'empty\_like'},}
\DoxyCodeLine{00003\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00004\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00005\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a9120f89faa4eceb8a018859bed4526f7}\label{namespacenumpy_1_1ma_1_1core_a9120f89faa4eceb8a018859bed4526f7} 
\index{numpy.ma.core@{numpy.ma.core}!equal@{equal}}
\index{equal@{equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{equal}{equal}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+equal = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+equal)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a05913f2c71220208666e6b54d6b26a30}\label{namespacenumpy_1_1ma_1_1core_a05913f2c71220208666e6b54d6b26a30} 
\index{numpy.ma.core@{numpy.ma.core}!exp@{exp}}
\index{exp@{exp}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{exp}{exp}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+exp = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+exp)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_aefeeee05847dbaa7e6d14d3690ffd236}\label{namespacenumpy_1_1ma_1_1core_aefeeee05847dbaa7e6d14d3690ffd236} 
\index{numpy.ma.core@{numpy.ma.core}!fabs@{fabs}}
\index{fabs@{fabs}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{fabs}{fabs}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+fabs = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+fabs)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ad943fb8cd3ae928889bcb9bb46cbe50e}\label{namespacenumpy_1_1ma_1_1core_ad943fb8cd3ae928889bcb9bb46cbe50e} 
\index{numpy.ma.core@{numpy.ma.core}!float\_types\_list@{float\_types\_list}}
\index{float\_types\_list@{float\_types\_list}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{float\_types\_list}{float\_types\_list}}
{\footnotesize\ttfamily list numpy.\+ma.\+core.\+float\+\_\+types\+\_\+list}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [np.half,\ np.single,\ np.double,\ np.longdouble,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ np.csingle,\ np.cdouble,\ np.clongdouble]}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_aa95f1e6c62f4f6c457b4f9d470fe9bbe}\label{namespacenumpy_1_1ma_1_1core_aa95f1e6c62f4f6c457b4f9d470fe9bbe} 
\index{numpy.ma.core@{numpy.ma.core}!floor@{floor}}
\index{floor@{floor}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{floor}{floor}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+floor = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+floor)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_aab4ab1ae0c9d8f94ed7b688e8419ccfd}\label{namespacenumpy_1_1ma_1_1core_aab4ab1ae0c9d8f94ed7b688e8419ccfd} 
\index{numpy.ma.core@{numpy.ma.core}!floor\_divide@{floor\_divide}}
\index{floor\_divide@{floor\_divide}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{floor\_divide}{floor\_divide}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+floor\+\_\+divide}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_DomainedBinaryOperation(umath.floor\_divide,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainSafeDivide(),\ 0,\ 1)}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_aa399d2d1f4e648e9ce4930b1212b3498}\label{namespacenumpy_1_1ma_1_1core_aa399d2d1f4e648e9ce4930b1212b3498} 
\index{numpy.ma.core@{numpy.ma.core}!fmod@{fmod}}
\index{fmod@{fmod}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{fmod}{fmod}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+fmod = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}(umath.\+fmod, \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}(), 0, 1)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a1447273a76e349a77bc1d85596c83209}\label{namespacenumpy_1_1ma_1_1core_a1447273a76e349a77bc1d85596c83209} 
\index{numpy.ma.core@{numpy.ma.core}!frombuffer@{frombuffer}}
\index{frombuffer@{frombuffer}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{frombuffer}{frombuffer}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+frombuffer}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'frombuffer'},}
\DoxyCodeLine{00003\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00004\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out:\ MaskedArray'},}
\DoxyCodeLine{00005\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_adf0d2913ba7e564eff28cd7c243eec62}\label{namespacenumpy_1_1ma_1_1core_adf0d2913ba7e564eff28cd7c243eec62} 
\index{numpy.ma.core@{numpy.ma.core}!fromfunction@{fromfunction}}
\index{fromfunction@{fromfunction}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{fromfunction}{fromfunction}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+fromfunction}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \textcolor{stringliteral}{'fromfunction'},}
\DoxyCodeLine{00003\ \ \ \ np\_ret=\textcolor{stringliteral}{'fromfunction\ :\ any'},}
\DoxyCodeLine{00004\ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'fromfunction:\ MaskedArray'},}
\DoxyCodeLine{00005\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a0970cd0b8e0192e47258bafe5b940051}\label{namespacenumpy_1_1ma_1_1core_a0970cd0b8e0192e47258bafe5b940051} 
\index{numpy.ma.core@{numpy.ma.core}!get\_data@{get\_data}}
\index{get\_data@{get\_data}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{get\_data}{get\_data}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+get\+\_\+data = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a4c058cfe52befdaf7bc1beb8c06e3b0d}{getdata}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a089c465f38e219e618241a2bd6706a72}\label{namespacenumpy_1_1ma_1_1core_a089c465f38e219e618241a2bd6706a72} 
\index{numpy.ma.core@{numpy.ma.core}!get\_mask@{get\_mask}}
\index{get\_mask@{get\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{get\_mask}{get\_mask}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+get\+\_\+mask = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aee4137f8256ee554372b8e0629355971}{getmask}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_af46d1de5e4c57b6eb70f8c1130da875d}\label{namespacenumpy_1_1ma_1_1core_af46d1de5e4c57b6eb70f8c1130da875d} 
\index{numpy.ma.core@{numpy.ma.core}!greater@{greater}}
\index{greater@{greater}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{greater}{greater}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+greater = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+greater)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a17ae5bf50a52d8ee4720dddaa7779823}\label{namespacenumpy_1_1ma_1_1core_a17ae5bf50a52d8ee4720dddaa7779823} 
\index{numpy.ma.core@{numpy.ma.core}!greater\_equal@{greater\_equal}}
\index{greater\_equal@{greater\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{greater\_equal}{greater\_equal}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+greater\+\_\+equal = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+greater\+\_\+equal)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ac9aabccbd3643ebffc834e4d576e3e3b}\label{namespacenumpy_1_1ma_1_1core_ac9aabccbd3643ebffc834e4d576e3e3b} 
\index{numpy.ma.core@{numpy.ma.core}!harden\_mask@{harden\_mask}}
\index{harden\_mask@{harden\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{harden\_mask}{harden\_mask}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+harden\+\_\+mask = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}harden\+\_\+mask\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a835f29ad53957419c0ff51f0199ce412}\label{namespacenumpy_1_1ma_1_1core_a835f29ad53957419c0ff51f0199ce412} 
\index{numpy.ma.core@{numpy.ma.core}!hypot@{hypot}}
\index{hypot@{hypot}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{hypot}{hypot}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+hypot = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+hypot)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a27d92b83c7d72381405190793a1fbd10}\label{namespacenumpy_1_1ma_1_1core_a27d92b83c7d72381405190793a1fbd10} 
\index{numpy.ma.core@{numpy.ma.core}!identity@{identity}}
\index{identity@{identity}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{identity}{identity}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+identity}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'identity'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a90dd821d3c2af4142e801072150bb3f1}\label{namespacenumpy_1_1ma_1_1core_a90dd821d3c2af4142e801072150bb3f1} 
\index{numpy.ma.core@{numpy.ma.core}!ids@{ids}}
\index{ids@{ids}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ids}{ids}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ids = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}ids\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a1cba93d768a61f51e74e5c5f7e8233f7}\label{namespacenumpy_1_1ma_1_1core_a1cba93d768a61f51e74e5c5f7e8233f7} 
\index{numpy.ma.core@{numpy.ma.core}!indices@{indices}}
\index{indices@{indices}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{indices}{indices}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+indices}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'indices'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'grid\ :\ one\ ndarray\ or\ tuple\ of\ ndarrays'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'grid\ :\ one\ MaskedArray\ or\ tuple\ of\ MaskedArrays'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_af5b70aab8e0b4e834b26e3ee8b671deb}\label{namespacenumpy_1_1ma_1_1core_af5b70aab8e0b4e834b26e3ee8b671deb} 
\index{numpy.ma.core@{numpy.ma.core}!info@{info}}
\index{info@{info}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{info}{info}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+info = np.\+iinfo(np.\+int64)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a4065d4c56178ab45dc4c09a3341f4464}\label{namespacenumpy_1_1ma_1_1core_a4065d4c56178ab45dc4c09a3341f4464} 
\index{numpy.ma.core@{numpy.ma.core}!innerproduct@{innerproduct}}
\index{innerproduct@{innerproduct}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{innerproduct}{innerproduct}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+innerproduct = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a70b1e7c1e7cd6089d61329228470907e}{inner}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a350a49b5091ca75bba5576eca2a22404}\label{namespacenumpy_1_1ma_1_1core_a350a49b5091ca75bba5576eca2a22404} 
\index{numpy.ma.core@{numpy.ma.core}!isarray@{isarray}}
\index{isarray@{isarray}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{isarray}{isarray}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+isarray = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e}{is\+Masked\+Array}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a51934f356f9682f4347d725747b4bfef}\label{namespacenumpy_1_1ma_1_1core_a51934f356f9682f4347d725747b4bfef} 
\index{numpy.ma.core@{numpy.ma.core}!isMA@{isMA}}
\index{isMA@{isMA}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{isMA}{isMA}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+is\+MA = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a0fb3f12a8fd2830af78e25f0d22c9d3e}{is\+Masked\+Array}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ae7e7a3dc955065407c7d0801906173b5}\label{namespacenumpy_1_1ma_1_1core_ae7e7a3dc955065407c7d0801906173b5} 
\index{numpy.ma.core@{numpy.ma.core}!less@{less}}
\index{less@{less}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{less}{less}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+less = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+less)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a373aad430737172328d07d67264945fe}\label{namespacenumpy_1_1ma_1_1core_a373aad430737172328d07d67264945fe} 
\index{numpy.ma.core@{numpy.ma.core}!less\_equal@{less\_equal}}
\index{less\_equal@{less\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{less\_equal}{less\_equal}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+less\+\_\+equal = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+less\+\_\+equal)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a3f5dfa023ac8ef0d85c02e582f867159}\label{namespacenumpy_1_1ma_1_1core_a3f5dfa023ac8ef0d85c02e582f867159} 
\index{numpy.ma.core@{numpy.ma.core}!log@{log}}
\index{log@{log}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{log}{log}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+log}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.log,\ 1.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainGreater(0.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_aab50cb82e4a184528e6d179de1a457c1}\label{namespacenumpy_1_1ma_1_1core_aab50cb82e4a184528e6d179de1a457c1} 
\index{numpy.ma.core@{numpy.ma.core}!log10@{log10}}
\index{log10@{log10}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{log10}{log10}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+log10}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.log10,\ 1.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainGreater(0.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_af55e1ce23ec62714eb7e94bf28a46971}\label{namespacenumpy_1_1ma_1_1core_af55e1ce23ec62714eb7e94bf28a46971} 
\index{numpy.ma.core@{numpy.ma.core}!log2@{log2}}
\index{log2@{log2}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{log2}{log2}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+log2}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.log2,\ 1.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainGreater(0.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_af2548e3983fe07d9f740ea481a916a6f}\label{namespacenumpy_1_1ma_1_1core_af2548e3983fe07d9f740ea481a916a6f} 
\index{numpy.ma.core@{numpy.ma.core}!logical\_and@{logical\_and}}
\index{logical\_and@{logical\_and}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{logical\_and}{logical\_and}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+logical\+\_\+and = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+and)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a4c8e7fc0f6ae775e89c5d5e3657d5431}\label{namespacenumpy_1_1ma_1_1core_a4c8e7fc0f6ae775e89c5d5e3657d5431} 
\index{numpy.ma.core@{numpy.ma.core}!logical\_not@{logical\_not}}
\index{logical\_not@{logical\_not}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{logical\_not}{logical\_not}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+logical\+\_\+not = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+logical\+\_\+not)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ad225eefaa421cafecf2ced8cc45374be}\label{namespacenumpy_1_1ma_1_1core_ad225eefaa421cafecf2ced8cc45374be} 
\index{numpy.ma.core@{numpy.ma.core}!logical\_or@{logical\_or}}
\index{logical\_or@{logical\_or}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{logical\_or}{logical\_or}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+logical\+\_\+or = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+or)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a7df643d412aa21b4b8c01c8dd88bf6e6}\label{namespacenumpy_1_1ma_1_1core_a7df643d412aa21b4b8c01c8dd88bf6e6} 
\index{numpy.ma.core@{numpy.ma.core}!logical\_xor@{logical\_xor}}
\index{logical\_xor@{logical\_xor}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{logical\_xor}{logical\_xor}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+logical\+\_\+xor = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+logical\+\_\+xor)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ad49455d80ed35dc668673068a0fd6129}\label{namespacenumpy_1_1ma_1_1core_ad49455d80ed35dc668673068a0fd6129} 
\index{numpy.ma.core@{numpy.ma.core}!masked@{masked}}
\index{masked@{masked}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked}{masked}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedConstant}{Masked\+Constant}}()}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a0462968b90d3e1a2aa6c54845c45f5da}\label{namespacenumpy_1_1ma_1_1core_a0462968b90d3e1a2aa6c54845c45f5da} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_array@{masked\_array}}
\index{masked\_array@{masked\_array}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_array}{masked\_array}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+array = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1MaskedArray}{Masked\+Array}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a42b4fb5861601e58f9e118e6630187b2}\label{namespacenumpy_1_1ma_1_1core_a42b4fb5861601e58f9e118e6630187b2} 
\index{numpy.ma.core@{numpy.ma.core}!masked\_print\_option@{masked\_print\_option}}
\index{masked\_print\_option@{masked\_print\_option}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{masked\_print\_option}{masked\_print\_option}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+masked\+\_\+print\+\_\+option = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedPrintOption}{\+\_\+\+Masked\+Print\+Option}}(\textquotesingle{}-\/-\/\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e}\label{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e} 
\index{numpy.ma.core@{numpy.ma.core}!MaskType@{MaskType}}
\index{MaskType@{MaskType}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{MaskType}{MaskType}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+Mask\+Type = np.\+bool}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a115e8a82d45c099a3ca87ac53e088196}\label{namespacenumpy_1_1ma_1_1core_a115e8a82d45c099a3ca87ac53e088196} 
\index{numpy.ma.core@{numpy.ma.core}!max\_filler@{max\_filler}}
\index{max\_filler@{max\_filler}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{max\_filler}{max\_filler}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+max\+\_\+filler = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_aa870f600996814468ff2c6c5e373d84a}{\+\_\+minvals}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a62a7d8c694b3891ba4a473dee4f2f6d6}\label{namespacenumpy_1_1ma_1_1core_a62a7d8c694b3891ba4a473dee4f2f6d6} 
\index{numpy.ma.core@{numpy.ma.core}!max\_val@{max\_val}}
\index{max\_val@{max\_val}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{max\_val}{max\_val}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+max\+\_\+val}

\Hypertarget{namespacenumpy_1_1ma_1_1core_af5e69f0e12633758a7f1b414f0fa1bc6}\label{namespacenumpy_1_1ma_1_1core_af5e69f0e12633758a7f1b414f0fa1bc6} 
\index{numpy.ma.core@{numpy.ma.core}!maximum@{maximum}}
\index{maximum@{maximum}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{maximum}{maximum}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+maximum = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__extrema__operation}{\+\_\+extrema\+\_\+operation}}(umath.\+maximum, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af46d1de5e4c57b6eb70f8c1130da875d}{greater}}, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a09e1df3c10c1071ab491b82adc781cce}{maximum\+\_\+fill\+\_\+value}})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a46ebf9733bc25babd0aa8f08ae17e9b7}\label{namespacenumpy_1_1ma_1_1core_a46ebf9733bc25babd0aa8f08ae17e9b7} 
\index{numpy.ma.core@{numpy.ma.core}!mean@{mean}}
\index{mean@{mean}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{mean}{mean}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+mean = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}mean\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_af2700e38d027bf2fd011e296af3201cc}\label{namespacenumpy_1_1ma_1_1core_af2700e38d027bf2fd011e296af3201cc} 
\index{numpy.ma.core@{numpy.ma.core}!min\_filler@{min\_filler}}
\index{min\_filler@{min\_filler}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{min\_filler}{min\_filler}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+min\+\_\+filler = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a52e0aa8235d8e8866c4f93132ea361a5}{\+\_\+maxvals}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a565120922b2e50b2f9040265b1f921fc}\label{namespacenumpy_1_1ma_1_1core_a565120922b2e50b2f9040265b1f921fc} 
\index{numpy.ma.core@{numpy.ma.core}!min\_val@{min\_val}}
\index{min\_val@{min\_val}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{min\_val}{min\_val}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+min\+\_\+val}

\Hypertarget{namespacenumpy_1_1ma_1_1core_aeb2ba5831680f4c8197597059511b49a}\label{namespacenumpy_1_1ma_1_1core_aeb2ba5831680f4c8197597059511b49a} 
\index{numpy.ma.core@{numpy.ma.core}!minimum@{minimum}}
\index{minimum@{minimum}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{minimum}{minimum}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+minimum = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__extrema__operation}{\+\_\+extrema\+\_\+operation}}(umath.\+minimum, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae7e7a3dc955065407c7d0801906173b5}{less}}, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_a1d560799762530922722ed03e325bf75}{minimum\+\_\+fill\+\_\+value}})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a35d11841e3187865b34bdc56062e28f8}\label{namespacenumpy_1_1ma_1_1core_a35d11841e3187865b34bdc56062e28f8} 
\index{numpy.ma.core@{numpy.ma.core}!mod@{mod}}
\index{mod@{mod}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{mod}{mod}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+mod = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainedBinaryOperation}{\+\_\+\+Domained\+Binary\+Operation}}(umath.\+mod, \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__DomainSafeDivide}{\+\_\+\+Domain\+Safe\+Divide}}(), 0, 1)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a904cfee6a443856d8f28bcabdc581ca3}\label{namespacenumpy_1_1ma_1_1core_a904cfee6a443856d8f28bcabdc581ca3} 
\index{numpy.ma.core@{numpy.ma.core}!multiply@{multiply}}
\index{multiply@{multiply}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{multiply}{multiply}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+multiply = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+multiply, 1, 1)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a3f3c3cdb93ef35eff48a3607fe63065d}\label{namespacenumpy_1_1ma_1_1core_a3f3c3cdb93ef35eff48a3607fe63065d} 
\index{numpy.ma.core@{numpy.ma.core}!negative@{negative}}
\index{negative@{negative}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{negative}{negative}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+negative = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+negative)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa}\label{namespacenumpy_1_1ma_1_1core_abafbbb38c7afc60936cc5a55fa23ecfa} 
\index{numpy.ma.core@{numpy.ma.core}!nomask@{nomask}}
\index{nomask@{nomask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{nomask}{nomask}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+nomask = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acc6b89c85d288395d69165107e312c4e}{Mask\+Type}}(0)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a157435586edf14697eb861bf883f53a5}\label{namespacenumpy_1_1ma_1_1core_a157435586edf14697eb861bf883f53a5} 
\index{numpy.ma.core@{numpy.ma.core}!nonzero@{nonzero}}
\index{nonzero@{nonzero}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{nonzero}{nonzero}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+nonzero = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}nonzero\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ac48abe6f0d8fe084e093b892a3f6204a}\label{namespacenumpy_1_1ma_1_1core_ac48abe6f0d8fe084e093b892a3f6204a} 
\index{numpy.ma.core@{numpy.ma.core}!not\_equal@{not\_equal}}
\index{not\_equal@{not\_equal}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{not\_equal}{not\_equal}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+not\+\_\+equal = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+not\+\_\+equal)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ac7e1120e60c622054350c7e6e1ca62c2}\label{namespacenumpy_1_1ma_1_1core_ac7e1120e60c622054350c7e6e1ca62c2} 
\index{numpy.ma.core@{numpy.ma.core}!ones@{ones}}
\index{ones@{ones}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ones}{ones}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ones}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'ones'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_ac83bf6449039f715038b5aafb1b4c052}\label{namespacenumpy_1_1ma_1_1core_ac83bf6449039f715038b5aafb1b4c052} 
\index{numpy.ma.core@{numpy.ma.core}!ones\_like@{ones\_like}}
\index{ones\_like@{ones\_like}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ones\_like}{ones\_like}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ones\+\_\+like}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'ones\_like'},}
\DoxyCodeLine{00003\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00004\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00005\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_aca2cd675f56afaf40f368db1b4736046}\label{namespacenumpy_1_1ma_1_1core_aca2cd675f56afaf40f368db1b4736046} 
\index{numpy.ma.core@{numpy.ma.core}!outerproduct@{outerproduct}}
\index{outerproduct@{outerproduct}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{outerproduct}{outerproduct}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+outerproduct = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_af2f6d2c8970c6ad528639810df1d9e6c}{outer}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_acd937c16ef10fa2184bb450224be6603}\label{namespacenumpy_1_1ma_1_1core_acd937c16ef10fa2184bb450224be6603} 
\index{numpy.ma.core@{numpy.ma.core}!prod@{prod}}
\index{prod@{prod}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{prod}{prod}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+prod = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}prod\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a5b7331c8be2833e3cb23d3aff257f193}\label{namespacenumpy_1_1ma_1_1core_a5b7331c8be2833e3cb23d3aff257f193} 
\index{numpy.ma.core@{numpy.ma.core}!product@{product}}
\index{product@{product}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{product}{product}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+product = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_acd937c16ef10fa2184bb450224be6603}{prod}}\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ad95c8d874cf47e68e31d3129b3339634}\label{namespacenumpy_1_1ma_1_1core_ad95c8d874cf47e68e31d3129b3339634} 
\index{numpy.ma.core@{numpy.ma.core}!ravel@{ravel}}
\index{ravel@{ravel}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ravel}{ravel}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+ravel = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}ravel\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a47e9cb4bc6277b24b219f6794480c811}\label{namespacenumpy_1_1ma_1_1core_a47e9cb4bc6277b24b219f6794480c811} 
\index{numpy.ma.core@{numpy.ma.core}!reduce@{reduce}}
\index{reduce@{reduce}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{reduce}{reduce}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+reduce}

\Hypertarget{namespacenumpy_1_1ma_1_1core_af9ec8885ec7e33164ab240325c62cb91}\label{namespacenumpy_1_1ma_1_1core_af9ec8885ec7e33164ab240325c62cb91} 
\index{numpy.ma.core@{numpy.ma.core}!remainder@{remainder}}
\index{remainder@{remainder}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{remainder}{remainder}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+remainder}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_DomainedBinaryOperation(umath.remainder,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainSafeDivide(),\ 0,\ 1)}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_ae0c207c42a170872500d93cf9e8b8751}\label{namespacenumpy_1_1ma_1_1core_ae0c207c42a170872500d93cf9e8b8751} 
\index{numpy.ma.core@{numpy.ma.core}!repeat@{repeat}}
\index{repeat@{repeat}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{repeat}{repeat}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+repeat = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}repeat\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a80eee7765e1c59f3e9d47062c1ab80f4}\label{namespacenumpy_1_1ma_1_1core_a80eee7765e1c59f3e9d47062c1ab80f4} 
\index{numpy.ma.core@{numpy.ma.core}!round@{round}}
\index{round@{round}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{round}{round}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+round = \mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ab65dc83aa506b08f16d69e23a24c7765}{round\+\_\+}}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a50c62686f6332c6c784d556e249bb780}\label{namespacenumpy_1_1ma_1_1core_a50c62686f6332c6c784d556e249bb780} 
\index{numpy.ma.core@{numpy.ma.core}!scalar\_dtype@{scalar\_dtype}}
\index{scalar\_dtype@{scalar\_dtype}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{scalar\_dtype}{scalar\_dtype}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+scalar\+\_\+dtype = np.\+dtype(sctype)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ab9777efc4fb11b7132de51052e367be2}\label{namespacenumpy_1_1ma_1_1core_ab9777efc4fb11b7132de51052e367be2} 
\index{numpy.ma.core@{numpy.ma.core}!shrink\_mask@{shrink\_mask}}
\index{shrink\_mask@{shrink\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{shrink\_mask}{shrink\_mask}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+shrink\+\_\+mask = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}shrink\+\_\+mask\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a9011f3b810867bc580b530fd7e301f5b}\label{namespacenumpy_1_1ma_1_1core_a9011f3b810867bc580b530fd7e301f5b} 
\index{numpy.ma.core@{numpy.ma.core}!sin@{sin}}
\index{sin@{sin}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{sin}{sin}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+sin = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+sin)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_ad4a0e34a99e04590b9523a40b66a929e}\label{namespacenumpy_1_1ma_1_1core_ad4a0e34a99e04590b9523a40b66a929e} 
\index{numpy.ma.core@{numpy.ma.core}!sinh@{sinh}}
\index{sinh@{sinh}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{sinh}{sinh}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+sinh = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+sinh)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a254c1fa90224b11d8cb149f0e21f6161}\label{namespacenumpy_1_1ma_1_1core_a254c1fa90224b11d8cb149f0e21f6161} 
\index{numpy.ma.core@{numpy.ma.core}!soften\_mask@{soften\_mask}}
\index{soften\_mask@{soften\_mask}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{soften\_mask}{soften\_mask}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+soften\+\_\+mask = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}soften\+\_\+mask\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_afd9e0f9fd48cfc33ec5a3f2f5787c24a}\label{namespacenumpy_1_1ma_1_1core_afd9e0f9fd48cfc33ec5a3f2f5787c24a} 
\index{numpy.ma.core@{numpy.ma.core}!sometrue@{sometrue}}
\index{sometrue@{sometrue}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{sometrue}{sometrue}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+sometrue = logical\+\_\+or.\+reduce}

\Hypertarget{namespacenumpy_1_1ma_1_1core_afaf4f80457e478c88bb42ebe6a09c8aa}\label{namespacenumpy_1_1ma_1_1core_afaf4f80457e478c88bb42ebe6a09c8aa} 
\index{numpy.ma.core@{numpy.ma.core}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{sqrt}{sqrt}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+sqrt}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.sqrt,\ 0.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainGreaterEqual(0.0))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a25bd219452b8eb46a2888a83ddac4961}\label{namespacenumpy_1_1ma_1_1core_a25bd219452b8eb46a2888a83ddac4961} 
\index{numpy.ma.core@{numpy.ma.core}!squeeze@{squeeze}}
\index{squeeze@{squeeze}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{squeeze}{squeeze}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+squeeze}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'squeeze'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'squeezed\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'squeezed\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a6218f021e131e27eea147e501b183a08}\label{namespacenumpy_1_1ma_1_1core_a6218f021e131e27eea147e501b183a08} 
\index{numpy.ma.core@{numpy.ma.core}!std@{std}}
\index{std@{std}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{std}{std}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+std = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}std\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a6f98e92563a77b193c897b57b29616be}\label{namespacenumpy_1_1ma_1_1core_a6f98e92563a77b193c897b57b29616be} 
\index{numpy.ma.core@{numpy.ma.core}!subtract@{subtract}}
\index{subtract@{subtract}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{subtract}{subtract}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+subtract = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedBinaryOperation}{\+\_\+\+Masked\+Binary\+Operation}}(umath.\+subtract)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a009376cf93afe2abb614042bb8da83f4}\label{namespacenumpy_1_1ma_1_1core_a009376cf93afe2abb614042bb8da83f4} 
\index{numpy.ma.core@{numpy.ma.core}!sum@{sum}}
\index{sum@{sum}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{sum}{sum}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+sum = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}sum\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a305644a52798502115b3b3f2a6a9b056}\label{namespacenumpy_1_1ma_1_1core_a305644a52798502115b3b3f2a6a9b056} 
\index{numpy.ma.core@{numpy.ma.core}!swapaxes@{swapaxes}}
\index{swapaxes@{swapaxes}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{swapaxes}{swapaxes}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+swapaxes = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}swapaxes\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_acf722039ca4f5f079ec956da05738e52}\label{namespacenumpy_1_1ma_1_1core_acf722039ca4f5f079ec956da05738e52} 
\index{numpy.ma.core@{numpy.ma.core}!tan@{tan}}
\index{tan@{tan}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{tan}{tan}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+tan}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_MaskedUnaryOperation(umath.tan,\ 0.0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainTan(1e-\/35))}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_a6afd07da1a3d4b9585669fc115a8ce02}\label{namespacenumpy_1_1ma_1_1core_a6afd07da1a3d4b9585669fc115a8ce02} 
\index{numpy.ma.core@{numpy.ma.core}!tanh@{tanh}}
\index{tanh@{tanh}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{tanh}{tanh}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+tanh = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__MaskedUnaryOperation}{\+\_\+\+Masked\+Unary\+Operation}}(umath.\+tanh)}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a724ae498510cf6c1dafdc266c64d744f}\label{namespacenumpy_1_1ma_1_1core_a724ae498510cf6c1dafdc266c64d744f} 
\index{numpy.ma.core@{numpy.ma.core}!trace@{trace}}
\index{trace@{trace}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{trace}{trace}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+trace = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}trace\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a1212505d2325c633277326ea6ff0ceb1}\label{namespacenumpy_1_1ma_1_1core_a1212505d2325c633277326ea6ff0ceb1} 
\index{numpy.ma.core@{numpy.ma.core}!true\_divide@{true\_divide}}
\index{true\_divide@{true\_divide}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{true\_divide}{true\_divide}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+true\+\_\+divide}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_DomainedBinaryOperation(umath.true\_divide,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_DomainSafeDivide(),\ 0,\ 1)}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_ad413190a3c501d5f20cc1b97c6c4417e}\label{namespacenumpy_1_1ma_1_1core_ad413190a3c501d5f20cc1b97c6c4417e} 
\index{numpy.ma.core@{numpy.ma.core}!ufunc\_domain@{ufunc\_domain}}
\index{ufunc\_domain@{ufunc\_domain}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ufunc\_domain}{ufunc\_domain}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+ufunc\+\_\+domain = \{\}}



Ufuncs \#. 

\Hypertarget{namespacenumpy_1_1ma_1_1core_a1ef6b945fc572f9141935e8d192acb9d}\label{namespacenumpy_1_1ma_1_1core_a1ef6b945fc572f9141935e8d192acb9d} 
\index{numpy.ma.core@{numpy.ma.core}!ufunc\_fills@{ufunc\_fills}}
\index{ufunc\_fills@{ufunc\_fills}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{ufunc\_fills}{ufunc\_fills}}
{\footnotesize\ttfamily dict numpy.\+ma.\+core.\+ufunc\+\_\+fills = \{\}}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a6250d7311d9a85a9e0e016ecc4312496}\label{namespacenumpy_1_1ma_1_1core_a6250d7311d9a85a9e0e016ecc4312496} 
\index{numpy.ma.core@{numpy.ma.core}!var@{var}}
\index{var@{var}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{var}{var}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+var = \mbox{\hyperlink{classnumpy_1_1ma_1_1core_1_1__frommethod}{\+\_\+frommethod}}(\textquotesingle{}var\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1core_a20bba9e970ae1fccfa1bbb87e82a53ac}\label{namespacenumpy_1_1ma_1_1core_a20bba9e970ae1fccfa1bbb87e82a53ac} 
\index{numpy.ma.core@{numpy.ma.core}!zeros@{zeros}}
\index{zeros@{zeros}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{zeros}{zeros}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+zeros}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'zeros'},}
\DoxyCodeLine{00003\ \ \ \ \ params=dict(fill\_value=\textcolor{keywordtype}{None},\ hardmask=\textcolor{keyword}{False}),}
\DoxyCodeLine{00004\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00005\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00006\ )}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1ma_1_1core_ae42b665e6fa6c8fcebe20cac5a452be4}\label{namespacenumpy_1_1ma_1_1core_ae42b665e6fa6c8fcebe20cac5a452be4} 
\index{numpy.ma.core@{numpy.ma.core}!zeros\_like@{zeros\_like}}
\index{zeros\_like@{zeros\_like}!numpy.ma.core@{numpy.ma.core}}
\doxysubsubsection{\texorpdfstring{zeros\_like}{zeros\_like}}
{\footnotesize\ttfamily numpy.\+ma.\+core.\+zeros\+\_\+like}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \_convert2ma(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'zeros\_like'},}
\DoxyCodeLine{00003\ \ \ \ \ np\_ret=\textcolor{stringliteral}{'out\ :\ ndarray'},}
\DoxyCodeLine{00004\ \ \ \ \ np\_ma\_ret=\textcolor{stringliteral}{'out\ :\ MaskedArray'},}
\DoxyCodeLine{00005\ )}

\end{DoxyCode}
