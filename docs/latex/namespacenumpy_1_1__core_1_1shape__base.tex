\doxysection{Référence de l\textquotesingle{}espace de nommage numpy.\+\_\+core.\+shape\+\_\+base}
\hypertarget{namespacenumpy_1_1__core_1_1shape__base}{}\label{namespacenumpy_1_1__core_1_1shape__base}\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a77ca35f027b223b10e0b29acb80b01c1}{\+\_\+atleast\+\_\+1d\+\_\+dispatcher}} (\texorpdfstring{$\ast$}{*}arys)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aa3e663528190d6022c0308eed627b3ba}{atleast\+\_\+1d}} (\texorpdfstring{$\ast$}{*}arys)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_abaecb557d69ac4a3e3129aa939e7cf41}{\+\_\+atleast\+\_\+2d\+\_\+dispatcher}} (\texorpdfstring{$\ast$}{*}arys)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aaf0a3c491edc0294ce876ffb0745f228}{atleast\+\_\+2d}} (\texorpdfstring{$\ast$}{*}arys)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a3ee60cf5046ed86dcda22d52044d403e}{\+\_\+atleast\+\_\+3d\+\_\+dispatcher}} (\texorpdfstring{$\ast$}{*}arys)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aa396efffc365869cac18e8375ba90019}{atleast\+\_\+3d}} (\texorpdfstring{$\ast$}{*}arys)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_afd24b9a6c0c6b8b7270f66d48f64d417}{\+\_\+arrays\+\_\+for\+\_\+stack\+\_\+dispatcher}} (arrays)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a417e5005b67df4080adaa45299c0a685}{\+\_\+vhstack\+\_\+dispatcher}} (tup, \texorpdfstring{$\ast$}{*}dtype=None, casting=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ad676643270e12606eaa34450dfcce776}{vstack}} (tup, \texorpdfstring{$\ast$}{*}dtype=None, casting="{}same\+\_\+kind"{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a2872dc3a251813f1ded09b8d915ef31d}{hstack}} (tup, \texorpdfstring{$\ast$}{*}dtype=None, casting="{}same\+\_\+kind"{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a9c000a1c1a16583408b75a43fa5652c7}{\+\_\+stack\+\_\+dispatcher}} (arrays, axis=None, out=None, \texorpdfstring{$\ast$}{*}dtype=None, casting=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aee59ed1c69480f535c104bf283bddcdf}{stack}} (arrays, axis=0, out=None, \texorpdfstring{$\ast$}{*}dtype=None, casting="{}same\+\_\+kind"{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aba69d373314d26df990897da3034cab1}{\+\_\+unstack\+\_\+dispatcher}} (x, \texorpdfstring{$\ast$}{*}axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ae6b60841aea5bb9fc64ef151f0625bb4}{unstack}} (x, \texorpdfstring{$\ast$}{*}axis=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ad8b8a32a4f8bdf7769b46f210beba7b3}{\+\_\+block\+\_\+format\+\_\+index}} (index)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aabb71e74bb9c9953f464faee9fc86cd6}{\+\_\+block\+\_\+check\+\_\+depths\+\_\+match}} (arrays, parent\+\_\+index=\mbox{[}$\,$\mbox{]})
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a04f66a56bb1923fca7f8069179f2c3c9}{\+\_\+atleast\+\_\+nd}} (a, ndim)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a68e9d71d60831af1dba9e57f495f3ed9}{\+\_\+accumulate}} (values)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a7110bba1008b092b12cdea8609009c95}{\+\_\+concatenate\+\_\+shapes}} (shapes, axis)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_aa2f3b90ae49f7fc6e7be1f08c42783a0}{\+\_\+block\+\_\+info\+\_\+recursion}} (arrays, max\+\_\+depth, result\+\_\+ndim, depth=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a6b2cb3f672b56cd167bb77313365b374}{\+\_\+block}} (arrays, max\+\_\+depth, result\+\_\+ndim, depth=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ab98d47b53962c3ccaa906c159332fbe9}{\+\_\+block\+\_\+dispatcher}} (arrays)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a3087223cdb3722706eb6a0aa7741e3b6}{block}} (arrays)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ab0d707b8cc12ef6677d5eb1e7d9dabbd}{\+\_\+block\+\_\+setup}} (arrays)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ac1e02bc3b8afaa3fdc9338528e653eee}{\+\_\+block\+\_\+slicing}} (arrays, list\+\_\+ndim, result\+\_\+ndim)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a64fee91bd4dc4c27155694a7baf0cfc1}{\+\_\+block\+\_\+concatenate}} (arrays, list\+\_\+ndim, result\+\_\+ndim)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a68164dc99f06173646a1196d489171a6}{array\+\_\+function\+\_\+dispatch}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_a919ac8cea7835031c589ed4f5a5880af}{\+\_\+size}} = getattr(\+\_\+from\+\_\+nx.\+size, \textquotesingle{}\+\_\+\+\_\+wrapped\+\_\+\+\_\+\textquotesingle{}, \+\_\+from\+\_\+nx.\+size)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ad68f201a8ff4ec6dc694e62fe640ba63}{\+\_\+ndim}} = getattr(\+\_\+from\+\_\+nx.\+ndim, \textquotesingle{}\+\_\+\+\_\+wrapped\+\_\+\+\_\+\textquotesingle{}, \+\_\+from\+\_\+nx.\+ndim)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__core_1_1shape__base_ae89602508d888a0b82d1227f3d0688c3}{\+\_\+concatenate}}
\end{DoxyCompactItemize}


\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a68e9d71d60831af1dba9e57f495f3ed9}\label{namespacenumpy_1_1__core_1_1shape__base_a68e9d71d60831af1dba9e57f495f3ed9} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_accumulate@{\_accumulate}}
\index{\_accumulate@{\_accumulate}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_accumulate()}{\_accumulate()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+accumulate (\begin{DoxyParamCaption}\item[{}]{values }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_afd24b9a6c0c6b8b7270f66d48f64d417}\label{namespacenumpy_1_1__core_1_1shape__base_afd24b9a6c0c6b8b7270f66d48f64d417} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_arrays\_for\_stack\_dispatcher@{\_arrays\_for\_stack\_dispatcher}}
\index{\_arrays\_for\_stack\_dispatcher@{\_arrays\_for\_stack\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_arrays\_for\_stack\_dispatcher()}{\_arrays\_for\_stack\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+arrays\+\_\+for\+\_\+stack\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arrays }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a77ca35f027b223b10e0b29acb80b01c1}\label{namespacenumpy_1_1__core_1_1shape__base_a77ca35f027b223b10e0b29acb80b01c1} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_atleast\_1d\_dispatcher@{\_atleast\_1d\_dispatcher}}
\index{\_atleast\_1d\_dispatcher@{\_atleast\_1d\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_atleast\_1d\_dispatcher()}{\_atleast\_1d\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+atleast\+\_\+1d\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arys }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_abaecb557d69ac4a3e3129aa939e7cf41}\label{namespacenumpy_1_1__core_1_1shape__base_abaecb557d69ac4a3e3129aa939e7cf41} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_atleast\_2d\_dispatcher@{\_atleast\_2d\_dispatcher}}
\index{\_atleast\_2d\_dispatcher@{\_atleast\_2d\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_atleast\_2d\_dispatcher()}{\_atleast\_2d\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+atleast\+\_\+2d\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arys }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a3ee60cf5046ed86dcda22d52044d403e}\label{namespacenumpy_1_1__core_1_1shape__base_a3ee60cf5046ed86dcda22d52044d403e} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_atleast\_3d\_dispatcher@{\_atleast\_3d\_dispatcher}}
\index{\_atleast\_3d\_dispatcher@{\_atleast\_3d\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_atleast\_3d\_dispatcher()}{\_atleast\_3d\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+atleast\+\_\+3d\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arys }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a04f66a56bb1923fca7f8069179f2c3c9}\label{namespacenumpy_1_1__core_1_1shape__base_a04f66a56bb1923fca7f8069179f2c3c9} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_atleast\_nd@{\_atleast\_nd}}
\index{\_atleast\_nd@{\_atleast\_nd}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_atleast\_nd()}{\_atleast\_nd()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+atleast\+\_\+nd (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{ndim }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a6b2cb3f672b56cd167bb77313365b374}\label{namespacenumpy_1_1__core_1_1shape__base_a6b2cb3f672b56cd167bb77313365b374} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block@{\_block}}
\index{\_block@{\_block}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block()}{\_block()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{max\+\_\+depth,  }\item[{}]{result\+\_\+ndim,  }\item[{}]{depth = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Internal implementation of block based on repeated concatenation.
`arrays` is the argument passed to
block. `max_depth` is the depth of nested lists within `arrays` and
`result_ndim` is the greatest of the dimensions of the arrays in
`arrays` and the depth of the lists in `arrays` (see block docstring
for details).
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aabb71e74bb9c9953f464faee9fc86cd6}\label{namespacenumpy_1_1__core_1_1shape__base_aabb71e74bb9c9953f464faee9fc86cd6} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_check\_depths\_match@{\_block\_check\_depths\_match}}
\index{\_block\_check\_depths\_match@{\_block\_check\_depths\_match}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_check\_depths\_match()}{\_block\_check\_depths\_match()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+check\+\_\+depths\+\_\+match (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{parent\+\_\+index = {\ttfamily \mbox{[}\mbox{]}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Recursive function checking that the depths of nested lists in `arrays`
all match. Mismatch raises a ValueError as described in the block
docstring below.

The entire index (rather than just the depth) needs to be calculated
for each innermost list, in case an error needs to be raised, so that
the index of the offending list can be printed as part of the error.

Parameters
----------
arrays : nested list of arrays
    The arrays to check
parent_index : list of int
    The full index of `arrays` within the nested lists passed to
    `_block_check_depths_match` at the top of the recursion.

Returns
-------
first_index : list of int
    The full index of an element from the bottom of the nesting in
    `arrays`. If any element at the bottom is an empty list, this will
    refer to it, and the last index along the empty axis will be None.
max_arr_ndim : int
    The maximum of the ndims of the arrays nested in `arrays`.
final_size: int
    The number of elements in the final array. This is used the motivate
    the choice of algorithm used using benchmarking wisdom.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a64fee91bd4dc4c27155694a7baf0cfc1}\label{namespacenumpy_1_1__core_1_1shape__base_a64fee91bd4dc4c27155694a7baf0cfc1} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_concatenate@{\_block\_concatenate}}
\index{\_block\_concatenate@{\_block\_concatenate}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_concatenate()}{\_block\_concatenate()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+concatenate (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{list\+\_\+ndim,  }\item[{}]{result\+\_\+ndim }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ab98d47b53962c3ccaa906c159332fbe9}\label{namespacenumpy_1_1__core_1_1shape__base_ab98d47b53962c3ccaa906c159332fbe9} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_dispatcher@{\_block\_dispatcher}}
\index{\_block\_dispatcher@{\_block\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_dispatcher()}{\_block\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arrays }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ad8b8a32a4f8bdf7769b46f210beba7b3}\label{namespacenumpy_1_1__core_1_1shape__base_ad8b8a32a4f8bdf7769b46f210beba7b3} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_format\_index@{\_block\_format\_index}}
\index{\_block\_format\_index@{\_block\_format\_index}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_format\_index()}{\_block\_format\_index()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+format\+\_\+index (\begin{DoxyParamCaption}\item[{}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Convert a list of indices ``[0, 1, 2]`` into ``"arrays[0][1][2]"``.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aa2f3b90ae49f7fc6e7be1f08c42783a0}\label{namespacenumpy_1_1__core_1_1shape__base_aa2f3b90ae49f7fc6e7be1f08c42783a0} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_info\_recursion@{\_block\_info\_recursion}}
\index{\_block\_info\_recursion@{\_block\_info\_recursion}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_info\_recursion()}{\_block\_info\_recursion()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+info\+\_\+recursion (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{max\+\_\+depth,  }\item[{}]{result\+\_\+ndim,  }\item[{}]{depth = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns the shape of the final array, along with a list
of slices and a list of arrays that can be used for assignment inside the
new array

Parameters
----------
arrays : nested list of arrays
    The arrays to check
max_depth : list of int
    The number of nested lists
result_ndim : int
    The number of dimensions in thefinal array.

Returns
-------
shape : tuple of int
    The shape that the final array will take on.
slices: list of tuple of slices
    The slices into the full array required for assignment. These are
    required to be prepended with ``(Ellipsis, )`` to obtain to correct
    final index.
arrays: list of ndarray
    The data to assign to each slice of the full array\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ab0d707b8cc12ef6677d5eb1e7d9dabbd}\label{namespacenumpy_1_1__core_1_1shape__base_ab0d707b8cc12ef6677d5eb1e7d9dabbd} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_setup@{\_block\_setup}}
\index{\_block\_setup@{\_block\_setup}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_setup()}{\_block\_setup()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+setup (\begin{DoxyParamCaption}\item[{}]{arrays }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns
(`arrays`, list_ndim, result_ndim, final_size)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ac1e02bc3b8afaa3fdc9338528e653eee}\label{namespacenumpy_1_1__core_1_1shape__base_ac1e02bc3b8afaa3fdc9338528e653eee} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_block\_slicing@{\_block\_slicing}}
\index{\_block\_slicing@{\_block\_slicing}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_block\_slicing()}{\_block\_slicing()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+block\+\_\+slicing (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{list\+\_\+ndim,  }\item[{}]{result\+\_\+ndim }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a7110bba1008b092b12cdea8609009c95}\label{namespacenumpy_1_1__core_1_1shape__base_a7110bba1008b092b12cdea8609009c95} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_concatenate\_shapes@{\_concatenate\_shapes}}
\index{\_concatenate\_shapes@{\_concatenate\_shapes}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_concatenate\_shapes()}{\_concatenate\_shapes()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+concatenate\+\_\+shapes (\begin{DoxyParamCaption}\item[{}]{shapes,  }\item[{}]{axis }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Given array shapes, return the resulting shape and slices prefixes.

These help in nested concatenation.

Returns
-------
shape: tuple of int
    This tuple satisfies::

        shape, _ = _concatenate_shapes([arr.shape for shape in arrs], axis)
        shape == concatenate(arrs, axis).shape

slice_prefixes: tuple of (slice(start, end), )
    For a list of arrays being concatenated, this returns the slice
    in the larger array at axis that needs to be sliced into.

    For example, the following holds::

        ret = concatenate([a, b, c], axis)
        _, (sl_a, sl_b, sl_c) = concatenate_slices([a, b, c], axis)

        ret[(slice(None),) * axis + sl_a] == a
        ret[(slice(None),) * axis + sl_b] == b
        ret[(slice(None),) * axis + sl_c] == c

    These are called slice prefixes since they are used in the recursive
    blocking algorithm to compute the left-most slices during the
    recursion. Therefore, they must be prepended to rest of the slice
    that was computed deeper in the recursion.

    These are returned as tuples to ensure that they can quickly be added
    to existing slice tuple without creating a new tuple every time.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a9c000a1c1a16583408b75a43fa5652c7}\label{namespacenumpy_1_1__core_1_1shape__base_a9c000a1c1a16583408b75a43fa5652c7} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_stack\_dispatcher@{\_stack\_dispatcher}}
\index{\_stack\_dispatcher@{\_stack\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_stack\_dispatcher()}{\_stack\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+stack\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{dtype = {\ttfamily None},  }\item[{}]{casting = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aba69d373314d26df990897da3034cab1}\label{namespacenumpy_1_1__core_1_1shape__base_aba69d373314d26df990897da3034cab1} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_unstack\_dispatcher@{\_unstack\_dispatcher}}
\index{\_unstack\_dispatcher@{\_unstack\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_unstack\_dispatcher()}{\_unstack\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+unstack\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{\texorpdfstring{$\ast$}{*}}]{axis = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a417e5005b67df4080adaa45299c0a685}\label{namespacenumpy_1_1__core_1_1shape__base_a417e5005b67df4080adaa45299c0a685} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_vhstack\_dispatcher@{\_vhstack\_dispatcher}}
\index{\_vhstack\_dispatcher@{\_vhstack\_dispatcher}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_vhstack\_dispatcher()}{\_vhstack\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+vhstack\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{tup,  }\item[{\texorpdfstring{$\ast$}{*}}]{dtype = {\ttfamily None},  }\item[{}]{casting = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aa3e663528190d6022c0308eed627b3ba}\label{namespacenumpy_1_1__core_1_1shape__base_aa3e663528190d6022c0308eed627b3ba} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!atleast\_1d@{atleast\_1d}}
\index{atleast\_1d@{atleast\_1d}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{atleast\_1d()}{atleast\_1d()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+atleast\+\_\+1d (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arys }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert inputs to arrays with at least one dimension.

Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.

Parameters
----------
arys1, arys2, ... : array_like
    One or more input arrays.

Returns
-------
ret : ndarray
    An array, or tuple of arrays, each with ``a.ndim >= 1``.
    Copies are made only if necessary.

See Also
--------
atleast_2d, atleast_3d

Examples
--------
>>> import numpy as np
>>> np.atleast_1d(1.0)
array([1.])

>>> x = np.arange(9.0).reshape(3,3)
>>> np.atleast_1d(x)
array([[0., 1., 2.],
       [3., 4., 5.],
       [6., 7., 8.]])
>>> np.atleast_1d(x) is x
True

>>> np.atleast_1d(1, [3, 4])
(array([1]), array([3, 4]))\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aaf0a3c491edc0294ce876ffb0745f228}\label{namespacenumpy_1_1__core_1_1shape__base_aaf0a3c491edc0294ce876ffb0745f228} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!atleast\_2d@{atleast\_2d}}
\index{atleast\_2d@{atleast\_2d}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{atleast\_2d()}{atleast\_2d()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+atleast\+\_\+2d (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arys }\end{DoxyParamCaption})}

\begin{DoxyVerb}View inputs as arrays with at least two dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted
    to arrays.  Arrays that already have two or more dimensions are
    preserved.

Returns
-------
res, res2, ... : ndarray
    An array, or tuple of arrays, each with ``a.ndim >= 2``.
    Copies are avoided where possible, and views with two or more
    dimensions are returned.

See Also
--------
atleast_1d, atleast_3d

Examples
--------
>>> import numpy as np
>>> np.atleast_2d(3.0)
array([[3.]])

>>> x = np.arange(3.0)
>>> np.atleast_2d(x)
array([[0., 1., 2.]])
>>> np.atleast_2d(x).base is x
True

>>> np.atleast_2d(1, [1, 2], [[1, 2]])
(array([[1]]), array([[1, 2]]), array([[1, 2]]))\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aa396efffc365869cac18e8375ba90019}\label{namespacenumpy_1_1__core_1_1shape__base_aa396efffc365869cac18e8375ba90019} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!atleast\_3d@{atleast\_3d}}
\index{atleast\_3d@{atleast\_3d}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{atleast\_3d()}{atleast\_3d()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+atleast\+\_\+3d (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arys }\end{DoxyParamCaption})}

\begin{DoxyVerb}View inputs as arrays with at least three dimensions.

Parameters
----------
arys1, arys2, ... : array_like
    One or more array-like sequences.  Non-array inputs are converted to
    arrays.  Arrays that already have three or more dimensions are
    preserved.

Returns
-------
res1, res2, ... : ndarray
    An array, or tuple of arrays, each with ``a.ndim >= 3``.  Copies are
    avoided where possible, and views with three or more dimensions are
    returned.  For example, a 1-D array of shape ``(N,)`` becomes a view
    of shape ``(1, N, 1)``, and a 2-D array of shape ``(M, N)`` becomes a
    view of shape ``(M, N, 1)``.

See Also
--------
atleast_1d, atleast_2d

Examples
--------
>>> import numpy as np
>>> np.atleast_3d(3.0)
array([[[3.]]])

>>> x = np.arange(3.0)
>>> np.atleast_3d(x).shape
(1, 3, 1)

>>> x = np.arange(12.0).reshape(4,3)
>>> np.atleast_3d(x).shape
(4, 3, 1)
>>> np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself
True

>>> for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):
...     print(arr, arr.shape) # doctest: +SKIP
...
[[[1]
  [2]]] (1, 2, 1)
[[[1]
  [2]]] (1, 2, 1)
[[[1 2]]] (1, 1, 2)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a3087223cdb3722706eb6a0aa7741e3b6}\label{namespacenumpy_1_1__core_1_1shape__base_a3087223cdb3722706eb6a0aa7741e3b6} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!block@{block}}
\index{block@{block}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{block()}{block()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+block (\begin{DoxyParamCaption}\item[{}]{arrays }\end{DoxyParamCaption})}

\begin{DoxyVerb}Assemble an nd-array from nested lists of blocks.

Blocks in the innermost lists are concatenated (see `concatenate`) along
the last dimension (-1), then these are concatenated along the
second-last dimension (-2), and so on until the outermost list is reached.

Blocks can be of any dimension, but will not be broadcasted using
the normal rules. Instead, leading axes of size 1 are inserted,
to make ``block.ndim`` the same for all blocks. This is primarily useful
for working with scalars, and means that code like ``np.block([v, 1])``
is valid, where ``v.ndim == 1``.

When the nested list is two levels deep, this allows block matrices to be
constructed from their components.

Parameters
----------
arrays : nested list of array_like or scalars (but not tuples)
    If passed a single ndarray or scalar (a nested list of depth 0), this
    is returned unmodified (and not copied).

    Elements shapes must match along the appropriate axes (without
    broadcasting), but leading 1s will be prepended to the shape as
    necessary to make the dimensions match.

Returns
-------
block_array : ndarray
    The array assembled from the given blocks.

    The dimensionality of the output is equal to the greatest of:

    * the dimensionality of all the inputs
    * the depth to which the input list is nested

Raises
------
ValueError
    * If list depths are mismatched - for instance, ``[[a, b], c]`` is
      illegal, and should be spelt ``[[a, b], [c]]``
    * If lists are empty - for instance, ``[[a, b], []]``

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
vstack : Stack arrays in sequence vertically (row wise).
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).
unstack : Split an array into a tuple of sub-arrays along an axis.

Notes
-----
When called with only scalars, ``np.block`` is equivalent to an ndarray
call. So ``np.block([[1, 2], [3, 4]])`` is equivalent to
``np.array([[1, 2], [3, 4]])``.

This function does not enforce that the blocks lie on a fixed grid.
``np.block([[a, b], [c, d]])`` is not restricted to arrays of the form::

    AAAbb
    AAAbb
    cccDD

But is also allowed to produce, for some ``a, b, c, d``::

    AAAbb
    AAAbb
    cDDDD

Since concatenation happens along the last axis first, `block` is *not*
capable of producing the following directly::

    AAAbb
    cccbb
    cccDD

Matlab's "square bracket stacking", ``[A, B, ...; p, q, ...]``, is
equivalent to ``np.block([[A, B, ...], [p, q, ...]])``.

Examples
--------
The most common use of this function is to build a block matrix:

>>> import numpy as np
>>> A = np.eye(2) * 2
>>> B = np.eye(3) * 3
>>> np.block([
...     [A,               np.zeros((2, 3))],
...     [np.ones((3, 2)), B               ]
... ])
array([[2., 0., 0., 0., 0.],
       [0., 2., 0., 0., 0.],
       [1., 1., 3., 0., 0.],
       [1., 1., 0., 3., 0.],
       [1., 1., 0., 0., 3.]])

With a list of depth 1, `block` can be used as `hstack`:

>>> np.block([1, 2, 3])              # hstack([1, 2, 3])
array([1, 2, 3])

>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.block([a, b, 10])             # hstack([a, b, 10])
array([ 1,  2,  3,  4,  5,  6, 10])

>>> A = np.ones((2, 2), int)
>>> B = 2 * A
>>> np.block([A, B])                 # hstack([A, B])
array([[1, 1, 2, 2],
       [1, 1, 2, 2]])

With a list of depth 2, `block` can be used in place of `vstack`:

>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.block([[a], [b]])             # vstack([a, b])
array([[1, 2, 3],
       [4, 5, 6]])

>>> A = np.ones((2, 2), int)
>>> B = 2 * A
>>> np.block([[A], [B]])             # vstack([A, B])
array([[1, 1],
       [1, 1],
       [2, 2],
       [2, 2]])

It can also be used in place of `atleast_1d` and `atleast_2d`:

>>> a = np.array(0)
>>> b = np.array([1])
>>> np.block([a])                    # atleast_1d(a)
array([0])
>>> np.block([b])                    # atleast_1d(b)
array([1])

>>> np.block([[a]])                  # atleast_2d(a)
array([[0]])
>>> np.block([[b]])                  # atleast_2d(b)
array([[1]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a2872dc3a251813f1ded09b8d915ef31d}\label{namespacenumpy_1_1__core_1_1shape__base_a2872dc3a251813f1ded09b8d915ef31d} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!hstack@{hstack}}
\index{hstack@{hstack}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{hstack()}{hstack()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+hstack (\begin{DoxyParamCaption}\item[{}]{tup,  }\item[{\texorpdfstring{$\ast$}{*}}]{dtype = {\ttfamily None},  }\item[{}]{casting = {\ttfamily "{}same\+\_\+kind"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Stack arrays in sequence horizontally (column wise).

This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by `hsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the second axis,
    except 1-D arrays which can be any length. In the case of a single
    array_like input, it will be treated as a sequence of arrays; i.e.,
    each element along the zeroth axis is treated as a separate array.

dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

    .. versionadded:: 1.24

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

    .. versionadded:: 1.24

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
hsplit : Split an array into multiple sub-arrays
         horizontally (column-wise).
unstack : Split an array into a tuple of sub-arrays along an axis.

Examples
--------
>>> import numpy as np
>>> a = np.array((1,2,3))
>>> b = np.array((4,5,6))
>>> np.hstack((a,b))
array([1, 2, 3, 4, 5, 6])
>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[4],[5],[6]])
>>> np.hstack((a,b))
array([[1, 4],
       [2, 5],
       [3, 6]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_aee59ed1c69480f535c104bf283bddcdf}\label{namespacenumpy_1_1__core_1_1shape__base_aee59ed1c69480f535c104bf283bddcdf} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!stack@{stack}}
\index{stack@{stack}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{stack()}{stack()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+stack (\begin{DoxyParamCaption}\item[{}]{arrays,  }\item[{}]{axis = {\ttfamily 0},  }\item[{}]{out = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}}]{dtype = {\ttfamily None},  }\item[{}]{casting = {\ttfamily "{}same\+\_\+kind"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Join a sequence of arrays along a new axis.

The ``axis`` parameter specifies the index of the new axis in the
dimensions of the result. For example, if ``axis=0`` it will be the first
dimension and if ``axis=-1`` it will be the last dimension.

Parameters
----------
arrays : sequence of ndarrays
    Each array must have the same shape. In the case of a single ndarray
    array_like input, it will be treated as a sequence of arrays; i.e.,
    each element along the zeroth axis is treated as a separate array.

axis : int, optional
    The axis in the result array along which the input arrays are stacked.

out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what stack would have returned if no
    out argument were specified.

dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

    .. versionadded:: 1.24

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

    .. versionadded:: 1.24


Returns
-------
stacked : ndarray
    The stacked array has one more dimension than the input arrays.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
block : Assemble an nd-array from nested lists of blocks.
split : Split array into a list of multiple sub-arrays of equal size.
unstack : Split an array into a tuple of sub-arrays along an axis.

Examples
--------
>>> import numpy as np
>>> rng = np.random.default_rng()
>>> arrays = [rng.normal(size=(3,4)) for _ in range(10)]
>>> np.stack(arrays, axis=0).shape
(10, 3, 4)

>>> np.stack(arrays, axis=1).shape
(3, 10, 4)

>>> np.stack(arrays, axis=2).shape
(3, 4, 10)

>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.stack((a, b))
array([[1, 2, 3],
       [4, 5, 6]])

>>> np.stack((a, b), axis=-1)
array([[1, 4],
       [2, 5],
       [3, 6]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ae6b60841aea5bb9fc64ef151f0625bb4}\label{namespacenumpy_1_1__core_1_1shape__base_ae6b60841aea5bb9fc64ef151f0625bb4} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!unstack@{unstack}}
\index{unstack@{unstack}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{unstack()}{unstack()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+unstack (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{\texorpdfstring{$\ast$}{*}}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Split an array into a sequence of arrays along the given axis.

The ``axis`` parameter specifies the dimension along which the array will
be split. For example, if ``axis=0`` (the default) it will be the first
dimension and if ``axis=-1`` it will be the last dimension.

The result is a tuple of arrays split along ``axis``.

.. versionadded:: 2.1.0

Parameters
----------
x : ndarray
    The array to be unstacked.
axis : int, optional
    Axis along which the array will be split. Default: ``0``.

Returns
-------
unstacked : tuple of ndarrays
    The unstacked arrays.

See Also
--------
stack : Join a sequence of arrays along a new axis.
concatenate : Join a sequence of arrays along an existing axis.
block : Assemble an nd-array from nested lists of blocks.
split : Split array into a list of multiple sub-arrays of equal size.

Notes
-----
``unstack`` serves as the reverse operation of :py:func:`stack`, i.e.,
``stack(unstack(x, axis=axis), axis=axis) == x``.

This function is equivalent to ``tuple(np.moveaxis(x, axis, 0))``, since
iterating on an array iterates along the first axis.

Examples
--------
>>> arr = np.arange(24).reshape((2, 3, 4))
>>> np.unstack(arr)
(array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]]),
 array([[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]))
>>> np.unstack(arr, axis=1)
(array([[ 0,  1,  2,  3],
        [12, 13, 14, 15]]),
 array([[ 4,  5,  6,  7],
        [16, 17, 18, 19]]),
 array([[ 8,  9, 10, 11],
        [20, 21, 22, 23]]))
>>> arr2 = np.stack(np.unstack(arr, axis=1), axis=1)
>>> arr2.shape
(2, 3, 4)
>>> np.all(arr == arr2)
np.True_\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ad676643270e12606eaa34450dfcce776}\label{namespacenumpy_1_1__core_1_1shape__base_ad676643270e12606eaa34450dfcce776} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!vstack@{vstack}}
\index{vstack@{vstack}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{vstack()}{vstack()}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+vstack (\begin{DoxyParamCaption}\item[{}]{tup,  }\item[{\texorpdfstring{$\ast$}{*}}]{dtype = {\ttfamily None},  }\item[{}]{casting = {\ttfamily "{}same\+\_\+kind"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Stack arrays in sequence vertically (row wise).

This is equivalent to concatenation along the first axis after 1-D arrays
of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by
`vsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of ndarrays
    The arrays must have the same shape along all but the first axis.
    1-D arrays must have the same length. In the case of a single
    array_like input, it will be treated as a sequence of arrays; i.e.,
    each element along the zeroth axis is treated as a separate array.

dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

    .. versionadded:: 1.24

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

    .. versionadded:: 1.24

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays, will be at least 2-D.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
hstack : Stack arrays in sequence horizontally (column wise).
dstack : Stack arrays in sequence depth wise (along third axis).
column_stack : Stack 1-D arrays as columns into a 2-D array.
vsplit : Split an array into multiple sub-arrays vertically (row-wise).
unstack : Split an array into a tuple of sub-arrays along an axis.

Examples
--------
>>> import numpy as np
>>> a = np.array([1, 2, 3])
>>> b = np.array([4, 5, 6])
>>> np.vstack((a,b))
array([[1, 2, 3],
       [4, 5, 6]])

>>> a = np.array([[1], [2], [3]])
>>> b = np.array([[4], [5], [6]])
>>> np.vstack((a,b))
array([[1],
       [2],
       [3],
       [4],
       [5],
       [6]])\end{DoxyVerb}
 

\doxysubsection{Documentation des variables}
\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ae89602508d888a0b82d1227f3d0688c3}\label{namespacenumpy_1_1__core_1_1shape__base_ae89602508d888a0b82d1227f3d0688c3} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_concatenate@{\_concatenate}}
\index{\_concatenate@{\_concatenate}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_concatenate}{\_concatenate}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+concatenate\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ getattr(\_from\_nx.concatenate,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'\_\_wrapped\_\_'},\ \_from\_nx.concatenate)}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_ad68f201a8ff4ec6dc694e62fe640ba63}\label{namespacenumpy_1_1__core_1_1shape__base_ad68f201a8ff4ec6dc694e62fe640ba63} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_ndim@{\_ndim}}
\index{\_ndim@{\_ndim}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_ndim}{\_ndim}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+ndim = getattr(\+\_\+from\+\_\+nx.\+ndim, \textquotesingle{}\+\_\+\+\_\+wrapped\+\_\+\+\_\+\textquotesingle{}, \+\_\+from\+\_\+nx.\+ndim)\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a919ac8cea7835031c589ed4f5a5880af}\label{namespacenumpy_1_1__core_1_1shape__base_a919ac8cea7835031c589ed4f5a5880af} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!\_size@{\_size}}
\index{\_size@{\_size}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{\_size}{\_size}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+\_\+size = getattr(\+\_\+from\+\_\+nx.\+size, \textquotesingle{}\+\_\+\+\_\+wrapped\+\_\+\+\_\+\textquotesingle{}, \+\_\+from\+\_\+nx.\+size)\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1__core_1_1shape__base_a68164dc99f06173646a1196d489171a6}\label{namespacenumpy_1_1__core_1_1shape__base_a68164dc99f06173646a1196d489171a6} 
\index{numpy.\_core.shape\_base@{numpy.\_core.shape\_base}!array\_function\_dispatch@{array\_function\_dispatch}}
\index{array\_function\_dispatch@{array\_function\_dispatch}!numpy.\_core.shape\_base@{numpy.\_core.shape\_base}}
\doxysubsubsection{\texorpdfstring{array\_function\_dispatch}{array\_function\_dispatch}}
{\footnotesize\ttfamily numpy.\+\_\+core.\+shape\+\_\+base.\+array\+\_\+function\+\_\+dispatch}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ functools.partial(}
\DoxyCodeLine{00002\ \ \ \ \ overrides.array\_function\_dispatch,\ module=\textcolor{stringliteral}{'numpy'})}

\end{DoxyCode}
