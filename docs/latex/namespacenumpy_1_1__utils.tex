\doxysection{Référence de l\textquotesingle{}espace de nommage numpy.\+\_\+utils}
\hypertarget{namespacenumpy_1_1__utils}{}\label{namespacenumpy_1_1__utils}\index{numpy.\_utils@{numpy.\_utils}}
\doxysubsubsection*{Espaces de nommage}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespacenumpy_1_1__utils_1_1__convertions}{\+\_\+convertions}}
\item 
namespace \mbox{\hyperlink{namespacenumpy_1_1__utils_1_1__inspect}{\+\_\+inspect}}
\item 
namespace \mbox{\hyperlink{namespacenumpy_1_1__utils_1_1__pep440}{\+\_\+pep440}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1__utils_a7c03c558340628601ca938d96ded1459}{set\+\_\+module}} (module)
\item 
\mbox{\hyperlink{namespacenumpy_1_1__utils_ab6d0f0797399f170792ecdf4b908b29d}{\+\_\+rename\+\_\+parameter}} (old\+\_\+names, new\+\_\+names, dep\+\_\+version=None)
\end{DoxyCompactItemize}


\doxysubsection{Description détaillée}
\begin{DoxyVerb}This is a module for defining private helpers which do not depend on the
rest of NumPy.

Everything in here must be self-contained so that it can be
imported anywhere else without creating circular imports.
If a utility requires the import of NumPy, it probably belongs
in ``numpy._core``.
\end{DoxyVerb}
 

\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacenumpy_1_1__utils_ab6d0f0797399f170792ecdf4b908b29d}\label{namespacenumpy_1_1__utils_ab6d0f0797399f170792ecdf4b908b29d} 
\index{numpy.\_utils@{numpy.\_utils}!\_rename\_parameter@{\_rename\_parameter}}
\index{\_rename\_parameter@{\_rename\_parameter}!numpy.\_utils@{numpy.\_utils}}
\doxysubsubsection{\texorpdfstring{\_rename\_parameter()}{\_rename\_parameter()}}
{\footnotesize\ttfamily numpy.\+\_\+utils.\+\_\+rename\+\_\+parameter (\begin{DoxyParamCaption}\item[{}]{old\+\_\+names,  }\item[{}]{new\+\_\+names,  }\item[{}]{dep\+\_\+version = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Generate decorator for backward-compatible keyword renaming.

Apply the decorator generated by `_rename_parameter` to functions with a
renamed parameter to maintain backward-compatibility.

After decoration, the function behaves as follows:
If only the new parameter is passed into the function, behave as usual.
If only the old parameter is passed into the function (as a keyword), raise
a DeprecationWarning if `dep_version` is provided, and behave as usual
otherwise.
If both old and new parameters are passed into the function, raise a
DeprecationWarning if `dep_version` is provided, and raise the appropriate
TypeError (function got multiple values for argument).

Parameters
----------
old_names : list of str
    Old names of parameters
new_name : list of str
    New names of parameters
dep_version : str, optional
    Version of NumPy in which old parameter was deprecated in the format
    'X.Y.Z'. If supplied, the deprecation message will indicate that
    support for the old parameter will be removed in version 'X.Y+2.Z'

Notes
-----
Untested with functions that accept *args. Probably won't work as written.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1__utils_a7c03c558340628601ca938d96ded1459}\label{namespacenumpy_1_1__utils_a7c03c558340628601ca938d96ded1459} 
\index{numpy.\_utils@{numpy.\_utils}!set\_module@{set\_module}}
\index{set\_module@{set\_module}!numpy.\_utils@{numpy.\_utils}}
\doxysubsubsection{\texorpdfstring{set\_module()}{set\_module()}}
{\footnotesize\ttfamily numpy.\+\_\+utils.\+set\+\_\+module (\begin{DoxyParamCaption}\item[{}]{module }\end{DoxyParamCaption})}

\begin{DoxyVerb}Private decorator for overriding __module__ on a function or class.

Example usage::

    @set_module('numpy')
    def example():
        pass

    assert example.__module__ == 'numpy'
\end{DoxyVerb}
 