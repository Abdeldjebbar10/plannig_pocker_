\doxysection{Référence de la classe pandas.\+core.\+groupby.\+groupby.\+Group\+By}
\hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy}{}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy}\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}


Graphe d\textquotesingle{}héritage de pandas.\+core.\+groupby.\+groupby.\+Group\+By\+:
% FIG 0


Graphe de collaboration de pandas.\+core.\+groupby.\+groupby.\+Group\+By\+:
% FIG 1
\doxysubsubsection*{Fonctions membres publiques}
\begin{DoxyCompactItemize}
\item 
None \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac164431296ab1ba360692d0bf2c0f701}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1e8befeb0c9e7da25600d0119af3f726}{obj}}, \mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a34ab6708bf412008a6c49f719c219280}{\+\_\+\+Keys\+Arg\+Type}}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab885b4c07c7081d8f3bd8bfd51d9cad5}{keys}}=None, Axis \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=0, Index\+Label\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a2a5c3daddc0cd71d53ae1703376ba230}{level}}=None, \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1ops_1_1BaseGrouper}{ops.\+Base\+Grouper}}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_adf4d053fd1818e6c37fdbac7960e413c}{grouper}}=None, frozenset\mbox{[}Hashable\mbox{]}\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aba8874c98a4d0fc618ae3ab735d83798}{exclusions}}=None, Index\+Label\texorpdfstring{$\vert$}{|}None selection=None, bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a95f69def69abf91e4ed27e2f215b6645}{as\+\_\+index}}=True, bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa716330d6113b7f0d85e594d84f7c83a}{sort}}=True, bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae43cf53a5fc86038b9ae1fcb50353232}{group\+\_\+keys}}=True, bool\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aad235e29e75ce0c2ea71fc58f3833d4a}{observed}}=lib.\+no\+\_\+default, bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b}{dropna}}=True)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a75caced3d083bf6a25e21388c79b8d76}{\+\_\+\+\_\+getattr\+\_\+\+\_\+}} (self, str attr)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6bcea37a3ca4c0b83a4e7c2a1f4b9744}{apply}} (self, func, \texorpdfstring{$\ast$}{*}args, bool include\+\_\+groups=True, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a73fd9629a7a95bba63fbc8a316e56285}{any}} (self, bool skipna=True)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aca41dcd2ed47e3cab8a37d9b2abc48e3}{all}} (self, bool skipna=True)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7f0e94b2416991aed9f5aef0be1ea312}{count}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a611f23bf2f5e21f4a67e62d9ba6ebcb5}{mean}} (self, bool numeric\+\_\+only=False, Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]}\texorpdfstring{$\vert$}{|}None engine=None, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a02f26506b761b85cf5a659e6290d0340}{median}} (self, bool numeric\+\_\+only=False)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a21cf38606b1d5338a7ab53b178aa37b7}{std}} (self, int ddof=1, Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]}\texorpdfstring{$\vert$}{|}None engine=None, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs=None, bool numeric\+\_\+only=False)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abd6b28389b3b4bf68c653584b5b9cf40}{var}} (self, int ddof=1, Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]}\texorpdfstring{$\vert$}{|}None engine=None, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs=None, bool numeric\+\_\+only=False)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a79dfaada8852dd9a162c36f3f2d337df}{sem}} (self, int ddof=1, bool numeric\+\_\+only=False)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abf144a9cf62fed56f15f1cfb77c0a263}{size}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a970ace20f19e971b994a524aa3ea573b}{sum}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=0, Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]}\texorpdfstring{$\vert$}{|}None engine=None, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3e25432aa1d26ffff1ff750b429921a9}{prod}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=0)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3d94cb5acc8878d012d80c011e9f3f1f}{min}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=-\/1, Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]}\texorpdfstring{$\vert$}{|}None engine=None, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_afec4751663c1bf22bf6bf86305add2bf}{max}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=-\/1, Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]}\texorpdfstring{$\vert$}{|}None engine=None, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa4f603ee61ca1ef93eeba79e15055cbb}{first}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=-\/1, bool skipna=True)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7d8671d55ee9869aeabaef211ee56ee7}{last}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=-\/1, bool skipna=True)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a94e9ea883682f3e31624abd0170195a3}{ohlc}} (self)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a691cad5575e341a6867e679b32413b7d}{describe}} (self, percentiles=None, include=None, exclude=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1resample_1_1Resampler}{Resampler}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9fa6cf1d59c6530b5a4ad46a6dc49c59}{resample}} (self, rule, \texorpdfstring{$\ast$}{*}args, bool include\+\_\+groups=True, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1window_1_1rolling_1_1RollingGroupby}{Rolling\+Groupby}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad123d631afc14e83b31e7384cbd4a158}{rolling}} (self, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1window_1_1expanding_1_1ExpandingGroupby}{Expanding\+Groupby}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a5a310c9e138f254a8dc75b9b00fac63e}{expanding}} (self, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1window_1_1ewm_1_1ExponentialMovingWindowGroupby}{Exponential\+Moving\+Window\+Groupby}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aaa2aca5c66474b38ec1460b90c787568}{ewm}} (self, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9e7e76c9dc33352a0255fab4e598cc81}{ffill}} (self, int\texorpdfstring{$\vert$}{|}None limit=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a14c659c128cac8ea33f9cf57dded2367}{bfill}} (self, int\texorpdfstring{$\vert$}{|}None limit=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByNthSelector}{Group\+By\+Nth\+Selector}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a99dc3aa9708151309c8e76d075ae458a}{nth}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9819ede86250c9fd6cce0e172ccd7b9a}{quantile}} (self, float\texorpdfstring{$\vert$}{|}Any\+Array\+Like q=0.\+5, str interpolation="{}linear"{}, bool numeric\+\_\+only=False)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a4e0ab5f350005e94a5ff7a77874a9bde}{ngroup}} (self, bool ascending=True)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab69f343f46d328e9ff7f92c48167bd9d}{cumcount}} (self, bool ascending=True)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a0afbc40de210d1495a3bf44500e5fe60}{rank}} (self, str method="{}average"{}, bool ascending=True, str na\+\_\+option="{}keep"{}, bool pct=False, Axis\+Int\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a109b04b5da99f009f7f006e86355993b}{cumprod}} (self, Axis\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7e486417e2947badfc8f701822ae8d48}{cumsum}} (self, Axis\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa43d4059428ff9fed536e22b1602248b}{cummin}} (self, Axis\+Int\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default, bool numeric\+\_\+only=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9d03c29e3aff9f5c2e8cb93bf373777d}{cummax}} (self, Axis\+Int\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default, bool numeric\+\_\+only=False, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a16a698ffcaddfef306e4d1642ec4c982}{shift}} (self, int\texorpdfstring{$\vert$}{|}Sequence\mbox{[}int\mbox{]} periods=1, freq=None, Axis\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default, fill\+\_\+value=lib.\+no\+\_\+default, str\texorpdfstring{$\vert$}{|}None suffix=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9ffc3376f8eb8fe016943c7366f97673}{diff}} (self, int periods=1, Axis\+Int\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac005afcdce65181c3ee8c745b76954ab}{pct\+\_\+change}} (self, int periods=1, Fillna\+Options\texorpdfstring{$\vert$}{|}None\texorpdfstring{$\vert$}{|}lib.\+No\+Default fill\+\_\+method=lib.\+no\+\_\+default, int\texorpdfstring{$\vert$}{|}None\texorpdfstring{$\vert$}{|}lib.\+No\+Default limit=lib.\+no\+\_\+default, freq=None, Axis\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a78f1160675cd14ffa2152d7892ed0408}{head}} (self, int n=5)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a763a9595f945252ec15615cf0165dc26}{tail}} (self, int n=5)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a36848017b67bb140e005f24888fb9fc1}{sample}} (self, int\texorpdfstring{$\vert$}{|}None n=None, float\texorpdfstring{$\vert$}{|}None frac=None, bool replace=False, Sequence\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}}\texorpdfstring{$\vert$}{|}None weights=None, Random\+State\texorpdfstring{$\vert$}{|}None random\+\_\+state=None)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres publiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy}{pandas.\+core.\+groupby.\+groupby.\+Base\+Group\+By}}}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a8337410d52f544362ee647ab1a502b01}{\+\_\+\+\_\+len\+\_\+\+\_\+}} (self)
\item 
str \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a8b952c92d9fdda32cdcd7b6db3eb3fa8}{\+\_\+\+\_\+repr\+\_\+\+\_\+}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1ops_1_1BaseGrouper}{ops.\+Base\+Grouper}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_adf4d053fd1818e6c37fdbac7960e413c}{grouper}} (self)
\item 
dict\mbox{[}Hashable, np.\+ndarray\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a4bd0a55d97fcab26f8df25e67e9bea0b}{groups}} (self)
\item 
int \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a10aae1b1de1e558515d979282899845c}{ngroups}} (self)
\item 
dict\mbox{[}Hashable, npt.\+NDArray\mbox{[}np.\+intp\mbox{]}\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a69170c122250520eae9635882820c3d3}{indices}} (self)
\item 
T \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a9f305e6758cd10d99d0389bf68b45011}{pipe}} (self, Callable\mbox{[}..., T\mbox{]}\texorpdfstring{$\vert$}{|}tuple\mbox{[}Callable\mbox{[}..., T\mbox{]}, str\mbox{]} func, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_af91fe7eafca224e3204260639512406d}{get\+\_\+group}} (self, name, \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_aac4094c67077964fa95bb915942d224c}{obj}}=None)
\item 
Iterator\mbox{[}tuple\mbox{[}Hashable, NDFrameT\mbox{]}\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a9e47304f229dd92531696371b9be253e}{\+\_\+\+\_\+iter\+\_\+\+\_\+}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres publiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject}{pandas.\+core.\+base.\+Pandas\+Object}}}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject_ad5b15e942fb2d2dcfb12fa1667404aeb}{\+\_\+\+\_\+sizeof\+\_\+\+\_\+}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres publiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin}{pandas.\+core.\+accessor.\+Dir\+Names\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
list\mbox{[}str\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin_ac86361dc5b262c58dcdf818d410136e4}{\+\_\+\+\_\+dir\+\_\+\+\_\+}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres publiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin}{pandas.\+core.\+base.\+Selection\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae71168779b11e49ff704d8e1252625ba}{ndim}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_aad3c986de316f6c45ec1d2f161b001a1}{\+\_\+\+\_\+getitem\+\_\+\+\_\+}} (self, key)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae485d4e476e4284dee050eb5245f4862}{aggregate}} (self, func, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\end{DoxyCompactItemize}
\doxysubsubsection*{Attributs publics}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a2a5c3daddc0cd71d53ae1703376ba230}{level}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a92fb589411ebb1a7c1a8babfe74987d1}{as\+\_\+index}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab885b4c07c7081d8f3bd8bfd51d9cad5}{keys}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa716330d6113b7f0d85e594d84f7c83a}{sort}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae43cf53a5fc86038b9ae1fcb50353232}{group\+\_\+keys}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b}{dropna}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aad235e29e75ce0c2ea71fc58f3833d4a}{observed}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1e8befeb0c9e7da25600d0119af3f726}{obj}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aba8874c98a4d0fc618ae3ab735d83798}{exclusions}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs publics hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy}{pandas.\+core.\+groupby.\+groupby.\+Base\+Group\+By}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a8cd00befecc935b7ab0c04017fa5f4a7}{groups}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a382def7764ebcaf70d26e83645db0e59}{indices}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_aac4094c67077964fa95bb915942d224c}{obj}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs publics hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin}{pandas.\+core.\+base.\+Selection\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a5207a79fc68d7810cc3a907a49eaf556}{obj}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a740e931e362229a193cc2b827ac039e7}{exclusions}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Attributs publics statiques}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a95f69def69abf91e4ed27e2f215b6645}{as\+\_\+index}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs publics statiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy}{pandas.\+core.\+groupby.\+groupby.\+Base\+Group\+By}}}
\begin{DoxyCompactItemize}
\item 
Axis\+Int \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_ad7c87829c4f7e644366e65163289ad63}{axis}}
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a34ab6708bf412008a6c49f719c219280}{\+\_\+\+Keys\+Arg\+Type}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a03ac204416264c8e1af84f43300bba61}{keys}} = None
\item 
Index\+Label \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a37f1cb20ca08f02bc9e136da76182383}{level}} = None
\item 
bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_ad6a78667f6d1b18a9ea35fd12c878380}{group\+\_\+keys}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs publics statiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin}{pandas.\+core.\+base.\+Selection\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a35b32ba83d07b2d612b80a3bb8b54c40}{obj}}
\item 
frozenset \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a1eee2f6959c9fcab6d8b57d166c81d45}{exclusions}} \mbox{[}Hashable\mbox{]}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a1f3539bc11e3abeff5e0f5a31bfbc5c7}{agg}} = \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae485d4e476e4284dee050eb5245f4862}{aggregate}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Fonctions membres protégées}
\begin{DoxyCompactItemize}
\item 
None \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1f20ab360419a07d88c40b81f0398827}{\+\_\+deprecate\+\_\+axis}} (self, int \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}, str name)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a72b9a62e096abdbf12a81633c23d9292}{\+\_\+op\+\_\+via\+\_\+apply}} (self, str name, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad312d52db44b54cac6d83eb6467c4562}{\+\_\+concat\+\_\+objects}} (self, values, bool not\+\_\+indexed\+\_\+same=False, bool is\+\_\+transform=False)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad3d6b6af581a5671c827e89968aa0538}{\+\_\+set\+\_\+result\+\_\+index\+\_\+ordered}} (self, \mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}} result)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_af78975a6b57d94558db93c2e5c67c627}{\+\_\+insert\+\_\+inaxis\+\_\+grouper}} (self, \mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}}\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} result)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3580ad0b16f1fe278091b5a3a89201e6}{\+\_\+maybe\+\_\+transpose\+\_\+result}} (self, NDFrameT result)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac845ecee25a3e49b6a36681e91df42f5}{\+\_\+wrap\+\_\+aggregated\+\_\+output}} (self, \mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}}\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} result, npt.\+NDArray\mbox{[}np.\+float64\mbox{]}\texorpdfstring{$\vert$}{|}None qs=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a34334f407c47419139f34fbb98738f0c}{\+\_\+wrap\+\_\+applied\+\_\+output}} (self, data, list values, bool not\+\_\+indexed\+\_\+same=False, bool is\+\_\+transform=False)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27bdd4706a37e68eca785a0d4c3e86b3}{\+\_\+numba\+\_\+prep}} (self, \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} data)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aca46c624a93f4db0a2eca86beb4b8f1a}{\+\_\+numba\+\_\+agg\+\_\+general}} (self, Callable func, dict\mbox{[}np.\+dtype, Any\mbox{]} dtype\+\_\+mapping, dict\mbox{[}str, bool\mbox{]}\texorpdfstring{$\vert$}{|}None engine\+\_\+kwargs, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}aggregator\+\_\+kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae500369e1489cda366dc97eab8a81891}{\+\_\+transform\+\_\+with\+\_\+numba}} (self, func, \texorpdfstring{$\ast$}{*}args, engine\+\_\+kwargs=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abb41996bf2d181e5ae2f5e92e46fb21b}{\+\_\+aggregate\+\_\+with\+\_\+numba}} (self, func, \texorpdfstring{$\ast$}{*}args, engine\+\_\+kwargs=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a70b26dccbffe8fc844cec39230938a94}{\+\_\+python\+\_\+apply\+\_\+general}} (self, Callable f, \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} data, bool\texorpdfstring{$\vert$}{|}None not\+\_\+indexed\+\_\+same=None, bool is\+\_\+transform=False, bool is\+\_\+agg=False)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a33c97b677d9228eac2291cd79da198af}{\+\_\+agg\+\_\+general}} (self, bool numeric\+\_\+only=False, int min\+\_\+count=-\/1, \texorpdfstring{$\ast$}{*}str alias, Callable\texorpdfstring{$\vert$}{|}None npfunc=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
Array\+Like \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a937f5de09213ac6b10bf55989371fae1}{\+\_\+agg\+\_\+py\+\_\+fallback}} (self, str how, Array\+Like values, int \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae71168779b11e49ff704d8e1252625ba}{ndim}}, Callable alt)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a89892ce5a378c156e3ca074ba3b00ac5}{\+\_\+cython\+\_\+agg\+\_\+general}} (self, str how, Callable\texorpdfstring{$\vert$}{|}None alt=None, bool numeric\+\_\+only=False, int min\+\_\+count=-\/1, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a15c132c7cddffb4d75c6579c2df12b79}{\+\_\+cython\+\_\+transform}} (self, str how, bool numeric\+\_\+only=False, Axis\+Int \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=0, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6091d4c7f024ed33ef4d07b06cead74a}{\+\_\+transform}} (self, func, \texorpdfstring{$\ast$}{*}args, engine=None, engine\+\_\+kwargs=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a81fd76cecac1af72652720dd31b8f64c}{\+\_\+wrap\+\_\+transform\+\_\+fast\+\_\+result}} (self, NDFrameT result)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9dcc837b955e5cc03775a395cdcff47a}{\+\_\+apply\+\_\+filter}} (self, \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a382def7764ebcaf70d26e83645db0e59}{indices}}, \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b}{dropna}})
\item 
np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab9680888ef1890f81ef62ea64a0df555}{\+\_\+cumcount\+\_\+array}} (self, bool ascending=True)
\item 
Callable \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3cb43e78db5c44635a0e3143192e6833}{\+\_\+obj\+\_\+1d\+\_\+constructor}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a983afa84395ff237cf723d6c120103f6}{\+\_\+value\+\_\+counts}} (self, Sequence\mbox{[}Hashable\mbox{]}\texorpdfstring{$\vert$}{|}None subset=None, bool normalize=False, bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa716330d6113b7f0d85e594d84f7c83a}{sort}}=True, bool ascending=False, bool \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b}{dropna}}=True)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3bf0245827f2dbad3109b6b63e0d4a0e}{\+\_\+fill}} (self, Literal\mbox{[}"{}ffill"{}, "{}bfill"{}\mbox{]} direction, int\texorpdfstring{$\vert$}{|}None limit=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a8d39b4286e3f16112113159820c2d471}{\+\_\+nth}} (self, Positional\+Indexer\texorpdfstring{$\vert$}{|}tuple n, Literal\mbox{[}"{}any"{}, "{}all"{}, None\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b}{dropna}}=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae444b9f5016c2439cf1662f905d66d64}{\+\_\+mask\+\_\+selected\+\_\+obj}} (self, npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]} mask)
\item 
\mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_acd442a6de72bcf2cbf5f43c591a4fc32}{\+\_\+reindex\+\_\+output}} (self, \mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}} output, Scalar fill\+\_\+value=np.\+nan, npt.\+NDArray\mbox{[}np.\+float64\mbox{]}\texorpdfstring{$\vert$}{|}None qs=None)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a0f8e235a100be38277ca12b66b16cee2}{\+\_\+idxmax\+\_\+idxmin}} (self, Literal\mbox{[}"{}idxmax"{}, "{}idxmin"{}\mbox{]} how, bool ignore\+\_\+unobserved=False, Axis\texorpdfstring{$\vert$}{|}None\texorpdfstring{$\vert$}{|}lib.\+No\+Default \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}{axis}}=lib.\+no\+\_\+default, bool skipna=True, bool numeric\+\_\+only=False)
\item 
NDFrameT \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a305bc35873d837f9a74465c961f8f200}{\+\_\+wrap\+\_\+idxmax\+\_\+idxmin}} (self, NDFrameT res)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres protégées hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy}{pandas.\+core.\+groupby.\+groupby.\+Base\+Group\+By}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_accd950a40bfd15bc8696bf3a9ca76f38}{\+\_\+get\+\_\+indices}} (self, names)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a3542def8e404156a3457e499c8583842}{\+\_\+get\+\_\+index}} (self, name)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_aa8d7f37c3e7e01e9a624bfcdb9ca795f}{\+\_\+selected\+\_\+obj}} (self)
\item 
set\mbox{[}str\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_ad7cad65657392c7742cfa69fdb2fadbb}{\+\_\+dir\+\_\+additions}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres protégées hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject}{pandas.\+core.\+base.\+Pandas\+Object}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject_a7b5112b72a8bafe13b1fa732bf1ea30d}{\+\_\+constructor}} (self)
\item 
None \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject_a8a2b95a9e1e4befc5ad3cba09c3f3e68}{\+\_\+reset\+\_\+cache}} (self, str\texorpdfstring{$\vert$}{|}None key=None)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres protégées hérités de \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin}{pandas.\+core.\+accessor.\+Dir\+Names\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
set\mbox{[}str\mbox{]} \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin_a3151f76f1b53042e9d13da3d3ef3cb92}{\+\_\+dir\+\_\+deletions}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres protégées hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin}{pandas.\+core.\+base.\+Selection\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a84ab5b21406fb07629293d56ffc9f98a}{\+\_\+selection\+\_\+list}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_acd6785b162f9f2a0f0a8a279201346db}{\+\_\+obj\+\_\+with\+\_\+exclusions}} (self)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a9f3d118b3cd8f40293932a1487962d18}{\+\_\+gotitem}} (self, key, int \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae71168779b11e49ff704d8e1252625ba}{ndim}}, subset=None)
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ad1591a6bbb00dfcef714413e1389278c}{\+\_\+infer\+\_\+selection}} (self, key, Series\texorpdfstring{$\vert$}{|}Data\+Frame subset)
\end{DoxyCompactItemize}
\doxysubsection*{Fonctions membres protégées hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin}{pandas.\+core.\+groupby.\+indexing.\+Group\+By\+Indexing\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByPositionalSelector}{Group\+By\+Positional\+Selector}} \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a8058dd6f140a9da6b0f02e823cce9159}{\+\_\+positional\+\_\+selector}} (self)
\item 
np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a1544259469e017dd36d79d395ed5f15e}{\+\_\+make\+\_\+mask\+\_\+from\+\_\+positional\+\_\+indexer}} (self, Positional\+Indexer\texorpdfstring{$\vert$}{|}tuple arg)
\item 
np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a919beb972b6e2651679c1ab45f0d0f63}{\+\_\+make\+\_\+mask\+\_\+from\+\_\+int}} (self, int arg)
\item 
bool\texorpdfstring{$\vert$}{|}np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a1d0259da6f314c77dd123353e9812c97}{\+\_\+make\+\_\+mask\+\_\+from\+\_\+list}} (self, Iterable\mbox{[}int\mbox{]} args)
\item 
bool\texorpdfstring{$\vert$}{|}np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a6fd469858a37bce644e9d3beafbe7ff1}{\+\_\+make\+\_\+mask\+\_\+from\+\_\+tuple}} (self, tuple args)
\item 
bool\texorpdfstring{$\vert$}{|}np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a3816900101ed8903025bb3c5e4e29f1a}{\+\_\+make\+\_\+mask\+\_\+from\+\_\+slice}} (self, slice arg)
\item 
np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_aea8a626dbf481c3b532e4479cb8b040c}{\+\_\+ascending\+\_\+count}} (self)
\item 
np.\+ndarray \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_aad474a847bbcdd0cadf7ca3edce7bcbb}{\+\_\+descending\+\_\+count}} (self)
\end{DoxyCompactItemize}
\doxysubsubsection*{Attributs protégés}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a91472f24fd5afcc07a81edd04b4a5328}{\+\_\+selection}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_adc71fe58ebe188cc6b6d8ff627ecddba}{\+\_\+grouper}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6e9c3764acd40f62b4463bf8aa235190}{\+\_\+selected\+\_\+obj}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a8ece12e82ff5f534105bb530a9ab8d7b}{\+\_\+obj\+\_\+with\+\_\+exclusions}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy}{pandas.\+core.\+groupby.\+groupby.\+Base\+Group\+By}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a88200cadb55a17f5cfbb144b228762f7}{\+\_\+selection}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin}{pandas.\+core.\+base.\+Selection\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a4b377ecea0956413cc4e45a77d887ac5}{\+\_\+selection}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a8690d2c7cd02cf083a1e6bafa899eab6}{\+\_\+selection\+\_\+list}}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin}{pandas.\+core.\+groupby.\+indexing.\+Group\+By\+Indexing\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a783cac517cedcd04929c9306b10f99f7}{\+\_\+ascending\+\_\+count}}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByIndexingMixin_a9035f1c6ded6d3a8a4be99f8bcdc819e}{\+\_\+descending\+\_\+count}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Attributs protégés statiques}
\begin{DoxyCompactItemize}
\item 
ops \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a19a910c3e7ac812793052b0590270f02}{\+\_\+grouper}} .Base\+Grouper
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés statiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy}{pandas.\+core.\+groupby.\+groupby.\+Base\+Group\+By}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a792c142e01aa4fc5640ed6e0211d3c5f}{\+\_\+hidden\+\_\+attrs}}
\item 
ops \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1groupby_1_1BaseGroupBy_a40f94745c7c0b54221efcb23f6c5de5c}{\+\_\+grouper}} .Base\+Grouper
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés statiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject}{pandas.\+core.\+base.\+Pandas\+Object}}}
\begin{DoxyCompactItemize}
\item 
dict \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1PandasObject_a3972565a4ab5ff072118eda20364cd2c}{\+\_\+cache}} \mbox{[}str, Any\mbox{]}
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés statiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin}{pandas.\+core.\+accessor.\+Dir\+Names\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
set \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin_a1e3f9f50e3532c77c3610c4b8fe27e6f}{\+\_\+accessors}} = set()
\item 
frozenset \mbox{\hyperlink{classpandas_1_1core_1_1accessor_1_1DirNamesMixin_a7b9c1894b79d330020bdc71ddc7126f0}{\+\_\+hidden\+\_\+attrs}} = frozenset()
\end{DoxyCompactItemize}
\doxysubsection*{Attributs protégés statiques hérités de \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin}{pandas.\+core.\+base.\+Selection\+Mixin}}}
\begin{DoxyCompactItemize}
\item 
Index\+Label \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_aa329bea9aae5a514a109fd19b39e4d51}{\+\_\+selection}} = None
\item 
list \mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae5fff6c63df1250ed6784ad633fe03f4}{\+\_\+internal\+\_\+names}} = \mbox{[}"{}\+\_\+cache"{}, "{}\+\_\+\+\_\+setstate\+\_\+\+\_\+"{}\mbox{]}
\item 
\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_a4df1b01fd09955430d448bf0a173a2f5}{\+\_\+internal\+\_\+names\+\_\+set}} = set(\mbox{\hyperlink{classpandas_1_1core_1_1base_1_1SelectionMixin_ae5fff6c63df1250ed6784ad633fe03f4}{\+\_\+internal\+\_\+names}})
\end{DoxyCompactItemize}


\doxysubsection{Description détaillée}
\begin{DoxyVerb}Class for grouping and aggregating relational data.

See aggregate, transform, and apply functions on this object.

It's easiest to use obj.groupby(...) to use GroupBy, but you can also do:

::

    grouped = groupby(obj, ...)

Parameters
----------
obj : pandas object
axis : int, default 0
level : int, default None
    Level of MultiIndex
groupings : list of Grouping objects
    Most users should ignore this
exclusions : array-like, optional
    List of columns to exclude
name : str
    Most users should ignore this

Returns
-------
**Attributes**
groups : dict
    {group name -> group labels}
len(grouped) : int
    Number of groups

Notes
-----
After grouping, see aggregate, apply, and transform functions. Here are
some other brief notes about usage. When grouping by multiple groups, the
result index will be a MultiIndex (hierarchical) by default.

Iteration produces (key, group) tuples, i.e. chunking the data by group. So
you can write code like:

::

    grouped = obj.groupby(keys, axis=axis)
    for key, group in grouped:
        # do something with the data

Function calls on GroupBy, if not specially implemented, "dispatch" to the
grouped data. So if you group a DataFrame and wish to invoke the std()
method on each group, you can simply do:

::

    df.groupby(mapper).std()

rather than

::

    df.groupby(mapper).aggregate(np.std)

You can pass arguments to these "wrapped" functions, too.

See the online documentation for full exposition on these topics and much
more
\end{DoxyVerb}
 

\doxysubsection{Documentation des constructeurs et destructeur}
\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac164431296ab1ba360692d0bf2c0f701}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac164431296ab1ba360692d0bf2c0f701} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily  None pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{NDFrameT}]{obj,  }\item[{\mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a34ab6708bf412008a6c49f719c219280}{\+\_\+\+Keys\+Arg\+Type}} \texorpdfstring{$\vert$}{|} None }]{keys = {\ttfamily None},  }\item[{Axis }]{axis = {\ttfamily 0},  }\item[{Index\+Label \texorpdfstring{$\vert$}{|} None }]{level = {\ttfamily None},  }\item[{\mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1ops_1_1BaseGrouper}{ops.\+Base\+Grouper}} \texorpdfstring{$\vert$}{|} None }]{grouper = {\ttfamily None},  }\item[{frozenset\mbox{[}Hashable\mbox{]} \texorpdfstring{$\vert$}{|} None }]{exclusions = {\ttfamily None},  }\item[{Index\+Label \texorpdfstring{$\vert$}{|} None }]{selection = {\ttfamily None},  }\item[{bool }]{as\+\_\+index = {\ttfamily True},  }\item[{bool }]{sort = {\ttfamily True},  }\item[{bool }]{group\+\_\+keys = {\ttfamily True},  }\item[{bool \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{observed = {\ttfamily lib.no\+\_\+default},  }\item[{bool }]{dropna = {\ttfamily True} }\end{DoxyParamCaption})}



\doxysubsection{Documentation des fonctions membres}
\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a75caced3d083bf6a25e21388c79b8d76}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a75caced3d083bf6a25e21388c79b8d76} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_\_getattr\_\_@{\_\_getattr\_\_}}
\index{\_\_getattr\_\_@{\_\_getattr\_\_}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_\_getattr\_\_()}{\_\_getattr\_\_()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+\+\_\+getattr\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{str}]{attr }\end{DoxyParamCaption})}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a33c97b677d9228eac2291cd79da198af}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a33c97b677d9228eac2291cd79da198af} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_agg\_general@{\_agg\_general}}
\index{\_agg\_general@{\_agg\_general}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_agg\_general()}{\_agg\_general()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+agg\+\_\+general (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily -\/1},  }\item[{\texorpdfstring{$\ast$}{*}str}]{alias,  }\item[{Callable \texorpdfstring{$\vert$}{|} None }]{npfunc = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a937f5de09213ac6b10bf55989371fae1}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a937f5de09213ac6b10bf55989371fae1} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_agg\_py\_fallback@{\_agg\_py\_fallback}}
\index{\_agg\_py\_fallback@{\_agg\_py\_fallback}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_agg\_py\_fallback()}{\_agg\_py\_fallback()}}
{\footnotesize\ttfamily  Array\+Like pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+agg\+\_\+py\+\_\+fallback (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{str}]{how,  }\item[{Array\+Like}]{values,  }\item[{int}]{ndim,  }\item[{Callable     }]{alt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Fallback to pure-python aggregation if _cython_operation raises
NotImplementedError.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abb41996bf2d181e5ae2f5e92e46fb21b}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abb41996bf2d181e5ae2f5e92e46fb21b} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_aggregate\_with\_numba@{\_aggregate\_with\_numba}}
\index{\_aggregate\_with\_numba@{\_aggregate\_with\_numba}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_aggregate\_with\_numba()}{\_aggregate\_with\_numba()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+aggregate\+\_\+with\+\_\+numba (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{func,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{}]{engine\+\_\+kwargs = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Perform groupby aggregation routine with the numba engine.

This routine mimics the data splitting routine of the DataSplitter class
to generate the indices of each group in the sorted data and then passes the
data and indices into a Numba jitted function.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9dcc837b955e5cc03775a395cdcff47a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9dcc837b955e5cc03775a395cdcff47a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_apply\_filter@{\_apply\_filter}}
\index{\_apply\_filter@{\_apply\_filter}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_apply\_filter()}{\_apply\_filter()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+apply\+\_\+filter (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{indices,  }\item[{}]{dropna }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad312d52db44b54cac6d83eb6467c4562}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad312d52db44b54cac6d83eb6467c4562} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_concat\_objects@{\_concat\_objects}}
\index{\_concat\_objects@{\_concat\_objects}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_concat\_objects()}{\_concat\_objects()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+concat\+\_\+objects (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{values,  }\item[{bool }]{not\+\_\+indexed\+\_\+same = {\ttfamily False},  }\item[{bool }]{is\+\_\+transform = {\ttfamily False} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab9680888ef1890f81ef62ea64a0df555}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab9680888ef1890f81ef62ea64a0df555} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_cumcount\_array@{\_cumcount\_array}}
\index{\_cumcount\_array@{\_cumcount\_array}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_cumcount\_array()}{\_cumcount\_array()}}
{\footnotesize\ttfamily  np.\+ndarray pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+cumcount\+\_\+array (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{ascending = {\ttfamily True} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Parameters
----------
ascending : bool, default True
    If False, number in reverse, from length of group - 1 to 0.

Notes
-----
this is currently implementing sort=False
(though the default is sort=True) for groupby in general
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a89892ce5a378c156e3ca074ba3b00ac5}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a89892ce5a378c156e3ca074ba3b00ac5} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_cython\_agg\_general@{\_cython\_agg\_general}}
\index{\_cython\_agg\_general@{\_cython\_agg\_general}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_cython\_agg\_general()}{\_cython\_agg\_general()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+cython\+\_\+agg\+\_\+general (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{str}]{how,  }\item[{Callable \texorpdfstring{$\vert$}{|} None }]{alt = {\ttfamily None},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily -\/1},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a15c132c7cddffb4d75c6579c2df12b79}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a15c132c7cddffb4d75c6579c2df12b79} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_cython\_transform@{\_cython\_transform}}
\index{\_cython\_transform@{\_cython\_transform}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_cython\_transform()}{\_cython\_transform()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+cython\+\_\+transform (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{str}]{how,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{Axis\+Int }]{axis = {\ttfamily 0},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Réimplémentée dans \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1generic_1_1SeriesGroupBy_a2fea2cb0a323998bb7cc37e8bc3e6211}{pandas.\+core.\+groupby.\+generic.\+Series\+Group\+By}}, et \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1generic_1_1DataFrameGroupBy_a185bec1cd3eea61bc721b47f69b4b61c}{pandas.\+core.\+groupby.\+generic.\+Data\+Frame\+Group\+By}}.

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1f20ab360419a07d88c40b81f0398827}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1f20ab360419a07d88c40b81f0398827} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_deprecate\_axis@{\_deprecate\_axis}}
\index{\_deprecate\_axis@{\_deprecate\_axis}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_deprecate\_axis()}{\_deprecate\_axis()}}
{\footnotesize\ttfamily  None pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+deprecate\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int}]{axis,  }\item[{str}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3bf0245827f2dbad3109b6b63e0d4a0e}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3bf0245827f2dbad3109b6b63e0d4a0e} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_fill@{\_fill}}
\index{\_fill@{\_fill}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_fill()}{\_fill()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+fill (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Literal\mbox{[}"{}ffill"{}, "{}bfill"{}\mbox{]}}]{direction,  }\item[{int \texorpdfstring{$\vert$}{|} None }]{limit = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Shared function for `pad` and `backfill` to call Cython method.

Parameters
----------
direction : {'ffill', 'bfill'}
    Direction passed to underlying Cython function. `bfill` will cause
    values to be filled backwards. `ffill` and any other values will
    default to a forward fill
limit : int, default None
    Maximum number of consecutive values to fill. If `None`, this
    method will convert to -1 prior to passing to Cython

Returns
-------
`Series` or `DataFrame` with filled values

See Also
--------
pad : Returns Series with minimum number of char in object.
backfill : Backward fill the missing values in the dataset.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a0f8e235a100be38277ca12b66b16cee2}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a0f8e235a100be38277ca12b66b16cee2} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_idxmax\_idxmin@{\_idxmax\_idxmin}}
\index{\_idxmax\_idxmin@{\_idxmax\_idxmin}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_idxmax\_idxmin()}{\_idxmax\_idxmin()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+idxmax\+\_\+idxmin (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Literal\mbox{[}"{}idxmax"{}, "{}idxmin"{}\mbox{]}}]{how,  }\item[{bool }]{ignore\+\_\+unobserved = {\ttfamily False},  }\item[{Axis \texorpdfstring{$\vert$}{|} None \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default},  }\item[{bool }]{skipna = {\ttfamily True},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute idxmax/idxmin.

Parameters
----------
how : {'idxmin', 'idxmax'}
    Whether to compute idxmin or idxmax.
axis : {{0 or 'index', 1 or 'columns'}}, default None
    The axis to use. 0 or 'index' for row-wise, 1 or 'columns' for column-wise.
    If axis is not provided, grouper's axis is used.
numeric_only : bool, default False
    Include only float, int, boolean columns.
skipna : bool, default True
    Exclude NA/null values. If an entire row/column is NA, the result
    will be NA.
ignore_unobserved : bool, default False
    When True and an unobserved group is encountered, do not raise. This used
    for transform where unobserved groups do not play an impact on the result.

Returns
-------
Series or DataFrame
    idxmax or idxmin for the groupby operation.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_af78975a6b57d94558db93c2e5c67c627}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_af78975a6b57d94558db93c2e5c67c627} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_insert\_inaxis\_grouper@{\_insert\_inaxis\_grouper}}
\index{\_insert\_inaxis\_grouper@{\_insert\_inaxis\_grouper}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_insert\_inaxis\_grouper()}{\_insert\_inaxis\_grouper()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+insert\+\_\+inaxis\+\_\+grouper (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae444b9f5016c2439cf1662f905d66d64}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae444b9f5016c2439cf1662f905d66d64} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_mask\_selected\_obj@{\_mask\_selected\_obj}}
\index{\_mask\_selected\_obj@{\_mask\_selected\_obj}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_mask\_selected\_obj()}{\_mask\_selected\_obj()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+mask\+\_\+selected\+\_\+obj (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{npt.\+NDArray\mbox{[}np.\+bool\+\_\+\mbox{]}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Return _selected_obj with mask applied to the correct axis.

Parameters
----------
mask : np.ndarray[bool]
    Boolean mask to apply.

Returns
-------
Series or DataFrame
    Filtered _selected_obj.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3580ad0b16f1fe278091b5a3a89201e6}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3580ad0b16f1fe278091b5a3a89201e6} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_maybe\_transpose\_result@{\_maybe\_transpose\_result}}
\index{\_maybe\_transpose\_result@{\_maybe\_transpose\_result}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_maybe\_transpose\_result()}{\_maybe\_transpose\_result()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+maybe\+\_\+transpose\+\_\+result (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{NDFrameT}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a8d39b4286e3f16112113159820c2d471}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a8d39b4286e3f16112113159820c2d471} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_nth@{\_nth}}
\index{\_nth@{\_nth}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_nth()}{\_nth()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+nth (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Positional\+Indexer \texorpdfstring{$\vert$}{|} tuple}]{n,  }\item[{Literal\mbox{[}"{}any"{}, "{}all"{}, None\mbox{]} }]{dropna = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aca46c624a93f4db0a2eca86beb4b8f1a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aca46c624a93f4db0a2eca86beb4b8f1a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_numba\_agg\_general@{\_numba\_agg\_general}}
\index{\_numba\_agg\_general@{\_numba\_agg\_general}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_numba\_agg\_general()}{\_numba\_agg\_general()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+numba\+\_\+agg\+\_\+general (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Callable}]{func,  }\item[{dict\mbox{[}np.\+dtype, Any\mbox{]}}]{dtype\+\_\+mapping,  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None}]{engine\+\_\+kwargs,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{aggregator\+\_\+kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Perform groupby with a standard numerical aggregation function (e.g. mean)
with Numba.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27bdd4706a37e68eca785a0d4c3e86b3}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27bdd4706a37e68eca785a0d4c3e86b3} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_numba\_prep@{\_numba\_prep}}
\index{\_numba\_prep@{\_numba\_prep}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_numba\_prep()}{\_numba\_prep()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+numba\+\_\+prep (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3cb43e78db5c44635a0e3143192e6833}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3cb43e78db5c44635a0e3143192e6833} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_obj\_1d\_constructor@{\_obj\_1d\_constructor}}
\index{\_obj\_1d\_constructor@{\_obj\_1d\_constructor}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_obj\_1d\_constructor()}{\_obj\_1d\_constructor()}}
{\footnotesize\ttfamily  Callable pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+obj\+\_\+1d\+\_\+constructor (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a72b9a62e096abdbf12a81633c23d9292}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a72b9a62e096abdbf12a81633c23d9292} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_op\_via\_apply@{\_op\_via\_apply}}
\index{\_op\_via\_apply@{\_op\_via\_apply}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_op\_via\_apply()}{\_op\_via\_apply()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+op\+\_\+via\+\_\+apply (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{str}]{name,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Compute the result of an operation by using GroupBy's apply.\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a70b26dccbffe8fc844cec39230938a94}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a70b26dccbffe8fc844cec39230938a94} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_python\_apply\_general@{\_python\_apply\_general}}
\index{\_python\_apply\_general@{\_python\_apply\_general}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_python\_apply\_general()}{\_python\_apply\_general()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+python\+\_\+apply\+\_\+general (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Callable}]{f,  }\item[{\mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}}}]{data,  }\item[{bool \texorpdfstring{$\vert$}{|} None }]{not\+\_\+indexed\+\_\+same = {\ttfamily None},  }\item[{bool }]{is\+\_\+transform = {\ttfamily False},  }\item[{bool }]{is\+\_\+agg = {\ttfamily False} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Apply function f in python space

Parameters
----------
f : callable
    Function to apply
data : Series or DataFrame
    Data to apply f to
not_indexed_same: bool, optional
    When specified, overrides the value of not_indexed_same. Apply behaves
    differently when the result index is equal to the input index, but
    this can be coincidental leading to value-dependent behavior.
is_transform : bool, default False
    Indicator for whether the function is actually a transform
    and should not have group keys prepended.
is_agg : bool, default False
    Indicator for whether the function is an aggregation. When the
    result is empty, we don't want to warn for this case.
    See _GroupBy._python_agg_general.

Returns
-------
Series or DataFrame
    data after applying f
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_acd442a6de72bcf2cbf5f43c591a4fc32}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_acd442a6de72bcf2cbf5f43c591a4fc32} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_reindex\_output@{\_reindex\_output}}
\index{\_reindex\_output@{\_reindex\_output}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_reindex\_output()}{\_reindex\_output()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+reindex\+\_\+output (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}}}]{output,  }\item[{Scalar }]{fill\+\_\+value = {\ttfamily np.nan},  }\item[{npt.\+NDArray\mbox{[}np.\+float64\mbox{]} \texorpdfstring{$\vert$}{|} None }]{qs = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}If we have categorical groupers, then we might want to make sure that
we have a fully re-indexed output to the levels. This means expanding
the output space to accommodate all values in the cartesian product of
our groups, regardless of whether they were observed in the data or
not. This will expand the output space if there are missing groups.

The method returns early without modifying the input if the number of
groupings is less than 2, self.observed == True or none of the groupers
are categorical.

Parameters
----------
output : Series or DataFrame
    Object resulting from grouping and applying an operation.
fill_value : scalar, default np.nan
    Value to use for unobserved categories if self.observed is False.
qs : np.ndarray[float64] or None, default None
    quantile values, only relevant for quantile.

Returns
-------
Series or DataFrame
    Object (potentially) re-indexed to include all possible groups.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad3d6b6af581a5671c827e89968aa0538}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad3d6b6af581a5671c827e89968aa0538} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_set\_result\_index\_ordered@{\_set\_result\_index\_ordered}}
\index{\_set\_result\_index\_ordered@{\_set\_result\_index\_ordered}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_set\_result\_index\_ordered()}{\_set\_result\_index\_ordered()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+set\+\_\+result\+\_\+index\+\_\+ordered (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\mbox{\hyperlink{namespacepandas_1_1core_1_1groupby_1_1groupby_a4b829fd0e051c1b8ae0ce117a4cb40ec}{Output\+Frame\+Or\+Series}}     }]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6091d4c7f024ed33ef4d07b06cead74a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6091d4c7f024ed33ef4d07b06cead74a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_transform@{\_transform}}
\index{\_transform@{\_transform}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_transform()}{\_transform()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+transform (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{func,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{}]{engine = {\ttfamily None},  }\item[{}]{engine\+\_\+kwargs = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae500369e1489cda366dc97eab8a81891}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae500369e1489cda366dc97eab8a81891} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_transform\_with\_numba@{\_transform\_with\_numba}}
\index{\_transform\_with\_numba@{\_transform\_with\_numba}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_transform\_with\_numba()}{\_transform\_with\_numba()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+transform\+\_\+with\+\_\+numba (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{func,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{}]{engine\+\_\+kwargs = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Perform groupby transform routine with the numba engine.

This routine mimics the data splitting routine of the DataSplitter class
to generate the indices of each group in the sorted data and then passes the
data and indices into a Numba jitted function.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a983afa84395ff237cf723d6c120103f6}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a983afa84395ff237cf723d6c120103f6} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_value\_counts@{\_value\_counts}}
\index{\_value\_counts@{\_value\_counts}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_value\_counts()}{\_value\_counts()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+value\+\_\+counts (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Sequence\mbox{[}Hashable\mbox{]} \texorpdfstring{$\vert$}{|} None }]{subset = {\ttfamily None},  }\item[{bool }]{normalize = {\ttfamily False},  }\item[{bool }]{sort = {\ttfamily True},  }\item[{bool }]{ascending = {\ttfamily False},  }\item[{bool }]{dropna = {\ttfamily True} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Shared implementation of value_counts for SeriesGroupBy and DataFrameGroupBy.

SeriesGroupBy additionally supports a bins argument. See the docstring of
DataFrameGroupBy.value_counts for a description of arguments.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac845ecee25a3e49b6a36681e91df42f5}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac845ecee25a3e49b6a36681e91df42f5} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_wrap\_aggregated\_output@{\_wrap\_aggregated\_output}}
\index{\_wrap\_aggregated\_output@{\_wrap\_aggregated\_output}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_wrap\_aggregated\_output()}{\_wrap\_aggregated\_output()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+wrap\+\_\+aggregated\+\_\+output (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}}}]{result,  }\item[{npt.\+NDArray\mbox{[}np.\+float64\mbox{]} \texorpdfstring{$\vert$}{|} None }]{qs = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Wraps the output of GroupBy aggregations into the expected result.

Parameters
----------
result : Series, DataFrame

Returns
-------
Series or DataFrame
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a34334f407c47419139f34fbb98738f0c}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a34334f407c47419139f34fbb98738f0c} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_wrap\_applied\_output@{\_wrap\_applied\_output}}
\index{\_wrap\_applied\_output@{\_wrap\_applied\_output}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_wrap\_applied\_output()}{\_wrap\_applied\_output()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+wrap\+\_\+applied\+\_\+output (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{data,  }\item[{list}]{values,  }\item[{bool }]{not\+\_\+indexed\+\_\+same = {\ttfamily False},  }\item[{bool }]{is\+\_\+transform = {\ttfamily False} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Réimplémentée dans \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1generic_1_1DataFrameGroupBy_a7abb50b37e5234abe435d0ec2303a6cb}{pandas.\+core.\+groupby.\+generic.\+Data\+Frame\+Group\+By}}, et \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1generic_1_1SeriesGroupBy_a95f51c6daddc8c2cabdfc2cdec63226a}{pandas.\+core.\+groupby.\+generic.\+Series\+Group\+By}}.

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a305bc35873d837f9a74465c961f8f200}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a305bc35873d837f9a74465c961f8f200} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_wrap\_idxmax\_idxmin@{\_wrap\_idxmax\_idxmin}}
\index{\_wrap\_idxmax\_idxmin@{\_wrap\_idxmax\_idxmin}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_wrap\_idxmax\_idxmin()}{\_wrap\_idxmax\_idxmin()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+wrap\+\_\+idxmax\+\_\+idxmin (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{NDFrameT}]{res }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a81fd76cecac1af72652720dd31b8f64c}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a81fd76cecac1af72652720dd31b8f64c} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_wrap\_transform\_fast\_result@{\_wrap\_transform\_fast\_result}}
\index{\_wrap\_transform\_fast\_result@{\_wrap\_transform\_fast\_result}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_wrap\_transform\_fast\_result()}{\_wrap\_transform\_fast\_result()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+wrap\+\_\+transform\+\_\+fast\+\_\+result (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{NDFrameT}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Fast transform path for aggregations.
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aca41dcd2ed47e3cab8a37d9b2abc48e3}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aca41dcd2ed47e3cab8a37d9b2abc48e3} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!all@{all}}
\index{all@{all}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{all()}{all()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+all (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{skipna = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True if all values in the group are truthful, else False.

Parameters
----------
skipna : bool, default True
    Flag to ignore nan values during truth testing.

Returns
-------
Series or DataFrame
    DataFrame or Series of boolean values, where a value is True if all elements
    are True within its respective group, False otherwise.
%(see_also)s
Examples
--------

For SeriesGroupBy:

>>> lst = ['a', 'a', 'b']
>>> ser = pd.Series([1, 2, 0], index=lst)
>>> ser
a    1
a    2
b    0
dtype: int64
>>> ser.groupby(level=0).all()
a     True
b    False
dtype: bool

For DataFrameGroupBy:

>>> data = [[1, 0, 3], [1, 5, 6], [7, 8, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["ostrich", "penguin", "parrot"])
>>> df
         a  b  c
ostrich  1  0  3
penguin  1  5  6
parrot   7  8  9
>>> df.groupby(by=["a"]).all()
       b      c
a
1  False   True
7   True   True
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a73fd9629a7a95bba63fbc8a316e56285}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a73fd9629a7a95bba63fbc8a316e56285} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!any@{any}}
\index{any@{any}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{any()}{any()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+any (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{skipna = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True if any value in the group is truthful, else False.

Parameters
----------
skipna : bool, default True
    Flag to ignore nan values during truth testing.

Returns
-------
Series or DataFrame
    DataFrame or Series of boolean values, where a value is True if any element
    is True within its respective group, False otherwise.
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'b']
>>> ser = pd.Series([1, 2, 0], index=lst)
>>> ser
a    1
a    2
b    0
dtype: int64
>>> ser.groupby(level=0).any()
a     True
b    False
dtype: bool

For DataFrameGroupBy:

>>> data = [[1, 0, 3], [1, 0, 6], [7, 1, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["ostrich", "penguin", "parrot"])
>>> df
         a  b  c
ostrich  1  0  3
penguin  1  0  6
parrot   7  1  9
>>> df.groupby(by=["a"]).any()
       b      c
a
1  False   True
7   True   True
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6bcea37a3ca4c0b83a4e7c2a1f4b9744}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6bcea37a3ca4c0b83a4e7c2a1f4b9744} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!apply@{apply}}
\index{apply@{apply}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{apply()}{apply()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+apply (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{func,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{bool }]{include\+\_\+groups = {\ttfamily True},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}



Réimplémentée dans \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1generic_1_1SeriesGroupBy_a4bb7c63c45f8d99015a8bdbaeabc66c8}{pandas.\+core.\+groupby.\+generic.\+Series\+Group\+By}}.

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a14c659c128cac8ea33f9cf57dded2367}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a14c659c128cac8ea33f9cf57dded2367} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!bfill@{bfill}}
\index{bfill@{bfill}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{bfill()}{bfill()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+bfill (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int \texorpdfstring{$\vert$}{|} None }]{limit = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Backward fill the values.

Parameters
----------
limit : int, optional
    Limit of how many values to fill.

Returns
-------
Series or DataFrame
    Object with missing values filled.

See Also
--------
Series.bfill :  Backward fill the missing values in the dataset.
DataFrame.bfill:  Backward fill the missing values in the dataset.
Series.fillna: Fill NaN values of a Series.
DataFrame.fillna: Fill NaN values of a DataFrame.

Examples
--------

With Series:

>>> index = ['Falcon', 'Falcon', 'Parrot', 'Parrot', 'Parrot']
>>> s = pd.Series([None, 1, None, None, 3], index=index)
>>> s
Falcon    NaN
Falcon    1.0
Parrot    NaN
Parrot    NaN
Parrot    3.0
dtype: float64
>>> s.groupby(level=0).bfill()
Falcon    1.0
Falcon    1.0
Parrot    3.0
Parrot    3.0
Parrot    3.0
dtype: float64
>>> s.groupby(level=0).bfill(limit=1)
Falcon    1.0
Falcon    1.0
Parrot    NaN
Parrot    3.0
Parrot    3.0
dtype: float64

With DataFrame:

>>> df = pd.DataFrame({'A': [1, None, None, None, 4],
...                    'B': [None, None, 5, None, 7]}, index=index)
>>> df
          A     B
Falcon  1.0   NaN
Falcon  NaN   NaN
Parrot  NaN   5.0
Parrot  NaN   NaN
Parrot  4.0   7.0
>>> df.groupby(level=0).bfill()
          A     B
Falcon  1.0   NaN
Falcon  NaN   NaN
Parrot  4.0   5.0
Parrot  4.0   7.0
Parrot  4.0   7.0
>>> df.groupby(level=0).bfill(limit=1)
          A     B
Falcon  1.0   NaN
Falcon  NaN   NaN
Parrot  NaN   5.0
Parrot  4.0   7.0
Parrot  4.0   7.0
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7f0e94b2416991aed9f5aef0be1ea312}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7f0e94b2416991aed9f5aef0be1ea312} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!count@{count}}
\index{count@{count}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{count()}{count()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+count (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute count of group, excluding missing values.

Returns
-------
Series or DataFrame
    Count of values within each group.
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'b']
>>> ser = pd.Series([1, 2, np.nan], index=lst)
>>> ser
a    1.0
a    2.0
b    NaN
dtype: float64
>>> ser.groupby(level=0).count()
a    2
b    0
dtype: int64

For DataFrameGroupBy:

>>> data = [[1, np.nan, 3], [1, np.nan, 6], [7, 8, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["cow", "horse", "bull"])
>>> df
        a     b c
cow     1   NaN 3
horse   1   NaN 6
bull    7   8.0 9
>>> df.groupby("a").count()
    b   c
a
1   0   2
7   1   1

For Resampler:

>>> ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex(
...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15']))
>>> ser
2023-01-01    1
2023-01-15    2
2023-02-01    3
2023-02-15    4
dtype: int64
>>> ser.resample('MS').count()
2023-01-01    2
2023-02-01    2
Freq: MS, dtype: int64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab69f343f46d328e9ff7f92c48167bd9d}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab69f343f46d328e9ff7f92c48167bd9d} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!cumcount@{cumcount}}
\index{cumcount@{cumcount}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{cumcount()}{cumcount()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+cumcount (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{ascending = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Number each item in each group from 0 to the length of that group - 1.

Essentially this is equivalent to

.. code-block:: python

    self.apply(lambda x: pd.Series(np.arange(len(x)), x.index))

Parameters
----------
ascending : bool, default True
    If False, number in reverse, from length of group - 1 to 0.

Returns
-------
Series
    Sequence number of each element within each group.

See Also
--------
.ngroup : Number the groups themselves.

Examples
--------
>>> df = pd.DataFrame([['a'], ['a'], ['a'], ['b'], ['b'], ['a']],
...                   columns=['A'])
>>> df
   A
0  a
1  a
2  a
3  b
4  b
5  a
>>> df.groupby('A').cumcount()
0    0
1    1
2    2
3    0
4    1
5    3
dtype: int64
>>> df.groupby('A').cumcount(ascending=False)
0    3
1    2
2    1
3    1
4    0
5    0
dtype: int64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9d03c29e3aff9f5c2e8cb93bf373777d}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9d03c29e3aff9f5c2e8cb93bf373777d} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!cummax@{cummax}}
\index{cummax@{cummax}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{cummax()}{cummax()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+cummax (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cumulative max for each group.

Returns
-------
Series or DataFrame
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'a', 'b', 'b', 'b']
>>> ser = pd.Series([1, 6, 2, 3, 1, 4], index=lst)
>>> ser
a    1
a    6
a    2
b    3
b    1
b    4
dtype: int64
>>> ser.groupby(level=0).cummax()
a    1
a    6
a    6
b    3
b    3
b    4
dtype: int64

For DataFrameGroupBy:

>>> data = [[1, 8, 2], [1, 1, 0], [2, 6, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["cow", "horse", "bull"])
>>> df
        a   b   c
cow     1   8   2
horse   1   1   0
bull    2   6   9
>>> df.groupby("a").groups
{1: ['cow', 'horse'], 2: ['bull']}
>>> df.groupby("a").cummax()
        b   c
cow     8   2
horse   8   2
bull    6   9
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa43d4059428ff9fed536e22b1602248b}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa43d4059428ff9fed536e22b1602248b} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!cummin@{cummin}}
\index{cummin@{cummin}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{cummin()}{cummin()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+cummin (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cumulative min for each group.

Returns
-------
Series or DataFrame
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'a', 'b', 'b', 'b']
>>> ser = pd.Series([1, 6, 2, 3, 0, 4], index=lst)
>>> ser
a    1
a    6
a    2
b    3
b    0
b    4
dtype: int64
>>> ser.groupby(level=0).cummin()
a    1
a    1
a    1
b    3
b    0
b    0
dtype: int64

For DataFrameGroupBy:

>>> data = [[1, 0, 2], [1, 1, 5], [6, 6, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["snake", "rabbit", "turtle"])
>>> df
        a   b   c
snake   1   0   2
rabbit  1   1   5
turtle  6   6   9
>>> df.groupby("a").groups
{1: ['snake', 'rabbit'], 6: ['turtle']}
>>> df.groupby("a").cummin()
        b   c
snake   0   2
rabbit  0   2
turtle  6   9
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a109b04b5da99f009f7f006e86355993b}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a109b04b5da99f009f7f006e86355993b} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!cumprod@{cumprod}}
\index{cumprod@{cumprod}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{cumprod()}{cumprod()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+cumprod (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Axis \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default},  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cumulative product for each group.

Returns
-------
Series or DataFrame
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'b']
>>> ser = pd.Series([6, 2, 0], index=lst)
>>> ser
a    6
a    2
b    0
dtype: int64
>>> ser.groupby(level=0).cumprod()
a    6
a   12
b    0
dtype: int64

For DataFrameGroupBy:

>>> data = [[1, 8, 2], [1, 2, 5], [2, 6, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["cow", "horse", "bull"])
>>> df
        a   b   c
cow     1   8   2
horse   1   2   5
bull    2   6   9
>>> df.groupby("a").groups
{1: ['cow', 'horse'], 2: ['bull']}
>>> df.groupby("a").cumprod()
        b   c
cow     8   2
horse  16  10
bull    6   9
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7e486417e2947badfc8f701822ae8d48}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7e486417e2947badfc8f701822ae8d48} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!cumsum@{cumsum}}
\index{cumsum@{cumsum}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{cumsum()}{cumsum()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+cumsum (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{Axis \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default},  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cumulative sum for each group.

Returns
-------
Series or DataFrame
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'b']
>>> ser = pd.Series([6, 2, 0], index=lst)
>>> ser
a    6
a    2
b    0
dtype: int64
>>> ser.groupby(level=0).cumsum()
a    6
a    8
b    0
dtype: int64

For DataFrameGroupBy:

>>> data = [[1, 8, 2], [1, 2, 5], [2, 6, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["fox", "gorilla", "lion"])
>>> df
          a   b   c
fox       1   8   2
gorilla   1   2   5
lion      2   6   9
>>> df.groupby("a").groups
{1: ['fox', 'gorilla'], 2: ['lion']}
>>> df.groupby("a").cumsum()
          b   c
fox       8   2
gorilla  10   7
lion      6   9
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a691cad5575e341a6867e679b32413b7d}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a691cad5575e341a6867e679b32413b7d} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!describe@{describe}}
\index{describe@{describe}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{describe()}{describe()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+describe (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{percentiles = {\ttfamily None},  }\item[{}]{include = {\ttfamily None},  }\item[{}]{exclude = {\ttfamily None} }\end{DoxyParamCaption})}



Réimplémentée dans \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1generic_1_1SeriesGroupBy_ae7c42f1dae4771731bae481afff42ebb}{pandas.\+core.\+groupby.\+generic.\+Series\+Group\+By}}.

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9ffc3376f8eb8fe016943c7366f97673}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9ffc3376f8eb8fe016943c7366f97673} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!diff@{diff}}
\index{diff@{diff}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{diff()}{diff()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+diff (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{periods = {\ttfamily 1},  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default} }\end{DoxyParamCaption})}

\begin{DoxyVerb}First discrete difference of element.

Calculates the difference of each element compared with another
element in the group (default is element in previous row).

Parameters
----------
periods : int, default 1
    Periods to shift for calculating difference, accepts negative values.
axis : axis to shift, default 0
    Take difference over rows (0) or columns (1).

    .. deprecated:: 2.1.0
        For axis=1, operate on the underlying object instead. Otherwise
        the axis keyword is not necessary.

Returns
-------
Series or DataFrame
    First differences.
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'a', 'b', 'b', 'b']
>>> ser = pd.Series([7, 2, 8, 4, 3, 3], index=lst)
>>> ser
a     7
a     2
a     8
b     4
b     3
b     3
dtype: int64
>>> ser.groupby(level=0).diff()
a    NaN
a   -5.0
a    6.0
b    NaN
b   -1.0
b    0.0
dtype: float64

For DataFrameGroupBy:

>>> data = {'a': [1, 3, 5, 7, 7, 8, 3], 'b': [1, 4, 8, 4, 4, 2, 1]}
>>> df = pd.DataFrame(data, index=['dog', 'dog', 'dog',
...                   'mouse', 'mouse', 'mouse', 'mouse'])
>>> df
         a  b
  dog    1  1
  dog    3  4
  dog    5  8
mouse    7  4
mouse    7  4
mouse    8  2
mouse    3  1
>>> df.groupby(level=0).diff()
         a    b
  dog  NaN  NaN
  dog  2.0  3.0
  dog  2.0  4.0
mouse  NaN  NaN
mouse  0.0  0.0
mouse  1.0 -2.0
mouse -5.0 -1.0
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aaa2aca5c66474b38ec1460b90c787568}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aaa2aca5c66474b38ec1460b90c787568} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!ewm@{ewm}}
\index{ewm@{ewm}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{ewm()}{ewm()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1window_1_1ewm_1_1ExponentialMovingWindowGroupby}{Exponential\+Moving\+Window\+Groupby}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+ewm (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an ewm grouper, providing ewm functionality per group.

Returns
-------
pandas.api.typing.ExponentialMovingWindowGroupby
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a5a310c9e138f254a8dc75b9b00fac63e}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a5a310c9e138f254a8dc75b9b00fac63e} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!expanding@{expanding}}
\index{expanding@{expanding}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{expanding()}{expanding()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1window_1_1expanding_1_1ExpandingGroupby}{Expanding\+Groupby}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+expanding (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an expanding grouper, providing expanding
functionality per group.

Returns
-------
pandas.api.typing.ExpandingGroupby
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9e7e76c9dc33352a0255fab4e598cc81}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9e7e76c9dc33352a0255fab4e598cc81} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!ffill@{ffill}}
\index{ffill@{ffill}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{ffill()}{ffill()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+ffill (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int \texorpdfstring{$\vert$}{|} None }]{limit = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Forward fill the values.

Parameters
----------
limit : int, optional
    Limit of how many values to fill.

Returns
-------
Series or DataFrame
    Object with missing values filled.

See Also
--------
Series.ffill: Returns Series with minimum number of char in object.
DataFrame.ffill: Object with missing values filled or None if inplace=True.
Series.fillna: Fill NaN values of a Series.
DataFrame.fillna: Fill NaN values of a DataFrame.

Examples
--------

For SeriesGroupBy:

>>> key = [0, 0, 1, 1]
>>> ser = pd.Series([np.nan, 2, 3, np.nan], index=key)
>>> ser
0    NaN
0    2.0
1    3.0
1    NaN
dtype: float64
>>> ser.groupby(level=0).ffill()
0    NaN
0    2.0
1    3.0
1    3.0
dtype: float64

For DataFrameGroupBy:

>>> df = pd.DataFrame(
...     {
...         "key": [0, 0, 1, 1, 1],
...         "A": [np.nan, 2, np.nan, 3, np.nan],
...         "B": [2, 3, np.nan, np.nan, np.nan],
...         "C": [np.nan, np.nan, 2, np.nan, np.nan],
...     }
... )
>>> df
   key    A    B   C
0    0  NaN  2.0 NaN
1    0  2.0  3.0 NaN
2    1  NaN  NaN 2.0
3    1  3.0  NaN NaN
4    1  NaN  NaN NaN

Propagate non-null values forward or backward within each group along columns.

>>> df.groupby("key").ffill()
     A    B   C
0  NaN  2.0 NaN
1  2.0  3.0 NaN
2  NaN  NaN 2.0
3  3.0  NaN 2.0
4  3.0  NaN 2.0

Propagate non-null values forward or backward within each group along rows.

>>> df.T.groupby(np.array([0, 0, 1, 1])).ffill().T
   key    A    B    C
0  0.0  0.0  2.0  2.0
1  0.0  2.0  3.0  3.0
2  1.0  1.0  NaN  2.0
3  1.0  3.0  NaN  NaN
4  1.0  1.0  NaN  NaN

Only replace the first NaN element within a group along rows.

>>> df.groupby("key").ffill(limit=1)
     A    B    C
0  NaN  2.0  NaN
1  2.0  3.0  NaN
2  NaN  NaN  2.0
3  3.0  NaN  2.0
4  3.0  NaN  NaN
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa4f603ee61ca1ef93eeba79e15055cbb}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa4f603ee61ca1ef93eeba79e15055cbb} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!first@{first}}
\index{first@{first}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{first()}{first()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+first (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily -\/1},  }\item[{bool }]{skipna = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the first entry of each column within each group.

Defaults to skipping NA elements.

Parameters
----------
numeric_only : bool, default False
    Include only float, int, boolean columns.
min_count : int, default -1
    The required number of valid values to perform the operation. If fewer
    than ``min_count`` valid values are present the result will be NA.
skipna : bool, default True
    Exclude NA/null values. If an entire row/column is NA, the result
    will be NA.

    .. versionadded:: 2.2.1

Returns
-------
Series or DataFrame
    First values within each group.

See Also
--------
DataFrame.groupby : Apply a function groupby to each row or column of a
    DataFrame.
pandas.core.groupby.DataFrameGroupBy.last : Compute the last non-null entry
    of each column.
pandas.core.groupby.DataFrameGroupBy.nth : Take the nth row from each group.

Examples
--------
>>> df = pd.DataFrame(dict(A=[1, 1, 3], B=[None, 5, 6], C=[1, 2, 3],
...                        D=['3/11/2000', '3/12/2000', '3/13/2000']))
>>> df['D'] = pd.to_datetime(df['D'])
>>> df.groupby("A").first()
     B  C          D
A
1  5.0  1 2000-03-11
3  6.0  3 2000-03-13
>>> df.groupby("A").first(min_count=2)
    B    C          D
A
1 NaN  1.0 2000-03-11
3 NaN  NaN        NaT
>>> df.groupby("A").first(numeric_only=True)
     B  C
A
1  5.0  1
3  6.0  3
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a78f1160675cd14ffa2152d7892ed0408}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a78f1160675cd14ffa2152d7892ed0408} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!head@{head}}
\index{head@{head}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{head()}{head()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+head (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{n = {\ttfamily 5} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return first n rows of each group.

Similar to ``.apply(lambda x: x.head(n))``, but it returns a subset of rows
from the original DataFrame with original index and order preserved
(``as_index`` flag is ignored).

Parameters
----------
n : int
    If positive: number of entries to include from start of each group.
    If negative: number of entries to exclude from end of each group.

Returns
-------
Series or DataFrame
    Subset of original Series or DataFrame as determined by n.
%(see_also)s
Examples
--------

>>> df = pd.DataFrame([[1, 2], [1, 4], [5, 6]],
...                   columns=['A', 'B'])
>>> df.groupby('A').head(1)
   A  B
0  1  2
2  5  6
>>> df.groupby('A').head(-1)
   A  B
0  1  2
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7d8671d55ee9869aeabaef211ee56ee7}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a7d8671d55ee9869aeabaef211ee56ee7} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!last@{last}}
\index{last@{last}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{last()}{last()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+last (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily -\/1},  }\item[{bool }]{skipna = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the last entry of each column within each group.

Defaults to skipping NA elements.

Parameters
----------
numeric_only : bool, default False
    Include only float, int, boolean columns. If None, will attempt to use
    everything, then use only numeric data.
min_count : int, default -1
    The required number of valid values to perform the operation. If fewer
    than ``min_count`` valid values are present the result will be NA.
skipna : bool, default True
    Exclude NA/null values. If an entire row/column is NA, the result
    will be NA.

    .. versionadded:: 2.2.1

Returns
-------
Series or DataFrame
    Last of values within each group.

See Also
--------
DataFrame.groupby : Apply a function groupby to each row or column of a
    DataFrame.
pandas.core.groupby.DataFrameGroupBy.first : Compute the first non-null entry
    of each column.
pandas.core.groupby.DataFrameGroupBy.nth : Take the nth row from each group.

Examples
--------
>>> df = pd.DataFrame(dict(A=[1, 1, 3], B=[5, None, 6], C=[1, 2, 3]))
>>> df.groupby("A").last()
     B  C
A
1  5.0  2
3  6.0  3
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_afec4751663c1bf22bf6bf86305add2bf}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_afec4751663c1bf22bf6bf86305add2bf} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!max@{max}}
\index{max@{max}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{max()}{max()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+max (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily -\/1},  }\item[{Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine = {\ttfamily None},  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine\+\_\+kwargs = {\ttfamily None} }\end{DoxyParamCaption})}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a611f23bf2f5e21f4a67e62d9ba6ebcb5}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a611f23bf2f5e21f4a67e62d9ba6ebcb5} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!mean@{mean}}
\index{mean@{mean}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{mean()}{mean()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+mean (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine = {\ttfamily None},  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine\+\_\+kwargs = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute mean of groups, excluding missing values.

Parameters
----------
numeric_only : bool, default False
    Include only float, int, boolean columns.

    .. versionchanged:: 2.0.0

        numeric_only no longer accepts ``None`` and defaults to ``False``.

engine : str, default None
    * ``'cython'`` : Runs the operation through C-extensions from cython.
    * ``'numba'`` : Runs the operation through JIT compiled code from numba.
    * ``None`` : Defaults to ``'cython'`` or globally setting
      ``compute.use_numba``

    .. versionadded:: 1.4.0

engine_kwargs : dict, default None
    * For ``'cython'`` engine, there are no accepted ``engine_kwargs``
    * For ``'numba'`` engine, the engine can accept ``nopython``, ``nogil``
      and ``parallel`` dictionary keys. The values must either be ``True`` or
      ``False``. The default ``engine_kwargs`` for the ``'numba'`` engine is
      ``{{'nopython': True, 'nogil': False, 'parallel': False}}``

    .. versionadded:: 1.4.0

Returns
-------
pandas.Series or pandas.DataFrame
%(see_also)s
Examples
--------
>>> df = pd.DataFrame({'A': [1, 1, 2, 1, 2],
...                    'B': [np.nan, 2, 3, 4, 5],
...                    'C': [1, 2, 1, 1, 2]}, columns=['A', 'B', 'C'])

Groupby one column and return the mean of the remaining columns in
each group.

>>> df.groupby('A').mean()
     B         C
A
1  3.0  1.333333
2  4.0  1.500000

Groupby two columns and return the mean of the remaining column.

>>> df.groupby(['A', 'B']).mean()
         C
A B
1 2.0  2.0
  4.0  1.0
2 3.0  1.0
  5.0  2.0

Groupby one column and return the mean of only particular column in
the group.

>>> df.groupby('A')['B'].mean()
A
1    3.0
2    4.0
Name: B, dtype: float64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a02f26506b761b85cf5a659e6290d0340}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a02f26506b761b85cf5a659e6290d0340} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!median@{median}}
\index{median@{median}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{median()}{median()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+median (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute median of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex

Parameters
----------
numeric_only : bool, default False
    Include only float, int, boolean columns.

    .. versionchanged:: 2.0.0

        numeric_only no longer accepts ``None`` and defaults to False.

Returns
-------
Series or DataFrame
    Median of values within each group.

Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'a', 'b', 'b', 'b']
>>> ser = pd.Series([7, 2, 8, 4, 3, 3], index=lst)
>>> ser
a     7
a     2
a     8
b     4
b     3
b     3
dtype: int64
>>> ser.groupby(level=0).median()
a    7.0
b    3.0
dtype: float64

For DataFrameGroupBy:

>>> data = {'a': [1, 3, 5, 7, 7, 8, 3], 'b': [1, 4, 8, 4, 4, 2, 1]}
>>> df = pd.DataFrame(data, index=['dog', 'dog', 'dog',
...                   'mouse', 'mouse', 'mouse', 'mouse'])
>>> df
         a  b
  dog    1  1
  dog    3  4
  dog    5  8
mouse    7  4
mouse    7  4
mouse    8  2
mouse    3  1
>>> df.groupby(level=0).median()
         a    b
dog    3.0  4.0
mouse  7.0  3.0

For Resampler:

>>> ser = pd.Series([1, 2, 3, 3, 4, 5],
...                 index=pd.DatetimeIndex(['2023-01-01',
...                                         '2023-01-10',
...                                         '2023-01-15',
...                                         '2023-02-01',
...                                         '2023-02-10',
...                                         '2023-02-15']))
>>> ser.resample('MS').median()
2023-01-01    2.0
2023-02-01    4.0
Freq: MS, dtype: float64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3d94cb5acc8878d012d80c011e9f3f1f}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3d94cb5acc8878d012d80c011e9f3f1f} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!min@{min}}
\index{min@{min}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{min()}{min()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+min (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily -\/1},  }\item[{Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine = {\ttfamily None},  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine\+\_\+kwargs = {\ttfamily None} }\end{DoxyParamCaption})}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a4e0ab5f350005e94a5ff7a77874a9bde}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a4e0ab5f350005e94a5ff7a77874a9bde} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!ngroup@{ngroup}}
\index{ngroup@{ngroup}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{ngroup()}{ngroup()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+ngroup (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{ascending = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Number each group from 0 to the number of groups - 1.

This is the enumerative complement of cumcount.  Note that the
numbers given to the groups match the order in which the groups
would be seen when iterating over the groupby object, not the
order they are first observed.

Groups with missing keys (where `pd.isna()` is True) will be labeled with `NaN`
and will be skipped from the count.

Parameters
----------
ascending : bool, default True
    If False, number in reverse, from number of group - 1 to 0.

Returns
-------
Series
    Unique numbers for each group.

See Also
--------
.cumcount : Number the rows in each group.

Examples
--------
>>> df = pd.DataFrame({"color": ["red", None, "red", "blue", "blue", "red"]})
>>> df
   color
0    red
1   None
2    red
3   blue
4   blue
5    red
>>> df.groupby("color").ngroup()
0    1.0
1    NaN
2    1.0
3    0.0
4    0.0
5    1.0
dtype: float64
>>> df.groupby("color", dropna=False).ngroup()
0    1
1    2
2    1
3    0
4    0
5    1
dtype: int64
>>> df.groupby("color", dropna=False).ngroup(ascending=False)
0    1
1    0
2    1
3    2
4    2
5    1
dtype: int64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a99dc3aa9708151309c8e76d075ae458a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a99dc3aa9708151309c8e76d075ae458a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!nth@{nth}}
\index{nth@{nth}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{nth()}{nth()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1groupby_1_1indexing_1_1GroupByNthSelector}{Group\+By\+Nth\+Selector}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+nth (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Take the nth row from each group if n is an int, otherwise a subset of rows.

Can be either a call or an index. dropna is not available with index notation.
Index notation accepts a comma separated list of integers and slices.

If dropna, will take the nth non-null row, dropna is either
'all' or 'any'; this is equivalent to calling dropna(how=dropna)
before the groupby.

Parameters
----------
n : int, slice or list of ints and slices
    A single nth value for the row or a list of nth values or slices.

    .. versionchanged:: 1.4.0
        Added slice and lists containing slices.
        Added index notation.

dropna : {'any', 'all', None}, default None
    Apply the specified dropna operation before counting which row is
    the nth row. Only supported if n is an int.

Returns
-------
Series or DataFrame
    N-th value within each group.
%(see_also)s
Examples
--------

>>> df = pd.DataFrame({'A': [1, 1, 2, 1, 2],
...                    'B': [np.nan, 2, 3, 4, 5]}, columns=['A', 'B'])
>>> g = df.groupby('A')
>>> g.nth(0)
   A   B
0  1 NaN
2  2 3.0
>>> g.nth(1)
   A   B
1  1 2.0
4  2 5.0
>>> g.nth(-1)
   A   B
3  1 4.0
4  2 5.0
>>> g.nth([0, 1])
   A   B
0  1 NaN
1  1 2.0
2  2 3.0
4  2 5.0
>>> g.nth(slice(None, -1))
   A   B
0  1 NaN
1  1 2.0
2  2 3.0

Index notation may also be used

>>> g.nth[0, 1]
   A   B
0  1 NaN
1  1 2.0
2  2 3.0
4  2 5.0
>>> g.nth[:-1]
   A   B
0  1 NaN
1  1 2.0
2  2 3.0

Specifying `dropna` allows ignoring ``NaN`` values

>>> g.nth(0, dropna='any')
   A   B
1  1 2.0
2  2 3.0

When the specified ``n`` is larger than any of the groups, an
empty DataFrame is returned

>>> g.nth(3, dropna='any')
Empty DataFrame
Columns: [A, B]
Index: []
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a94e9ea883682f3e31624abd0170195a3}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a94e9ea883682f3e31624abd0170195a3} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!ohlc@{ohlc}}
\index{ohlc@{ohlc}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{ohlc()}{ohlc()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+ohlc (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute open, high, low and close values of a group, excluding missing values.

For multiple groupings, the result index will be a MultiIndex

Returns
-------
DataFrame
    Open, high, low and close values within each group.

Examples
--------

For SeriesGroupBy:

>>> lst = ['SPX', 'CAC', 'SPX', 'CAC', 'SPX', 'CAC', 'SPX', 'CAC',]
>>> ser = pd.Series([3.4, 9.0, 7.2, 5.2, 8.8, 9.4, 0.1, 0.5], index=lst)
>>> ser
SPX     3.4
CAC     9.0
SPX     7.2
CAC     5.2
SPX     8.8
CAC     9.4
SPX     0.1
CAC     0.5
dtype: float64
>>> ser.groupby(level=0).ohlc()
     open  high  low  close
CAC   9.0   9.4  0.5    0.5
SPX   3.4   8.8  0.1    0.1

For DataFrameGroupBy:

>>> data = {2022: [1.2, 2.3, 8.9, 4.5, 4.4, 3, 2 , 1],
...         2023: [3.4, 9.0, 7.2, 5.2, 8.8, 9.4, 8.2, 1.0]}
>>> df = pd.DataFrame(data, index=['SPX', 'CAC', 'SPX', 'CAC',
...                   'SPX', 'CAC', 'SPX', 'CAC'])
>>> df
     2022  2023
SPX   1.2   3.4
CAC   2.3   9.0
SPX   8.9   7.2
CAC   4.5   5.2
SPX   4.4   8.8
CAC   3.0   9.4
SPX   2.0   8.2
CAC   1.0   1.0
>>> df.groupby(level=0).ohlc()
    2022                 2023
    open high  low close open high  low close
CAC  2.3  4.5  1.0   1.0  9.0  9.4  1.0   1.0
SPX  1.2  8.9  1.2   2.0  3.4  8.8  3.4   8.2

For Resampler:

>>> ser = pd.Series([1, 3, 2, 4, 3, 5],
...                 index=pd.DatetimeIndex(['2023-01-01',
...                                         '2023-01-10',
...                                         '2023-01-15',
...                                         '2023-02-01',
...                                         '2023-02-10',
...                                         '2023-02-15']))
>>> ser.resample('MS').ohlc()
            open  high  low  close
2023-01-01     1     3    1      2
2023-02-01     4     5    3      5
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac005afcdce65181c3ee8c745b76954ab}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ac005afcdce65181c3ee8c745b76954ab} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!pct\_change@{pct\_change}}
\index{pct\_change@{pct\_change}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{pct\_change()}{pct\_change()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+pct\+\_\+change (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{periods = {\ttfamily 1},  }\item[{Fillna\+Options \texorpdfstring{$\vert$}{|} None \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{fill\+\_\+method = {\ttfamily lib.no\+\_\+default},  }\item[{int \texorpdfstring{$\vert$}{|} None \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{limit = {\ttfamily lib.no\+\_\+default},  }\item[{}]{freq = {\ttfamily None},  }\item[{Axis \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate pct_change of each value to previous entry in group.

Returns
-------
Series or DataFrame
    Percentage changes within each group.
%(see_also)s
Examples
--------

For SeriesGroupBy:

>>> lst = ['a', 'a', 'b', 'b']
>>> ser = pd.Series([1, 2, 3, 4], index=lst)
>>> ser
a    1
a    2
b    3
b    4
dtype: int64
>>> ser.groupby(level=0).pct_change()
a         NaN
a    1.000000
b         NaN
b    0.333333
dtype: float64

For DataFrameGroupBy:

>>> data = [[1, 2, 3], [1, 5, 6], [2, 5, 8], [2, 6, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["tuna", "salmon", "catfish", "goldfish"])
>>> df
           a  b  c
    tuna   1  2  3
  salmon   1  5  6
 catfish   2  5  8
goldfish   2  6  9
>>> df.groupby("a").pct_change()
            b  c
    tuna    NaN    NaN
  salmon    1.5  1.000
 catfish    NaN    NaN
goldfish    0.2  0.125
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3e25432aa1d26ffff1ff750b429921a9}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a3e25432aa1d26ffff1ff750b429921a9} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!prod@{prod}}
\index{prod@{prod}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{prod()}{prod()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+prod (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily 0} }\end{DoxyParamCaption})}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9819ede86250c9fd6cce0e172ccd7b9a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9819ede86250c9fd6cce0e172ccd7b9a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!quantile@{quantile}}
\index{quantile@{quantile}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{quantile()}{quantile()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+quantile (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{float \texorpdfstring{$\vert$}{|} Any\+Array\+Like }]{q = {\ttfamily 0.5},  }\item[{str }]{interpolation = {\ttfamily "{}linear"{}},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return group values at the given quantile, a la numpy.percentile.

Parameters
----------
q : float or array-like, default 0.5 (50% quantile)
    Value(s) between 0 and 1 providing the quantile(s) to compute.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    Method to use when the desired quantile falls between two points.
numeric_only : bool, default False
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

    .. versionchanged:: 2.0.0

        numeric_only now defaults to ``False``.

Returns
-------
Series or DataFrame
    Return type determined by caller of GroupBy object.

See Also
--------
Series.quantile : Similar method for Series.
DataFrame.quantile : Similar method for DataFrame.
numpy.percentile : NumPy method to compute qth percentile.

Examples
--------
>>> df = pd.DataFrame([
...     ['a', 1], ['a', 2], ['a', 3],
...     ['b', 1], ['b', 3], ['b', 5]
... ], columns=['key', 'val'])
>>> df.groupby('key').quantile()
    val
key
a    2.0
b    3.0
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a0afbc40de210d1495a3bf44500e5fe60}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a0afbc40de210d1495a3bf44500e5fe60} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!rank@{rank}}
\index{rank@{rank}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{rank()}{rank()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+rank (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{str }]{method = {\ttfamily "{}average"{}},  }\item[{bool }]{ascending = {\ttfamily True},  }\item[{str }]{na\+\_\+option = {\ttfamily "{}keep"{}},  }\item[{bool }]{pct = {\ttfamily False},  }\item[{Axis\+Int \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Provide the rank of values within each group.

Parameters
----------
method : {'average', 'min', 'max', 'first', 'dense'}, default 'average'
    * average: average rank of group.
    * min: lowest rank in group.
    * max: highest rank in group.
    * first: ranks assigned in order they appear in the array.
    * dense: like 'min', but rank always increases by 1 between groups.
ascending : bool, default True
    False for ranks by high (1) to low (N).
na_option : {'keep', 'top', 'bottom'}, default 'keep'
    * keep: leave NA values where they are.
    * top: smallest rank if ascending.
    * bottom: smallest rank if descending.
pct : bool, default False
    Compute percentage rank of data within each group.
axis : int, default 0
    The axis of the object over which to compute the rank.

    .. deprecated:: 2.1.0
        For axis=1, operate on the underlying object instead. Otherwise
        the axis keyword is not necessary.

Returns
-------
DataFrame with ranking of values within each group
%(see_also)s
Examples
--------
>>> df = pd.DataFrame(
...     {
...         "group": ["a", "a", "a", "a", "a", "b", "b", "b", "b", "b"],
...         "value": [2, 4, 2, 3, 5, 1, 2, 4, 1, 5],
...     }
... )
>>> df
  group  value
0     a      2
1     a      4
2     a      2
3     a      3
4     a      5
5     b      1
6     b      2
7     b      4
8     b      1
9     b      5
>>> for method in ['average', 'min', 'max', 'dense', 'first']:
...     df[f'{method}_rank'] = df.groupby('group')['value'].rank(method)
>>> df
  group  value  average_rank  min_rank  max_rank  dense_rank  first_rank
0     a      2           1.5       1.0       2.0         1.0         1.0
1     a      4           4.0       4.0       4.0         3.0         4.0
2     a      2           1.5       1.0       2.0         1.0         2.0
3     a      3           3.0       3.0       3.0         2.0         3.0
4     a      5           5.0       5.0       5.0         4.0         5.0
5     b      1           1.5       1.0       2.0         1.0         1.0
6     b      2           3.0       3.0       3.0         2.0         3.0
7     b      4           4.0       4.0       4.0         3.0         4.0
8     b      1           1.5       1.0       2.0         1.0         2.0
9     b      5           5.0       5.0       5.0         4.0         5.0
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9fa6cf1d59c6530b5a4ad46a6dc49c59}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a9fa6cf1d59c6530b5a4ad46a6dc49c59} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!resample@{resample}}
\index{resample@{resample}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{resample()}{resample()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1resample_1_1Resampler}{Resampler}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+resample (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{rule,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{bool }]{include\+\_\+groups = {\ttfamily True},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Provide resampling when using a TimeGrouper.

Given a grouper, the function resamples it according to a string
"string" -> "frequency".

See the :ref:`frequency aliases <timeseries.offset_aliases>`
documentation for more details.

Parameters
----------
rule : str or DateOffset
    The offset string or object representing target grouper conversion.
*args
    Possible arguments are `how`, `fill_method`, `limit`, `kind` and
    `on`, and other arguments of `TimeGrouper`.
include_groups : bool, default True
    When True, will attempt to include the groupings in the operation in
    the case that they are columns of the DataFrame. If this raises a
    TypeError, the result will be computed with the groupings excluded.
    When False, the groupings will be excluded when applying ``func``.

    .. versionadded:: 2.2.0

    .. deprecated:: 2.2.0

       Setting include_groups to True is deprecated. Only the value
       False will be allowed in a future version of pandas.

**kwargs
    Possible arguments are `how`, `fill_method`, `limit`, `kind` and
    `on`, and other arguments of `TimeGrouper`.

Returns
-------
pandas.api.typing.DatetimeIndexResamplerGroupby,
pandas.api.typing.PeriodIndexResamplerGroupby, or
pandas.api.typing.TimedeltaIndexResamplerGroupby
    Return a new groupby object, with type depending on the data
    being resampled.

See Also
--------
Grouper : Specify a frequency to resample with when
    grouping by a key.
DatetimeIndex.resample : Frequency conversion and resampling of
    time series.

Examples
--------
>>> idx = pd.date_range('1/1/2000', periods=4, freq='min')
>>> df = pd.DataFrame(data=4 * [range(2)],
...                   index=idx,
...                   columns=['a', 'b'])
>>> df.iloc[2, 0] = 5
>>> df
                    a  b
2000-01-01 00:00:00  0  1
2000-01-01 00:01:00  0  1
2000-01-01 00:02:00  5  1
2000-01-01 00:03:00  0  1

Downsample the DataFrame into 3 minute bins and sum the values of
the timestamps falling into a bin.

>>> df.groupby('a').resample('3min', include_groups=False).sum()
                         b
a
0   2000-01-01 00:00:00  2
    2000-01-01 00:03:00  1
5   2000-01-01 00:00:00  1

Upsample the series into 30 second bins.

>>> df.groupby('a').resample('30s', include_groups=False).sum()
                    b
a
0   2000-01-01 00:00:00  1
    2000-01-01 00:00:30  0
    2000-01-01 00:01:00  1
    2000-01-01 00:01:30  0
    2000-01-01 00:02:00  0
    2000-01-01 00:02:30  0
    2000-01-01 00:03:00  1
5   2000-01-01 00:02:00  1

Resample by month. Values are assigned to the month of the period.

>>> df.groupby('a').resample('ME', include_groups=False).sum()
            b
a
0   2000-01-31  3
5   2000-01-31  1

Downsample the series into 3 minute bins as above, but close the right
side of the bin interval.

>>> (
...     df.groupby('a')
...     .resample('3min', closed='right', include_groups=False)
...     .sum()
... )
                         b
a
0   1999-12-31 23:57:00  1
    2000-01-01 00:00:00  2
5   2000-01-01 00:00:00  1

Downsample the series into 3 minute bins and close the right side of
the bin interval, but label each bin using the right edge instead of
the left.

>>> (
...     df.groupby('a')
...     .resample('3min', closed='right', label='right', include_groups=False)
...     .sum()
... )
                         b
a
0   2000-01-01 00:00:00  1
    2000-01-01 00:03:00  2
5   2000-01-01 00:03:00  1
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad123d631afc14e83b31e7384cbd4a158}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ad123d631afc14e83b31e7384cbd4a158} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!rolling@{rolling}}
\index{rolling@{rolling}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{rolling()}{rolling()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1window_1_1rolling_1_1RollingGroupby}{Rolling\+Groupby}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+rolling (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a rolling grouper, providing rolling functionality per group.

Parameters
----------
window : int, timedelta, str, offset, or BaseIndexer subclass
    Size of the moving window.

    If an integer, the fixed number of observations used for
    each window.

    If a timedelta, str, or offset, the time period of each window. Each
    window will be a variable sized based on the observations included in
    the time-period. This is only valid for datetimelike indexes.
    To learn more about the offsets & frequency strings, please see `this link
    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.

    If a BaseIndexer subclass, the window boundaries
    based on the defined ``get_window_bounds`` method. Additional rolling
    keyword arguments, namely ``min_periods``, ``center``, ``closed`` and
    ``step`` will be passed to ``get_window_bounds``.

min_periods : int, default None
    Minimum number of observations in window required to have a value;
    otherwise, result is ``np.nan``.

    For a window that is specified by an offset,
    ``min_periods`` will default to 1.

    For a window that is specified by an integer, ``min_periods`` will default
    to the size of the window.

center : bool, default False
    If False, set the window labels as the right edge of the window index.

    If True, set the window labels as the center of the window index.

win_type : str, default None
    If ``None``, all points are evenly weighted.

    If a string, it must be a valid `scipy.signal window function
    <https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows>`__.

    Certain Scipy window types require additional parameters to be passed
    in the aggregation function. The additional parameters must match
    the keywords specified in the Scipy window type method signature.

on : str, optional
    For a DataFrame, a column label or Index level on which
    to calculate the rolling window, rather than the DataFrame's index.

    Provided integer column is ignored and excluded from result since
    an integer index is not used to calculate the rolling window.

axis : int or str, default 0
    If ``0`` or ``'index'``, roll across the rows.

    If ``1`` or ``'columns'``, roll across the columns.

    For `Series` this parameter is unused and defaults to 0.

closed : str, default None
    If ``'right'``, the first point in the window is excluded from calculations.

    If ``'left'``, the last point in the window is excluded from calculations.

    If ``'both'``, no points in the window are excluded from calculations.

    If ``'neither'``, the first and last points in the window are excluded
    from calculations.

    Default ``None`` (``'right'``).

method : str {'single', 'table'}, default 'single'
    Execute the rolling operation per single column or row (``'single'``)
    or over the entire object (``'table'``).

    This argument is only implemented when specifying ``engine='numba'``
    in the method call.

Returns
-------
pandas.api.typing.RollingGroupby
    Return a new grouper with our rolling appended.

See Also
--------
Series.rolling : Calling object with Series data.
DataFrame.rolling : Calling object with DataFrames.
Series.groupby : Apply a function groupby to a Series.
DataFrame.groupby : Apply a function groupby.

Examples
--------
>>> df = pd.DataFrame({'A': [1, 1, 2, 2],
...                    'B': [1, 2, 3, 4],
...                    'C': [0.362, 0.227, 1.267, -0.562]})
>>> df
      A  B      C
0     1  1  0.362
1     1  2  0.227
2     2  3  1.267
3     2  4 -0.562

>>> df.groupby('A').rolling(2).sum()
    B      C
A
1 0  NaN    NaN
  1  3.0  0.589
2 2  NaN    NaN
  3  7.0  0.705

>>> df.groupby('A').rolling(2, min_periods=1).sum()
    B      C
A
1 0  1.0  0.362
  1  3.0  0.589
2 2  3.0  1.267
  3  7.0  0.705

>>> df.groupby('A').rolling(2, on='B').sum()
    B      C
A
1 0  1    NaN
  1  2  0.589
2 2  3    NaN
  3  4  0.705
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a36848017b67bb140e005f24888fb9fc1}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a36848017b67bb140e005f24888fb9fc1} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!sample@{sample}}
\index{sample@{sample}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{sample()}{sample()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+sample (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int \texorpdfstring{$\vert$}{|} None }]{n = {\ttfamily None},  }\item[{float \texorpdfstring{$\vert$}{|} None }]{frac = {\ttfamily None},  }\item[{bool }]{replace = {\ttfamily False},  }\item[{Sequence \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} \texorpdfstring{$\vert$}{|} None }]{weights = {\ttfamily None},  }\item[{Random\+State \texorpdfstring{$\vert$}{|} None }]{random\+\_\+state = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a random sample of items from each group.

You can use `random_state` for reproducibility.

Parameters
----------
n : int, optional
    Number of items to return for each group. Cannot be used with
    `frac` and must be no larger than the smallest group unless
    `replace` is True. Default is one if `frac` is None.
frac : float, optional
    Fraction of items to return. Cannot be used with `n`.
replace : bool, default False
    Allow or disallow sampling of the same row more than once.
weights : list-like, optional
    Default None results in equal probability weighting.
    If passed a list-like then values must have the same length as
    the underlying DataFrame or Series object and will be used as
    sampling probabilities after normalization within each group.
    Values must be non-negative with at least one positive element
    within each group.
random_state : int, array-like, BitGenerator, np.random.RandomState, np.random.Generator, optional
    If int, array-like, or BitGenerator, seed for random number generator.
    If np.random.RandomState or np.random.Generator, use as given.

    .. versionchanged:: 1.4.0

        np.random.Generator objects now accepted

Returns
-------
Series or DataFrame
    A new object of same type as caller containing items randomly
    sampled within each group from the caller object.

See Also
--------
DataFrame.sample: Generate random samples from a DataFrame object.
numpy.random.choice: Generate a random sample from a given 1-D numpy
    array.

Examples
--------
>>> df = pd.DataFrame(
...     {"a": ["red"] * 2 + ["blue"] * 2 + ["black"] * 2, "b": range(6)}
... )
>>> df
       a  b
0    red  0
1    red  1
2   blue  2
3   blue  3
4  black  4
5  black  5

Select one row at random for each distinct value in column a. The
`random_state` argument can be used to guarantee reproducibility:

>>> df.groupby("a").sample(n=1, random_state=1)
       a  b
4  black  4
2   blue  2
1    red  1

Set `frac` to sample fixed proportions rather than counts:

>>> df.groupby("a")["b"].sample(frac=0.5, random_state=2)
5    5
2    2
0    0
Name: b, dtype: int64

Control sample probabilities within groups by setting weights:

>>> df.groupby("a").sample(
...     n=1,
...     weights=[1, 1, 1, 0, 0, 1],
...     random_state=1,
... )
       a  b
5  black  5
2   blue  2
0    red  0
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a79dfaada8852dd9a162c36f3f2d337df}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a79dfaada8852dd9a162c36f3f2d337df} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!sem@{sem}}
\index{sem@{sem}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{sem()}{sem()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+sem (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{ddof = {\ttfamily 1},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute standard error of the mean of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex.

Parameters
----------
ddof : int, default 1
    Degrees of freedom.

numeric_only : bool, default False
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

    .. versionchanged:: 2.0.0

        numeric_only now defaults to ``False``.

Returns
-------
Series or DataFrame
    Standard error of the mean of values within each group.

Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'b', 'b']
>>> ser = pd.Series([5, 10, 8, 14], index=lst)
>>> ser
a     5
a    10
b     8
b    14
dtype: int64
>>> ser.groupby(level=0).sem()
a    2.5
b    3.0
dtype: float64

For DataFrameGroupBy:

>>> data = [[1, 12, 11], [1, 15, 2], [2, 5, 8], [2, 6, 12]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["tuna", "salmon", "catfish", "goldfish"])
>>> df
           a   b   c
    tuna   1  12  11
  salmon   1  15   2
 catfish   2   5   8
goldfish   2   6  12
>>> df.groupby("a").sem()
      b  c
a
1    1.5  4.5
2    0.5  2.0

For Resampler:

>>> ser = pd.Series([1, 3, 2, 4, 3, 8],
...                 index=pd.DatetimeIndex(['2023-01-01',
...                                         '2023-01-10',
...                                         '2023-01-15',
...                                         '2023-02-01',
...                                         '2023-02-10',
...                                         '2023-02-15']))
>>> ser.resample('MS').sem()
2023-01-01    0.577350
2023-02-01    1.527525
Freq: MS, dtype: float64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a16a698ffcaddfef306e4d1642ec4c982}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a16a698ffcaddfef306e4d1642ec4c982} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!shift@{shift}}
\index{shift@{shift}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{shift()}{shift()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+shift (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int \texorpdfstring{$\vert$}{|} Sequence\mbox{[}int\mbox{]} }]{periods = {\ttfamily 1},  }\item[{}]{freq = {\ttfamily None},  }\item[{Axis \texorpdfstring{$\vert$}{|} lib.\+No\+Default }]{axis = {\ttfamily lib.no\+\_\+default},  }\item[{}]{fill\+\_\+value = {\ttfamily lib.no\+\_\+default},  }\item[{str \texorpdfstring{$\vert$}{|} None }]{suffix = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Shift each group by periods observations.

If freq is passed, the index will be increased using the periods and the freq.

Parameters
----------
periods : int | Sequence[int], default 1
    Number of periods to shift. If a list of values, shift each group by
    each period.
freq : str, optional
    Frequency string.
axis : axis to shift, default 0
    Shift direction.

    .. deprecated:: 2.1.0
        For axis=1, operate on the underlying object instead. Otherwise
        the axis keyword is not necessary.

fill_value : optional
    The scalar value to use for newly introduced missing values.

    .. versionchanged:: 2.1.0
        Will raise a ``ValueError`` if ``freq`` is provided too.

suffix : str, optional
    A string to add to each shifted column if there are multiple periods.
    Ignored otherwise.

Returns
-------
Series or DataFrame
    Object shifted within each group.

See Also
--------
Index.shift : Shift values of Index.

Examples
--------

For SeriesGroupBy:

>>> lst = ['a', 'a', 'b', 'b']
>>> ser = pd.Series([1, 2, 3, 4], index=lst)
>>> ser
a    1
a    2
b    3
b    4
dtype: int64
>>> ser.groupby(level=0).shift(1)
a    NaN
a    1.0
b    NaN
b    3.0
dtype: float64

For DataFrameGroupBy:

>>> data = [[1, 2, 3], [1, 5, 6], [2, 5, 8], [2, 6, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["tuna", "salmon", "catfish", "goldfish"])
>>> df
           a  b  c
    tuna   1  2  3
  salmon   1  5  6
 catfish   2  5  8
goldfish   2  6  9
>>> df.groupby("a").shift(1)
              b    c
    tuna    NaN  NaN
  salmon    2.0  3.0
 catfish    NaN  NaN
goldfish    5.0  8.0
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abf144a9cf62fed56f15f1cfb77c0a263}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abf144a9cf62fed56f15f1cfb77c0a263} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!size@{size}}
\index{size@{size}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily  \mbox{\hyperlink{classpandas_1_1core_1_1frame_1_1DataFrame}{Data\+Frame}} \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{classpandas_1_1core_1_1series_1_1Series}{Series}} pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+size (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute group sizes.

Returns
-------
DataFrame or Series
    Number of rows in each group as a Series if as_index is True
    or a DataFrame if as_index is False.
%(see_also)s
Examples
--------

For SeriesGroupBy:

>>> lst = ['a', 'a', 'b']
>>> ser = pd.Series([1, 2, 3], index=lst)
>>> ser
a     1
a     2
b     3
dtype: int64
>>> ser.groupby(level=0).size()
a    2
b    1
dtype: int64

>>> data = [[1, 2, 3], [1, 5, 6], [7, 8, 9]]
>>> df = pd.DataFrame(data, columns=["a", "b", "c"],
...                   index=["owl", "toucan", "eagle"])
>>> df
        a  b  c
owl     1  2  3
toucan  1  5  6
eagle   7  8  9
>>> df.groupby("a").size()
a
1    2
7    1
dtype: int64

For Resampler:

>>> ser = pd.Series([1, 2, 3], index=pd.DatetimeIndex(
...                 ['2023-01-01', '2023-01-15', '2023-02-01']))
>>> ser
2023-01-01    1
2023-01-15    2
2023-02-01    3
dtype: int64
>>> ser.resample('MS').size()
2023-01-01    2
2023-02-01    1
Freq: MS, dtype: int64
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a21cf38606b1d5338a7ab53b178aa37b7}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a21cf38606b1d5338a7ab53b178aa37b7} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!std@{std}}
\index{std@{std}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{std()}{std()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+std (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{ddof = {\ttfamily 1},  }\item[{Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine = {\ttfamily None},  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine\+\_\+kwargs = {\ttfamily None},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute standard deviation of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex.

Parameters
----------
ddof : int, default 1
    Degrees of freedom.

engine : str, default None
    * ``'cython'`` : Runs the operation through C-extensions from cython.
    * ``'numba'`` : Runs the operation through JIT compiled code from numba.
    * ``None`` : Defaults to ``'cython'`` or globally setting
      ``compute.use_numba``

    .. versionadded:: 1.4.0

engine_kwargs : dict, default None
    * For ``'cython'`` engine, there are no accepted ``engine_kwargs``
    * For ``'numba'`` engine, the engine can accept ``nopython``, ``nogil``
      and ``parallel`` dictionary keys. The values must either be ``True`` or
      ``False``. The default ``engine_kwargs`` for the ``'numba'`` engine is
      ``{{'nopython': True, 'nogil': False, 'parallel': False}}``

    .. versionadded:: 1.4.0

numeric_only : bool, default False
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

    .. versionchanged:: 2.0.0

        numeric_only now defaults to ``False``.

Returns
-------
Series or DataFrame
    Standard deviation of values within each group.
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'a', 'b', 'b', 'b']
>>> ser = pd.Series([7, 2, 8, 4, 3, 3], index=lst)
>>> ser
a     7
a     2
a     8
b     4
b     3
b     3
dtype: int64
>>> ser.groupby(level=0).std()
a    3.21455
b    0.57735
dtype: float64

For DataFrameGroupBy:

>>> data = {'a': [1, 3, 5, 7, 7, 8, 3], 'b': [1, 4, 8, 4, 4, 2, 1]}
>>> df = pd.DataFrame(data, index=['dog', 'dog', 'dog',
...                   'mouse', 'mouse', 'mouse', 'mouse'])
>>> df
         a  b
  dog    1  1
  dog    3  4
  dog    5  8
mouse    7  4
mouse    7  4
mouse    8  2
mouse    3  1
>>> df.groupby(level=0).std()
              a         b
dog    2.000000  3.511885
mouse  2.217356  1.500000
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a970ace20f19e971b994a524aa3ea573b}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a970ace20f19e971b994a524aa3ea573b} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!sum@{sum}}
\index{sum@{sum}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{sum()}{sum()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+sum (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False},  }\item[{int }]{min\+\_\+count = {\ttfamily 0},  }\item[{Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine = {\ttfamily None},  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine\+\_\+kwargs = {\ttfamily None} }\end{DoxyParamCaption})}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a763a9595f945252ec15615cf0165dc26}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a763a9595f945252ec15615cf0165dc26} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!tail@{tail}}
\index{tail@{tail}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{tail()}{tail()}}
{\footnotesize\ttfamily  NDFrameT pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+tail (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{n = {\ttfamily 5} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return last n rows of each group.

Similar to ``.apply(lambda x: x.tail(n))``, but it returns a subset of rows
from the original DataFrame with original index and order preserved
(``as_index`` flag is ignored).

Parameters
----------
n : int
    If positive: number of entries to include from end of each group.
    If negative: number of entries to exclude from start of each group.

Returns
-------
Series or DataFrame
    Subset of original Series or DataFrame as determined by n.
%(see_also)s
Examples
--------

>>> df = pd.DataFrame([['a', 1], ['a', 2], ['b', 1], ['b', 2]],
...                   columns=['A', 'B'])
>>> df.groupby('A').tail(1)
   A  B
1  a  2
3  b  2
>>> df.groupby('A').tail(-1)
   A  B
1  a  2
3  b  2
\end{DoxyVerb}
 \Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abd6b28389b3b4bf68c653584b5b9cf40}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_abd6b28389b3b4bf68c653584b5b9cf40} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!var@{var}}
\index{var@{var}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{var()}{var()}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+var (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{int }]{ddof = {\ttfamily 1},  }\item[{Literal\mbox{[}"{}cython"{}, "{}numba"{}\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine = {\ttfamily None},  }\item[{dict\mbox{[}str, bool\mbox{]} \texorpdfstring{$\vert$}{|} None }]{engine\+\_\+kwargs = {\ttfamily None},  }\item[{bool }]{numeric\+\_\+only = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute variance of groups, excluding missing values.

For multiple groupings, the result index will be a MultiIndex.

Parameters
----------
ddof : int, default 1
    Degrees of freedom.

engine : str, default None
    * ``'cython'`` : Runs the operation through C-extensions from cython.
    * ``'numba'`` : Runs the operation through JIT compiled code from numba.
    * ``None`` : Defaults to ``'cython'`` or globally setting
      ``compute.use_numba``

    .. versionadded:: 1.4.0

engine_kwargs : dict, default None
    * For ``'cython'`` engine, there are no accepted ``engine_kwargs``
    * For ``'numba'`` engine, the engine can accept ``nopython``, ``nogil``
      and ``parallel`` dictionary keys. The values must either be ``True`` or
      ``False``. The default ``engine_kwargs`` for the ``'numba'`` engine is
      ``{{'nopython': True, 'nogil': False, 'parallel': False}}``

    .. versionadded:: 1.4.0

numeric_only : bool, default False
    Include only `float`, `int` or `boolean` data.

    .. versionadded:: 1.5.0

    .. versionchanged:: 2.0.0

        numeric_only now defaults to ``False``.

Returns
-------
Series or DataFrame
    Variance of values within each group.
%(see_also)s
Examples
--------
For SeriesGroupBy:

>>> lst = ['a', 'a', 'a', 'b', 'b', 'b']
>>> ser = pd.Series([7, 2, 8, 4, 3, 3], index=lst)
>>> ser
a     7
a     2
a     8
b     4
b     3
b     3
dtype: int64
>>> ser.groupby(level=0).var()
a    10.333333
b     0.333333
dtype: float64

For DataFrameGroupBy:

>>> data = {'a': [1, 3, 5, 7, 7, 8, 3], 'b': [1, 4, 8, 4, 4, 2, 1]}
>>> df = pd.DataFrame(data, index=['dog', 'dog', 'dog',
...                   'mouse', 'mouse', 'mouse', 'mouse'])
>>> df
         a  b
  dog    1  1
  dog    3  4
  dog    5  8
mouse    7  4
mouse    7  4
mouse    8  2
mouse    3  1
>>> df.groupby(level=0).var()
              a          b
dog    4.000000  12.333333
mouse  4.916667   2.250000
\end{DoxyVerb}
 

\doxysubsection{Documentation des données membres}
\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a19a910c3e7ac812793052b0590270f02}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a19a910c3e7ac812793052b0590270f02} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_grouper@{\_grouper}}
\index{\_grouper@{\_grouper}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_grouper}{\_grouper}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily ops pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+grouper .Base\+Grouper\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_adc71fe58ebe188cc6b6d8ff627ecddba}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_adc71fe58ebe188cc6b6d8ff627ecddba} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_grouper@{\_grouper}}
\index{\_grouper@{\_grouper}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_grouper}{\_grouper}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+grouper\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a8ece12e82ff5f534105bb530a9ab8d7b}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a8ece12e82ff5f534105bb530a9ab8d7b} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_obj\_with\_exclusions@{\_obj\_with\_exclusions}}
\index{\_obj\_with\_exclusions@{\_obj\_with\_exclusions}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_obj\_with\_exclusions}{\_obj\_with\_exclusions}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+obj\+\_\+with\+\_\+exclusions\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6e9c3764acd40f62b4463bf8aa235190}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a6e9c3764acd40f62b4463bf8aa235190} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_selected\_obj@{\_selected\_obj}}
\index{\_selected\_obj@{\_selected\_obj}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_selected\_obj}{\_selected\_obj}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+selected\+\_\+obj\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a91472f24fd5afcc07a81edd04b4a5328}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a91472f24fd5afcc07a81edd04b4a5328} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!\_selection@{\_selection}}
\index{\_selection@{\_selection}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{\_selection}{\_selection}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+\_\+selection\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a95f69def69abf91e4ed27e2f215b6645}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a95f69def69abf91e4ed27e2f215b6645} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!as\_index@{as\_index}}
\index{as\_index@{as\_index}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{as\_index}{as\_index}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+as\+\_\+index\hspace{0.3cm}{\ttfamily [static]}}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a92fb589411ebb1a7c1a8babfe74987d1}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a92fb589411ebb1a7c1a8babfe74987d1} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!as\_index@{as\_index}}
\index{as\_index@{as\_index}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{as\_index}{as\_index}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+as\+\_\+index}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae9cb972cc96e0e06c7d409ebed5dcf88} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!axis@{axis}}
\index{axis@{axis}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{axis}{axis}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+axis}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a27e6d7322e8c242ea87594807d342c6b} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!dropna@{dropna}}
\index{dropna@{dropna}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{dropna}{dropna}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+dropna}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aba8874c98a4d0fc618ae3ab735d83798}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aba8874c98a4d0fc618ae3ab735d83798} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!exclusions@{exclusions}}
\index{exclusions@{exclusions}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{exclusions}{exclusions}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+exclusions}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae43cf53a5fc86038b9ae1fcb50353232}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ae43cf53a5fc86038b9ae1fcb50353232} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!group\_keys@{group\_keys}}
\index{group\_keys@{group\_keys}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{group\_keys}{group\_keys}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+group\+\_\+keys}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab885b4c07c7081d8f3bd8bfd51d9cad5}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_ab885b4c07c7081d8f3bd8bfd51d9cad5} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!keys@{keys}}
\index{keys@{keys}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{keys}{keys}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+keys}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a2a5c3daddc0cd71d53ae1703376ba230}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a2a5c3daddc0cd71d53ae1703376ba230} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!level@{level}}
\index{level@{level}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{level}{level}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+level}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1e8befeb0c9e7da25600d0119af3f726}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_a1e8befeb0c9e7da25600d0119af3f726} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!obj@{obj}}
\index{obj@{obj}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{obj}{obj}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+obj}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aad235e29e75ce0c2ea71fc58f3833d4a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aad235e29e75ce0c2ea71fc58f3833d4a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!observed@{observed}}
\index{observed@{observed}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{observed}{observed}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+observed}

\Hypertarget{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa716330d6113b7f0d85e594d84f7c83a}\label{classpandas_1_1core_1_1groupby_1_1groupby_1_1GroupBy_aa716330d6113b7f0d85e594d84f7c83a} 
\index{pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}!sort@{sort}}
\index{sort@{sort}!pandas.core.groupby.groupby.GroupBy@{pandas.core.groupby.groupby.GroupBy}}
\doxysubsubsection{\texorpdfstring{sort}{sort}}
{\footnotesize\ttfamily pandas.\+core.\+groupby.\+groupby.\+Group\+By.\+sort}



La documentation de cette classe a été générée à partir du fichier suivant \+:\begin{DoxyCompactItemize}
\item 
env/lib/python3.\+12/site-\/packages/pandas/core/groupby/\mbox{\hyperlink{core_2groupby_2groupby_8py}{groupby.\+py}}\end{DoxyCompactItemize}
