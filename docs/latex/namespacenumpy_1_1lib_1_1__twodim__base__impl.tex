\doxysection{Référence de l\textquotesingle{}espace de nommage numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl}
\hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl}{}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl}\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a33b3609fa9e1214de56289bf91856126}{\+\_\+min\+\_\+int}} (low, high)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ae82dbb64545f177987b75dcd6e2331f1}{\+\_\+flip\+\_\+dispatcher}} (m)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a20b8ad70aadf04144596103fbcc44c51}{fliplr}} (m)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a365de51a3c0cf6125053f930fe58f836}{flipud}} (m)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac1c9f0c8c91c3c01a9899e24db8cc683}{eye}} (N, M=None, k=0, dtype=float, order=\textquotesingle{}C\textquotesingle{}, \texorpdfstring{$\ast$}{*}device=None, like=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_afbd39976f16eb3a40645f6fe83cca289}{\+\_\+diag\+\_\+dispatcher}} (v, k=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a24e6f7b34764fe79678dbcc251aad80a}{diag}} (v, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a7458aec0138faa75d5775489d8bed1cb}{diagflat}} (v, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ad57f564b01ad252881b518825028fb7f}{tri}} (N, M=None, k=0, dtype=float, \texorpdfstring{$\ast$}{*}like=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a522aec48401145bb45f203feb85709d0}{\+\_\+trilu\+\_\+dispatcher}} (m, k=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a106ca7b058871ab021a10b4c848ac366}{tril}} (m, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a98f64e5dea5c08fe6836e71706725adb}{triu}} (m, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_acb44c61dcf1e417cf7a8367976482adf}{\+\_\+vander\+\_\+dispatcher}} (x, N=None, increasing=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aaff1a5d896c452c4e773d5b9de80b9e0}{vander}} (x, N=None, increasing=False)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_afde2c494686039ca8667ff80f56aef5c}{\+\_\+histogram2d\+\_\+dispatcher}} (x, y, bins=None, range=None, density=None, weights=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac0cbb2a476ddd21998c9bdc936fe4599}{histogram2d}} (x, y, bins=10, range=None, density=None, weights=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a04b53be555449f6a3aaabd4e4532f1b6}{mask\+\_\+indices}} (n, mask\+\_\+func, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_abf5b5227779e693e0a149f419fa41507}{tril\+\_\+indices}} (n, k=0, m=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a9dd5007f92123895309dbdc4185053bb}{\+\_\+trilu\+\_\+indices\+\_\+form\+\_\+dispatcher}} (arr, k=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a7be3b72921d778bd07b1bd3cd8f2149c}{tril\+\_\+indices\+\_\+from}} (arr, k=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a3efc7966afba38c0d2f10898cb9d34e4}{triu\+\_\+indices}} (n, k=0, m=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a25dc11b667ad7887a77d43515e04e1c0}{triu\+\_\+indices\+\_\+from}} (arr, k=0)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69}{array\+\_\+function\+\_\+dispatch}}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a3a1061abecdf7e7474d93b4b9379fd15}{i1}} = \mbox{\hyperlink{classnumpy_1_1__core_1_1getlimits_1_1iinfo}{iinfo}}(int8)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa1d29136f960358aa2e9190042d74783}{i2}} = \mbox{\hyperlink{classnumpy_1_1__core_1_1getlimits_1_1iinfo}{iinfo}}(int16)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a23c9c11c13128653df93dedecb528db3}{i4}} = \mbox{\hyperlink{classnumpy_1_1__core_1_1getlimits_1_1iinfo}{iinfo}}(int32)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a847ad85900962686c54f8f9fa5600d23}{\+\_\+eye\+\_\+with\+\_\+like}} = \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69}{array\+\_\+function\+\_\+dispatch}}()(\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac1c9f0c8c91c3c01a9899e24db8cc683}{eye}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_a1b6707e351b6122a44ad6e2be4bd9be5}{\+\_\+tri\+\_\+with\+\_\+like}} = \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69}{array\+\_\+function\+\_\+dispatch}}()(\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ad57f564b01ad252881b518825028fb7f}{tri}})
\end{DoxyCompactItemize}


\doxysubsection{Description détaillée}
\begin{DoxyVerb} Basic functions for manipulating 2d arrays\end{DoxyVerb}
 

\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_afbd39976f16eb3a40645f6fe83cca289}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_afbd39976f16eb3a40645f6fe83cca289} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_diag\_dispatcher@{\_diag\_dispatcher}}
\index{\_diag\_dispatcher@{\_diag\_dispatcher}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_diag\_dispatcher()}{\_diag\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+diag\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{v,  }\item[{}]{k = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_ae82dbb64545f177987b75dcd6e2331f1}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_ae82dbb64545f177987b75dcd6e2331f1} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_flip\_dispatcher@{\_flip\_dispatcher}}
\index{\_flip\_dispatcher@{\_flip\_dispatcher}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_flip\_dispatcher()}{\_flip\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+flip\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_afde2c494686039ca8667ff80f56aef5c}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_afde2c494686039ca8667ff80f56aef5c} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_histogram2d\_dispatcher@{\_histogram2d\_dispatcher}}
\index{\_histogram2d\_dispatcher@{\_histogram2d\_dispatcher}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_histogram2d\_dispatcher()}{\_histogram2d\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+histogram2d\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{bins = {\ttfamily None},  }\item[{}]{range = {\ttfamily None},  }\item[{}]{density = {\ttfamily None},  }\item[{}]{weights = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a33b3609fa9e1214de56289bf91856126}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a33b3609fa9e1214de56289bf91856126} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_min\_int@{\_min\_int}}
\index{\_min\_int@{\_min\_int}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_min\_int()}{\_min\_int()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+min\+\_\+int (\begin{DoxyParamCaption}\item[{}]{low,  }\item[{}]{high }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} get small int that fits the range \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a522aec48401145bb45f203feb85709d0}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a522aec48401145bb45f203feb85709d0} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_trilu\_dispatcher@{\_trilu\_dispatcher}}
\index{\_trilu\_dispatcher@{\_trilu\_dispatcher}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_trilu\_dispatcher()}{\_trilu\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+trilu\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{m,  }\item[{}]{k = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a9dd5007f92123895309dbdc4185053bb}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a9dd5007f92123895309dbdc4185053bb} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_trilu\_indices\_form\_dispatcher@{\_trilu\_indices\_form\_dispatcher}}
\index{\_trilu\_indices\_form\_dispatcher@{\_trilu\_indices\_form\_dispatcher}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_trilu\_indices\_form\_dispatcher()}{\_trilu\_indices\_form\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+trilu\+\_\+indices\+\_\+form\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{k = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_acb44c61dcf1e417cf7a8367976482adf}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_acb44c61dcf1e417cf7a8367976482adf} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_vander\_dispatcher@{\_vander\_dispatcher}}
\index{\_vander\_dispatcher@{\_vander\_dispatcher}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_vander\_dispatcher()}{\_vander\_dispatcher()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+vander\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{N = {\ttfamily None},  }\item[{}]{increasing = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a24e6f7b34764fe79678dbcc251aad80a}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a24e6f7b34764fe79678dbcc251aad80a} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!diag@{diag}}
\index{diag@{diag}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{diag()}{diag()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+diag (\begin{DoxyParamCaption}\item[{}]{v,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Extract a diagonal or construct a diagonal array.

See the more detailed documentation for ``numpy.diagonal`` if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.

Parameters
----------
v : array_like
    If `v` is a 2-D array, return a copy of its `k`-th diagonal.
    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
    diagonal.
k : int, optional
    Diagonal in question. The default is 0. Use `k>0` for diagonals
    above the main diagonal, and `k<0` for diagonals below the main
    diagonal.

Returns
-------
out : ndarray
    The extracted diagonal or constructed diagonal array.

See Also
--------
diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.

Examples
--------
>>> import numpy as np
>>> x = np.arange(9).reshape((3,3))
>>> x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

>>> np.diag(x)
array([0, 4, 8])
>>> np.diag(x, k=1)
array([1, 5])
>>> np.diag(x, k=-1)
array([3, 7])

>>> np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a7458aec0138faa75d5775489d8bed1cb}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a7458aec0138faa75d5775489d8bed1cb} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!diagflat@{diagflat}}
\index{diagflat@{diagflat}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{diagflat()}{diagflat()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+diagflat (\begin{DoxyParamCaption}\item[{}]{v,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a two-dimensional array with the flattened input as a diagonal.

Parameters
----------
v : array_like
    Input data, which is flattened and set as the `k`-th
    diagonal of the output.
k : int, optional
    Diagonal to set; 0, the default, corresponds to the "main" diagonal,
    a positive (negative) `k` giving the number of the diagonal above
    (below) the main.

Returns
-------
out : ndarray
    The 2-D output array.

See Also
--------
diag : MATLAB work-alike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.

Examples
--------
>>> import numpy as np
>>> np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])

>>> np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac1c9f0c8c91c3c01a9899e24db8cc683}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac1c9f0c8c91c3c01a9899e24db8cc683} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!eye@{eye}}
\index{eye@{eye}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{eye()}{eye()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+eye (\begin{DoxyParamCaption}\item[{}]{N,  }\item[{}]{M = {\ttfamily None},  }\item[{}]{k = {\ttfamily 0},  }\item[{}]{dtype = {\ttfamily float},  }\item[{}]{order = {\ttfamily \textquotesingle{}C\textquotesingle{}},  }\item[{\texorpdfstring{$\ast$}{*}}]{device = {\ttfamily None},  }\item[{}]{like = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a 2-D array with ones on the diagonal and zeros elsewhere.

Parameters
----------
N : int
  Number of rows in the output.
M : int, optional
  Number of columns in the output. If None, defaults to `N`.
k : int, optional
  Index of the diagonal: 0 (the default) refers to the main diagonal,
  a positive value refers to an upper diagonal, and a negative value
  to a lower diagonal.
dtype : data-type, optional
  Data-type of the returned array.
order : {'C', 'F'}, optional
    Whether the output should be stored in row-major (C-style) or
    column-major (Fortran-style) order in memory.
device : str, optional
    The device on which to place the created array. Default: None.
    For Array-API interoperability only, so must be ``"cpu"`` if passed.

    .. versionadded:: 2.0.0
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
I : ndarray of shape (N,M)
  An array where all elements are equal to zero, except for the `k`-th
  diagonal, whose values are equal to one.

See Also
--------
identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.

Examples
--------
>>> import numpy as np
>>> np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
>>> np.eye(3, k=1)
array([[0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a20b8ad70aadf04144596103fbcc44c51}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a20b8ad70aadf04144596103fbcc44c51} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!fliplr@{fliplr}}
\index{fliplr@{fliplr}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{fliplr()}{fliplr()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+fliplr (\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})}

\begin{DoxyVerb}Reverse the order of elements along axis 1 (left/right).

For a 2-D array, this flips the entries in each row in the left/right
direction. Columns are preserved, but appear in a different order than
before.

Parameters
----------
m : array_like
    Input array, must be at least 2-D.

Returns
-------
f : ndarray
    A view of `m` with the columns reversed.  Since a view
    is returned, this operation is :math:`\\mathcal O(1)`.

See Also
--------
flipud : Flip array in the up/down direction.
flip : Flip array in one or more dimensions.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``m[:,::-1]`` or ``np.flip(m, axis=1)``.
Requires the array to be at least 2-D.

Examples
--------
>>> import numpy as np
>>> A = np.diag([1.,2.,3.])
>>> A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
>>> np.fliplr(A)
array([[0.,  0.,  1.],
       [0.,  2.,  0.],
       [3.,  0.,  0.]])

>>> rng = np.random.default_rng()
>>> A = rng.normal(size=(2,3,5))
>>> np.all(np.fliplr(A) == A[:,::-1,...])
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a365de51a3c0cf6125053f930fe58f836}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a365de51a3c0cf6125053f930fe58f836} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!flipud@{flipud}}
\index{flipud@{flipud}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{flipud()}{flipud()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+flipud (\begin{DoxyParamCaption}\item[{}]{m }\end{DoxyParamCaption})}

\begin{DoxyVerb}Reverse the order of elements along axis 0 (up/down).

For a 2-D array, this flips the entries in each column in the up/down
direction. Rows are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
out : array_like
    A view of `m` with the rows reversed.  Since a view is
    returned, this operation is :math:`\\mathcal O(1)`.

See Also
--------
fliplr : Flip array in the left/right direction.
flip : Flip array in one or more dimensions.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``m[::-1, ...]`` or ``np.flip(m, axis=0)``.
Requires the array to be at least 1-D.

Examples
--------
>>> import numpy as np
>>> A = np.diag([1.0, 2, 3])
>>> A
array([[1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.]])
>>> np.flipud(A)
array([[0.,  0.,  3.],
       [0.,  2.,  0.],
       [1.,  0.,  0.]])

>>> rng = np.random.default_rng()
>>> A = rng.normal(size=(2,3,5))
>>> np.all(np.flipud(A) == A[::-1,...])
True

>>> np.flipud([1,2])
array([2, 1])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac0cbb2a476ddd21998c9bdc936fe4599}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac0cbb2a476ddd21998c9bdc936fe4599} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!histogram2d@{histogram2d}}
\index{histogram2d@{histogram2d}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{histogram2d()}{histogram2d()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+histogram2d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{bins = {\ttfamily 10},  }\item[{}]{range = {\ttfamily None},  }\item[{}]{density = {\ttfamily None},  }\item[{}]{weights = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the bi-dimensional histogram of two data samples.

Parameters
----------
x : array_like, shape (N,)
    An array containing the x coordinates of the points to be
    histogrammed.
y : array_like, shape (N,)
    An array containing the y coordinates of the points to be
    histogrammed.
bins : int or array_like or [int, int] or [array, array], optional
    The bin specification:

    * If int, the number of bins for the two dimensions (nx=ny=bins).
    * If array_like, the bin edges for the two dimensions
      (x_edges=y_edges=bins).
    * If [int, int], the number of bins in each dimension
      (nx, ny = bins).
    * If [array, array], the bin edges in each dimension
      (x_edges, y_edges = bins).
    * A combination [int, array] or [array, int], where int
      is the number of bins and array is the bin edges.

range : array_like, shape(2,2), optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
    will be considered outliers and not tallied in the histogram.
density : bool, optional
    If False, the default, returns the number of samples in each bin.
    If True, returns the probability *density* function at the bin,
    ``bin_count / sample_count / bin_area``.
weights : array_like, shape(N,), optional
    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
    Weights are normalized to 1 if `density` is True. If `density` is
    False, the values of the returned histogram are equal to the sum of
    the weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray, shape(nx, ny)
    The bi-dimensional histogram of samples `x` and `y`. Values in `x`
    are histogrammed along the first dimension and values in `y` are
    histogrammed along the second dimension.
xedges : ndarray, shape(nx+1,)
    The bin edges along the first dimension.
yedges : ndarray, shape(ny+1,)
    The bin edges along the second dimension.

See Also
--------
histogram : 1D histogram
histogramdd : Multidimensional histogram

Notes
-----
When `density` is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
``bin_value * bin_area`` is 1.

Please note that the histogram does not follow the Cartesian convention
where `x` values are on the abscissa and `y` values on the ordinate
axis.  Rather, `x` is histogrammed along the first dimension of the
array (vertical), and `y` along the second dimension of the array
(horizontal).  This ensures compatibility with `histogramdd`.

Examples
--------
>>> import numpy as np
>>> from matplotlib.image import NonUniformImage
>>> import matplotlib.pyplot as plt

Construct a 2-D histogram with variable bin width. First define the bin
edges:

>>> xedges = [0, 1, 3, 5]
>>> yedges = [0, 2, 3, 4, 6]

Next we create a histogram H with random bin content:

>>> x = np.random.normal(2, 1, 100)
>>> y = np.random.normal(1, 1, 100)
>>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
>>> # Histogram does not follow Cartesian convention (see Notes),
>>> # therefore transpose H for visualization purposes.
>>> H = H.T

:func:`imshow <matplotlib.pyplot.imshow>` can only display square bins:

>>> fig = plt.figure(figsize=(7, 3))
>>> ax = fig.add_subplot(131, title='imshow: square bins')
>>> plt.imshow(H, interpolation='nearest', origin='lower',
...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
<matplotlib.image.AxesImage object at 0x...>

:func:`pcolormesh <matplotlib.pyplot.pcolormesh>` can display actual edges:

>>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
...         aspect='equal')
>>> X, Y = np.meshgrid(xedges, yedges)
>>> ax.pcolormesh(X, Y, H)
<matplotlib.collections.QuadMesh object at 0x...>

:class:`NonUniformImage <matplotlib.image.NonUniformImage>` can be used to
display actual bin edges with interpolation:

>>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
>>> im = NonUniformImage(ax, interpolation='bilinear')
>>> xcenters = (xedges[:-1] + xedges[1:]) / 2
>>> ycenters = (yedges[:-1] + yedges[1:]) / 2
>>> im.set_data(xcenters, ycenters, H)
>>> ax.add_image(im)
>>> plt.show()

It is also possible to construct a 2-D histogram without specifying bin
edges:

>>> # Generate non-symmetric test data
>>> n = 10000
>>> x = np.linspace(1, 100, n)
>>> y = 2*np.log(x) + np.random.rand(n) - 0.5
>>> # Compute 2d histogram. Note the order of x/y and xedges/yedges
>>> H, yedges, xedges = np.histogram2d(y, x, bins=20)

Now we can plot the histogram using
:func:`pcolormesh <matplotlib.pyplot.pcolormesh>`, and a
:func:`hexbin <matplotlib.pyplot.hexbin>` for comparison.

>>> # Plot histogram using pcolormesh
>>> fig, (ax1, ax2) = plt.subplots(ncols=2, sharey=True)
>>> ax1.pcolormesh(xedges, yedges, H, cmap='rainbow')
>>> ax1.plot(x, 2*np.log(x), 'k-')
>>> ax1.set_xlim(x.min(), x.max())
>>> ax1.set_ylim(y.min(), y.max())
>>> ax1.set_xlabel('x')
>>> ax1.set_ylabel('y')
>>> ax1.set_title('histogram2d')
>>> ax1.grid()

>>> # Create hexbin plot for comparison
>>> ax2.hexbin(x, y, gridsize=20, cmap='rainbow')
>>> ax2.plot(x, 2*np.log(x), 'k-')
>>> ax2.set_title('hexbin')
>>> ax2.set_xlim(x.min(), x.max())
>>> ax2.set_xlabel('x')
>>> ax2.grid()

>>> plt.show()
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a04b53be555449f6a3aaabd4e4532f1b6}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a04b53be555449f6a3aaabd4e4532f1b6} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!mask\_indices@{mask\_indices}}
\index{mask\_indices@{mask\_indices}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{mask\_indices()}{mask\_indices()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+mask\+\_\+indices (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{mask\+\_\+func,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices to access (n, n) arrays, given a masking function.

Assume `mask_func` is a function that, for a square array a of size
``(n, n)`` with a possible offset argument `k`, when called as
``mask_func(a, k)`` returns a new array with zeros in certain locations
(functions like `triu` or `tril` do precisely this). Then this function
returns the indices where the non-zero values would be located.

Parameters
----------
n : int
    The returned indices will be valid to access arrays of shape (n, n).
mask_func : callable
    A function whose call signature is similar to that of `triu`, `tril`.
    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.
    `k` is an optional argument to the function.
k : scalar
    An optional argument which is passed through to `mask_func`. Functions
    like `triu`, `tril` take a second argument that is interpreted as an
    offset.

Returns
-------
indices : tuple of arrays.
    The `n` arrays of indices corresponding to the locations where
    ``mask_func(np.ones((n, n)), k)`` is True.

See Also
--------
triu, tril, triu_indices, tril_indices

Examples
--------
>>> import numpy as np

These are the indices that would allow you to access the upper triangular
part of any 3x3 array:

>>> iu = np.mask_indices(3, np.triu)

For example, if `a` is a 3x3 array:

>>> a = np.arange(9).reshape(3, 3)
>>> a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> a[iu]
array([0, 1, 2, 4, 5, 8])

An offset can be passed also to the masking function.  This gets us the
indices starting on the first diagonal right of the main one:

>>> iu1 = np.mask_indices(3, np.triu, 1)

with which we now extract only three elements:

>>> a[iu1]
array([1, 2, 5])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_ad57f564b01ad252881b518825028fb7f}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_ad57f564b01ad252881b518825028fb7f} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!tri@{tri}}
\index{tri@{tri}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{tri()}{tri()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+tri (\begin{DoxyParamCaption}\item[{}]{N,  }\item[{}]{M = {\ttfamily None},  }\item[{}]{k = {\ttfamily 0},  }\item[{}]{dtype = {\ttfamily float},  }\item[{\texorpdfstring{$\ast$}{*}}]{like = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}An array with ones at and below the given diagonal and zeros elsewhere.

Parameters
----------
N : int
    Number of rows in the array.
M : int, optional
    Number of columns in the array.
    By default, `M` is taken equal to `N`.
k : int, optional
    The sub-diagonal at and below which the array is filled.
    `k` = 0 is the main diagonal, while `k` < 0 is below it,
    and `k` > 0 is above.  The default is 0.
dtype : dtype, optional
    Data type of the returned array.  The default is float.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
tri : ndarray of shape (N, M)
    Array with its lower triangle filled with ones and zero elsewhere;
    in other words ``T[i,j] == 1`` for ``j <= i + k``, 0 otherwise.

Examples
--------
>>> import numpy as np
>>> np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])

>>> np.tri(3, 5, -1)
array([[0.,  0.,  0.,  0.,  0.],
       [1.,  0.,  0.,  0.,  0.],
       [1.,  1.,  0.,  0.,  0.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a106ca7b058871ab021a10b4c848ac366}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a106ca7b058871ab021a10b4c848ac366} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!tril@{tril}}
\index{tril@{tril}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{tril()}{tril()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+tril (\begin{DoxyParamCaption}\item[{}]{m,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Lower triangle of an array.

Return a copy of an array with elements above the `k`-th diagonal zeroed.
For arrays with ``ndim`` exceeding 2, `tril` will apply to the final two
axes.

Parameters
----------
m : array_like, shape (..., M, N)
    Input array.
k : int, optional
    Diagonal above which to zero elements.  `k = 0` (the default) is the
    main diagonal, `k < 0` is below it and `k > 0` is above.

Returns
-------
tril : ndarray, shape (..., M, N)
    Lower triangle of `m`, of same shape and data-type as `m`.

See Also
--------
triu : same thing, only for the upper triangle

Examples
--------
>>> import numpy as np
>>> np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])

>>> np.tril(np.arange(3*4*5).reshape(3, 4, 5))
array([[[ 0,  0,  0,  0,  0],
        [ 5,  6,  0,  0,  0],
        [10, 11, 12,  0,  0],
        [15, 16, 17, 18,  0]],
       [[20,  0,  0,  0,  0],
        [25, 26,  0,  0,  0],
        [30, 31, 32,  0,  0],
        [35, 36, 37, 38,  0]],
       [[40,  0,  0,  0,  0],
        [45, 46,  0,  0,  0],
        [50, 51, 52,  0,  0],
        [55, 56, 57, 58,  0]]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_abf5b5227779e693e0a149f419fa41507}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_abf5b5227779e693e0a149f419fa41507} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!tril\_indices@{tril\_indices}}
\index{tril\_indices@{tril\_indices}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{tril\_indices()}{tril\_indices()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+tril\+\_\+indices (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{k = {\ttfamily 0},  }\item[{}]{m = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices for the lower-triangle of an (n, m) array.

Parameters
----------
n : int
    The row dimension of the arrays for which the returned
    indices will be valid.
k : int, optional
    Diagonal offset (see `tril` for details).
m : int, optional
    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple of arrays
    The row and column indices, respectively. The row indices are sorted
    in non-decreasing order, and the correspdonding column indices are
    strictly increasing for each row.

See also
--------
triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu

Examples
--------
>>> import numpy as np

Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:

>>> il1 = np.tril_indices(4)
>>> il1
(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))

Note that row indices (first array) are non-decreasing, and the corresponding
column indices (second array) are strictly increasing for each row.
Here is how they can be used with a sample array:

>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

>>> a[il1]
array([ 0,  4,  5, ..., 13, 14, 15])

And for assigning values:

>>> a[il1] = -1
>>> a
array([[-1,  1,  2,  3],
       [-1, -1,  6,  7],
       [-1, -1, -1, 11],
       [-1, -1, -1, -1]])

These cover almost the whole array (two diagonals right of the main one):

>>> il2 = np.tril_indices(4, 2)
>>> a[il2] = -10
>>> a
array([[-10, -10, -10,   3],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a7be3b72921d778bd07b1bd3cd8f2149c}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a7be3b72921d778bd07b1bd3cd8f2149c} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!tril\_indices\_from@{tril\_indices\_from}}
\index{tril\_indices\_from@{tril\_indices\_from}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{tril\_indices\_from()}{tril\_indices\_from()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+tril\+\_\+indices\+\_\+from (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices for the lower-triangle of arr.

See `tril_indices` for full details.

Parameters
----------
arr : array_like
    The indices will be valid for square arrays whose dimensions are
    the same as arr.
k : int, optional
    Diagonal offset (see `tril` for details).

Examples
--------
>>> import numpy as np

Create a 4 by 4 array

>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Pass the array to get the indices of the lower triangular elements.

>>> trili = np.tril_indices_from(a)
>>> trili
(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))

>>> a[trili]
array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])

This is syntactic sugar for tril_indices().

>>> np.tril_indices(a.shape[0])
(array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]), array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))

Use the `k` parameter to return the indices for the lower triangular array
up to the k-th diagonal.

>>> trili1 = np.tril_indices_from(a, k=1)
>>> a[trili1]
array([ 0,  1,  4,  5,  6,  8,  9, 10, 11, 12, 13, 14, 15])

See Also
--------
tril_indices, tril, triu_indices_from
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a98f64e5dea5c08fe6836e71706725adb}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a98f64e5dea5c08fe6836e71706725adb} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!triu@{triu}}
\index{triu@{triu}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{triu()}{triu()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+triu (\begin{DoxyParamCaption}\item[{}]{m,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Upper triangle of an array.

Return a copy of an array with the elements below the `k`-th diagonal
zeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the
final two axes.

Please refer to the documentation for `tril` for further details.

See Also
--------
tril : lower triangle of an array

Examples
--------
>>> import numpy as np
>>> np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])

>>> np.triu(np.arange(3*4*5).reshape(3, 4, 5))
array([[[ 0,  1,  2,  3,  4],
        [ 0,  6,  7,  8,  9],
        [ 0,  0, 12, 13, 14],
        [ 0,  0,  0, 18, 19]],
       [[20, 21, 22, 23, 24],
        [ 0, 26, 27, 28, 29],
        [ 0,  0, 32, 33, 34],
        [ 0,  0,  0, 38, 39]],
       [[40, 41, 42, 43, 44],
        [ 0, 46, 47, 48, 49],
        [ 0,  0, 52, 53, 54],
        [ 0,  0,  0, 58, 59]]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a3efc7966afba38c0d2f10898cb9d34e4}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a3efc7966afba38c0d2f10898cb9d34e4} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!triu\_indices@{triu\_indices}}
\index{triu\_indices@{triu\_indices}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{triu\_indices()}{triu\_indices()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+triu\+\_\+indices (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{k = {\ttfamily 0},  }\item[{}]{m = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices for the upper-triangle of an (n, m) array.

Parameters
----------
n : int
    The size of the arrays for which the returned indices will
    be valid.
k : int, optional
    Diagonal offset (see `triu` for details).
m : int, optional
    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple, shape(2) of ndarrays, shape(`n`)
    The row and column indices, respectively. The row indices are sorted
    in non-decreasing order, and the correspdonding column indices are
    strictly increasing for each row.

See also
--------
tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril

Examples
--------
>>> import numpy as np

Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:

>>> iu1 = np.triu_indices(4)
>>> iu1
(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))

Note that row indices (first array) are non-decreasing, and the corresponding
column indices (second array) are strictly increasing for each row.

Here is how they can be used with a sample array:

>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

>>> a[iu1]
array([ 0,  1,  2, ..., 10, 11, 15])

And for assigning values:

>>> a[iu1] = -1
>>> a
array([[-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1]])

These cover only a small part of the whole array (two diagonals right
of the main one):

>>> iu2 = np.triu_indices(4, 2)
>>> a[iu2] = -10
>>> a
array([[ -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a25dc11b667ad7887a77d43515e04e1c0}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a25dc11b667ad7887a77d43515e04e1c0} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!triu\_indices\_from@{triu\_indices\_from}}
\index{triu\_indices\_from@{triu\_indices\_from}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{triu\_indices\_from()}{triu\_indices\_from()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+triu\+\_\+indices\+\_\+from (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{k = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices for the upper-triangle of arr.

See `triu_indices` for full details.

Parameters
----------
arr : ndarray, shape(N, N)
    The indices will be valid for square arrays.
k : int, optional
    Diagonal offset (see `triu` for details).

Returns
-------
triu_indices_from : tuple, shape(2) of ndarray, shape(N)
    Indices for the upper-triangle of `arr`.

Examples
--------
>>> import numpy as np

Create a 4 by 4 array

>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Pass the array to get the indices of the upper triangular elements.

>>> triui = np.triu_indices_from(a)
>>> triui
(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))

>>> a[triui]
array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])

This is syntactic sugar for triu_indices().

>>> np.triu_indices(a.shape[0])
(array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]), array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))

Use the `k` parameter to return the indices for the upper triangular array
from the k-th diagonal.

>>> triuim1 = np.triu_indices_from(a, k=1)
>>> a[triuim1]
array([ 1,  2,  3,  6,  7, 11])


See Also
--------
triu_indices, triu, tril_indices_from
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_aaff1a5d896c452c4e773d5b9de80b9e0}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_aaff1a5d896c452c4e773d5b9de80b9e0} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!vander@{vander}}
\index{vander@{vander}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{vander()}{vander()}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+vander (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{N = {\ttfamily None},  }\item[{}]{increasing = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
>>> import numpy as np
>>> x = np.array([1, 2, 3, 5])
>>> N = 3
>>> np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

>>> x = np.array([1, 2, 3, 5])
>>> np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
>>> np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

>>> np.linalg.det(np.vander(x))
48.000000000000043 # may vary
>>> (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48\end{DoxyVerb}
 

\doxysubsection{Documentation des variables}
\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a847ad85900962686c54f8f9fa5600d23}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a847ad85900962686c54f8f9fa5600d23} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_eye\_with\_like@{\_eye\_with\_like}}
\index{\_eye\_with\_like@{\_eye\_with\_like}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_eye\_with\_like}{\_eye\_with\_like}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+eye\+\_\+with\+\_\+like = \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69}{array\+\_\+function\+\_\+dispatch}}()(\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ac1c9f0c8c91c3c01a9899e24db8cc683}{eye}})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a1b6707e351b6122a44ad6e2be4bd9be5}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a1b6707e351b6122a44ad6e2be4bd9be5} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!\_tri\_with\_like@{\_tri\_with\_like}}
\index{\_tri\_with\_like@{\_tri\_with\_like}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{\_tri\_with\_like}{\_tri\_with\_like}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+\_\+tri\+\_\+with\+\_\+like = \mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69}{array\+\_\+function\+\_\+dispatch}}()(\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__twodim__base__impl_ad57f564b01ad252881b518825028fb7f}{tri}})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa5991ec5eebae7ce1133cc070e123c69} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!array\_function\_dispatch@{array\_function\_dispatch}}
\index{array\_function\_dispatch@{array\_function\_dispatch}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{array\_function\_dispatch}{array\_function\_dispatch}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+array\+\_\+function\+\_\+dispatch}

{\bfseries Valeur initiale \+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ functools.partial(}
\DoxyCodeLine{00002\ \ \ \ \ overrides.array\_function\_dispatch,\ module=\textcolor{stringliteral}{'numpy'})}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a3a1061abecdf7e7474d93b4b9379fd15}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a3a1061abecdf7e7474d93b4b9379fd15} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!i1@{i1}}
\index{i1@{i1}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{i1}{i1}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+i1 = \mbox{\hyperlink{classnumpy_1_1__core_1_1getlimits_1_1iinfo}{iinfo}}(int8)}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa1d29136f960358aa2e9190042d74783}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_aa1d29136f960358aa2e9190042d74783} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!i2@{i2}}
\index{i2@{i2}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{i2}{i2}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+i2 = \mbox{\hyperlink{classnumpy_1_1__core_1_1getlimits_1_1iinfo}{iinfo}}(int16)}

\Hypertarget{namespacenumpy_1_1lib_1_1__twodim__base__impl_a23c9c11c13128653df93dedecb528db3}\label{namespacenumpy_1_1lib_1_1__twodim__base__impl_a23c9c11c13128653df93dedecb528db3} 
\index{numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}!i4@{i4}}
\index{i4@{i4}!numpy.lib.\_twodim\_base\_impl@{numpy.lib.\_twodim\_base\_impl}}
\doxysubsubsection{\texorpdfstring{i4}{i4}}
{\footnotesize\ttfamily numpy.\+lib.\+\_\+twodim\+\_\+base\+\_\+impl.\+i4 = \mbox{\hyperlink{classnumpy_1_1__core_1_1getlimits_1_1iinfo}{iinfo}}(int32)}

