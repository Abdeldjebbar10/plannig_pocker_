\doxysection{Référence de l\textquotesingle{}espace de nommage numpy.\+polynomial.\+polyutils}
\hypertarget{namespacenumpy_1_1polynomial_1_1polyutils}{}\label{namespacenumpy_1_1polynomial_1_1polyutils}\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection*{Fonctions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a23749899d5d34b1fe47db966c5c0e124}{trimseq}} (seq)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a0840307978aa18cc7f32d51bdd081fcc}{as\+\_\+series}} (alist, trim=True)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a025dfde16a81b5a708e19f9ee6d51f47}{trimcoef}} (c, tol=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a91e7aa259a7aed6477d64f257d62c6e9}{getdomain}} (x)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_aa9b584b17644aef98a261f853d4abf24}{mapparms}} (old, new)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_afc444f9301156c1feba388b84361c090}{mapdomain}} (x, old, new)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a02e095d3d8e7ffeb8f3a537a50725b06}{\+\_\+nth\+\_\+slice}} (i, ndim)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a790aca2938a7084859a94804da6e16e7}{\+\_\+vander\+\_\+nd}} (vander\+\_\+fs, points, degrees)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a0d748690757115de27f84558f533e2a2}{\+\_\+vander\+\_\+nd\+\_\+flat}} (vander\+\_\+fs, points, degrees)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_acb6059b1257ef2ff2507d5639c97bfd7}{\+\_\+fromroots}} (line\+\_\+f, mul\+\_\+f, roots)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a4290d9d161c737230250acba6f57754f}{\+\_\+valnd}} (val\+\_\+f, c, \texorpdfstring{$\ast$}{*}args)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_aae985f1746c2d9109ffb923661697258}{\+\_\+gridnd}} (val\+\_\+f, c, \texorpdfstring{$\ast$}{*}args)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a85b13b9d0e58aa9ba4d8945e81866352}{\+\_\+div}} (mul\+\_\+f, c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_aa18d7d0c8ad6af445c1d4a164943dd2f}{\+\_\+add}} (c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a4c67758681e0827463c7b6b31dd109d9}{\+\_\+sub}} (c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a7ea2ef52659a4d83e456c6e7c19dbdb0}{\+\_\+fit}} (vander\+\_\+f, x, y, deg, rcond=None, full=False, w=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_aa67292b18f1c6bd0fc16fcd029be4789}{\+\_\+pow}} (mul\+\_\+f, c, pow, maxpower)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a38505ca4b0c39356bf045441af300b5c}{\+\_\+as\+\_\+int}} (x, desc)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1polyutils_a0aca55912f327f4c0e727c87f7655761}{format\+\_\+float}} (x, parens=False)
\end{DoxyCompactItemize}


\doxysubsection{Description détaillée}
\begin{DoxyVerb}Utility classes and functions for the polynomial modules.

This module provides: error and warning objects; a polynomial base class;
and some routines used in both the `polynomial` and `chebyshev` modules.

Functions
---------

.. autosummary::
   :toctree: generated/

   as_series    convert list of array_likes into 1-D arrays of common type.
   trimseq      remove trailing zeros.
   trimcoef     remove small trailing coefficients.
   getdomain    return the domain appropriate for a given set of abscissae.
   mapdomain    maps points between domains.
   mapparms     parameters of the linear map between domains.\end{DoxyVerb}
 

\doxysubsection{Documentation des fonctions}
\Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_aa18d7d0c8ad6af445c1d4a164943dd2f}\label{namespacenumpy_1_1polynomial_1_1polyutils_aa18d7d0c8ad6af445c1d4a164943dd2f} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_add@{\_add}}
\index{\_add@{\_add}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_add()}{\_add()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+add (\begin{DoxyParamCaption}\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} Helper function used to implement the ``<type>add`` functions. \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a38505ca4b0c39356bf045441af300b5c}\label{namespacenumpy_1_1polynomial_1_1polyutils_a38505ca4b0c39356bf045441af300b5c} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_as\_int@{\_as\_int}}
\index{\_as\_int@{\_as\_int}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_as\_int()}{\_as\_int()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+as\+\_\+int (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{desc }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Like `operator.index`, but emits a custom exception when passed an
incorrect type

Parameters
----------
x : int-like
    Value to interpret as an integer
desc : str
    description to include in any error message

Raises
------
TypeError : if x is a float or non-numeric
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a85b13b9d0e58aa9ba4d8945e81866352}\label{namespacenumpy_1_1polynomial_1_1polyutils_a85b13b9d0e58aa9ba4d8945e81866352} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_div@{\_div}}
\index{\_div@{\_div}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_div()}{\_div()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+div (\begin{DoxyParamCaption}\item[{}]{mul\+\_\+f,  }\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function used to implement the ``<type>div`` functions.

Implementation uses repeated subtraction of c2 multiplied by the nth basis.
For some polynomial types, a more efficient approach may be possible.

Parameters
----------
mul_f : function(array_like, array_like) -> array_like
    The ``<type>mul`` function, such as ``polymul``
c1, c2
    See the ``<type>div`` functions for more detail
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a7ea2ef52659a4d83e456c6e7c19dbdb0}\label{namespacenumpy_1_1polynomial_1_1polyutils_a7ea2ef52659a4d83e456c6e7c19dbdb0} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_fit@{\_fit}}
\index{\_fit@{\_fit}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_fit()}{\_fit()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+fit (\begin{DoxyParamCaption}\item[{}]{vander\+\_\+f,  }\item[{}]{x,  }\item[{}]{y,  }\item[{}]{deg,  }\item[{}]{rcond = {\ttfamily None},  }\item[{}]{full = {\ttfamily False},  }\item[{}]{w = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function used to implement the ``<type>fit`` functions.

Parameters
----------
vander_f : function(array_like, int) -> ndarray
    The 1d vander function, such as ``polyvander``
c1, c2
    See the ``<type>fit`` functions for more detail
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_acb6059b1257ef2ff2507d5639c97bfd7}\label{namespacenumpy_1_1polynomial_1_1polyutils_acb6059b1257ef2ff2507d5639c97bfd7} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_fromroots@{\_fromroots}}
\index{\_fromroots@{\_fromroots}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_fromroots()}{\_fromroots()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+fromroots (\begin{DoxyParamCaption}\item[{}]{line\+\_\+f,  }\item[{}]{mul\+\_\+f,  }\item[{}]{roots }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function used to implement the ``<type>fromroots`` functions.

Parameters
----------
line_f : function(float, float) -> ndarray
    The ``<type>line`` function, such as ``polyline``
mul_f : function(array_like, array_like) -> ndarray
    The ``<type>mul`` function, such as ``polymul``
roots
    See the ``<type>fromroots`` functions for more detail
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_aae985f1746c2d9109ffb923661697258}\label{namespacenumpy_1_1polynomial_1_1polyutils_aae985f1746c2d9109ffb923661697258} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_gridnd@{\_gridnd}}
\index{\_gridnd@{\_gridnd}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_gridnd()}{\_gridnd()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+gridnd (\begin{DoxyParamCaption}\item[{}]{val\+\_\+f,  }\item[{}]{c,  }\item[{\texorpdfstring{$\ast$}{*}}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function used to implement the ``<type>grid<n>d`` functions.

Parameters
----------
val_f : function(array_like, array_like, tensor: bool) -> array_like
    The ``<type>val`` function, such as ``polyval``
c, args
    See the ``<type>grid<n>d`` functions for more detail
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a02e095d3d8e7ffeb8f3a537a50725b06}\label{namespacenumpy_1_1polynomial_1_1polyutils_a02e095d3d8e7ffeb8f3a537a50725b06} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_nth\_slice@{\_nth\_slice}}
\index{\_nth\_slice@{\_nth\_slice}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_nth\_slice()}{\_nth\_slice()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+nth\+\_\+slice (\begin{DoxyParamCaption}\item[{}]{i,  }\item[{}]{ndim }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_aa67292b18f1c6bd0fc16fcd029be4789}\label{namespacenumpy_1_1polynomial_1_1polyutils_aa67292b18f1c6bd0fc16fcd029be4789} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_pow@{\_pow}}
\index{\_pow@{\_pow}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_pow()}{\_pow()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+pow (\begin{DoxyParamCaption}\item[{}]{mul\+\_\+f,  }\item[{}]{c,  }\item[{}]{pow,  }\item[{}]{maxpower }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function used to implement the ``<type>pow`` functions.

Parameters
----------
mul_f : function(array_like, array_like) -> ndarray
    The ``<type>mul`` function, such as ``polymul``
c : array_like
    1-D array of array of series coefficients
pow, maxpower
    See the ``<type>pow`` functions for more detail
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a4c67758681e0827463c7b6b31dd109d9}\label{namespacenumpy_1_1polynomial_1_1polyutils_a4c67758681e0827463c7b6b31dd109d9} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_sub@{\_sub}}
\index{\_sub@{\_sub}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_sub()}{\_sub()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+sub (\begin{DoxyParamCaption}\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} Helper function used to implement the ``<type>sub`` functions. \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a4290d9d161c737230250acba6f57754f}\label{namespacenumpy_1_1polynomial_1_1polyutils_a4290d9d161c737230250acba6f57754f} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_valnd@{\_valnd}}
\index{\_valnd@{\_valnd}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_valnd()}{\_valnd()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+valnd (\begin{DoxyParamCaption}\item[{}]{val\+\_\+f,  }\item[{}]{c,  }\item[{\texorpdfstring{$\ast$}{*}}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper function used to implement the ``<type>val<n>d`` functions.

Parameters
----------
val_f : function(array_like, array_like, tensor: bool) -> array_like
    The ``<type>val`` function, such as ``polyval``
c, args
    See the ``<type>val<n>d`` functions for more detail
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a790aca2938a7084859a94804da6e16e7}\label{namespacenumpy_1_1polynomial_1_1polyutils_a790aca2938a7084859a94804da6e16e7} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_vander\_nd@{\_vander\_nd}}
\index{\_vander\_nd@{\_vander\_nd}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_vander\_nd()}{\_vander\_nd()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+vander\+\_\+nd (\begin{DoxyParamCaption}\item[{}]{vander\+\_\+fs,  }\item[{}]{points,  }\item[{}]{degrees }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}A generalization of the Vandermonde matrix for N dimensions

The result is built by combining the results of 1d Vandermonde matrices,

.. math::
    W[i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_{k=0}^N{V_k(x_k)[i_0, \ldots, i_M, j_k]}

where

.. math::
    N &= \texttt{len(points)} = \texttt{len(degrees)} = \texttt{len(vander\_fs)} \\
    M &= \texttt{points[k].ndim} \\
    V_k &= \texttt{vander\_fs[k]} \\
    x_k &= \texttt{points[k]} \\
    0 \le j_k &\le \texttt{degrees[k]}

Expanding the one-dimensional :math:`V_k` functions gives:

.. math::
    W[i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_{k=0}^N{B_{k, j_k}(x_k[i_0, \ldots, i_M])}

where :math:`B_{k,m}` is the m'th basis of the polynomial construction used along
dimension :math:`k`. For a regular polynomial, :math:`B_{k, m}(x) = P_m(x) = x^m`.

Parameters
----------
vander_fs : Sequence[function(array_like, int) -> ndarray]
    The 1d vander function to use for each axis, such as ``polyvander``
points : Sequence[array_like]
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
    This must be the same length as `vander_fs`.
degrees : Sequence[int]
    The maximum degree (inclusive) to use for each axis.
    This must be the same length as `vander_fs`.

Returns
-------
vander_nd : ndarray
    An array of shape ``points[0].shape + tuple(d + 1 for d in degrees)``.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a0d748690757115de27f84558f533e2a2}\label{namespacenumpy_1_1polynomial_1_1polyutils_a0d748690757115de27f84558f533e2a2} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!\_vander\_nd\_flat@{\_vander\_nd\_flat}}
\index{\_vander\_nd\_flat@{\_vander\_nd\_flat}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{\_vander\_nd\_flat()}{\_vander\_nd\_flat()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+\_\+vander\+\_\+nd\+\_\+flat (\begin{DoxyParamCaption}\item[{}]{vander\+\_\+fs,  }\item[{}]{points,  }\item[{}]{degrees }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Like `_vander_nd`, but flattens the last ``len(degrees)`` axes into a single axis

Used to implement the public ``<type>vander<n>d`` functions.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a0840307978aa18cc7f32d51bdd081fcc}\label{namespacenumpy_1_1polynomial_1_1polyutils_a0840307978aa18cc7f32d51bdd081fcc} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!as\_series@{as\_series}}
\index{as\_series@{as\_series}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{as\_series()}{as\_series()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+as\+\_\+series (\begin{DoxyParamCaption}\item[{}]{alist,  }\item[{}]{trim = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return argument as a list of 1-d arrays.

The returned list contains array(s) of dtype double, complex double, or
object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of
size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays
of size ``N`` (i.e., is "parsed by row"); and a higher dimensional array
raises a Value Error if it is not first reshaped into either a 1-d or 2-d
array.

Parameters
----------
alist : array_like
    A 1- or 2-d array_like
trim : boolean, optional
    When True, trailing zeros are removed from the inputs.
    When False, the inputs are passed through intact.

Returns
-------
[a1, a2,...] : list of 1-D arrays
    A copy of the input data as a list of 1-d arrays.

Raises
------
ValueError
    Raised when `as_series` cannot convert its input to 1-d arrays, or at
    least one of the resulting arrays is empty.

Examples
--------
>>> import numpy as np
>>> from numpy.polynomial import polyutils as pu
>>> a = np.arange(4)
>>> pu.as_series(a)
[array([0.]), array([1.]), array([2.]), array([3.])]
>>> b = np.arange(6).reshape((2,3))
>>> pu.as_series(b)
[array([0., 1., 2.]), array([3., 4., 5.])]

>>> pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))
[array([1.]), array([0., 1., 2.]), array([0., 1.])]

>>> pu.as_series([2, [1.1, 0.]])
[array([2.]), array([1.1])]

>>> pu.as_series([2, [1.1, 0.]], trim=False)
[array([2.]), array([1.1, 0. ])]\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a0aca55912f327f4c0e727c87f7655761}\label{namespacenumpy_1_1polynomial_1_1polyutils_a0aca55912f327f4c0e727c87f7655761} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!format\_float@{format\_float}}
\index{format\_float@{format\_float}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{format\_float()}{format\_float()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+format\+\_\+float (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{parens = {\ttfamily False} }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a91e7aa259a7aed6477d64f257d62c6e9}\label{namespacenumpy_1_1polynomial_1_1polyutils_a91e7aa259a7aed6477d64f257d62c6e9} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!getdomain@{getdomain}}
\index{getdomain@{getdomain}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{getdomain()}{getdomain()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+getdomain (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a domain suitable for given abscissae.

Find a domain suitable for a polynomial or Chebyshev series
defined at the values supplied.

Parameters
----------
x : array_like
    1-d array of abscissae whose domain will be determined.

Returns
-------
domain : ndarray
    1-d array containing two values.  If the inputs are complex, then
    the two returned points are the lower left and upper right corners
    of the smallest rectangle (aligned with the axes) in the complex
    plane containing the points `x`. If the inputs are real, then the
    two points are the ends of the smallest interval containing the
    points `x`.

See Also
--------
mapparms, mapdomain

Examples
--------
>>> import numpy as np
>>> from numpy.polynomial import polyutils as pu
>>> points = np.arange(4)**2 - 5; points
array([-5, -4, -1,  4])
>>> pu.getdomain(points)
array([-5.,  4.])
>>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle
>>> pu.getdomain(c)
array([-1.-1.j,  1.+1.j])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_afc444f9301156c1feba388b84361c090}\label{namespacenumpy_1_1polynomial_1_1polyutils_afc444f9301156c1feba388b84361c090} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!mapdomain@{mapdomain}}
\index{mapdomain@{mapdomain}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{mapdomain()}{mapdomain()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+mapdomain (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{old,  }\item[{}]{new }\end{DoxyParamCaption})}

\begin{DoxyVerb}Apply linear map to input points.

The linear map ``offset + scale*x`` that maps the domain `old` to
the domain `new` is applied to the points `x`.

Parameters
----------
x : array_like
    Points to be mapped. If `x` is a subtype of ndarray the subtype
    will be preserved.
old, new : array_like
    The two domains that determine the map.  Each must (successfully)
    convert to 1-d arrays containing precisely two values.

Returns
-------
x_out : ndarray
    Array of points of the same shape as `x`, after application of the
    linear map between the two domains.

See Also
--------
getdomain, mapparms

Notes
-----
Effectively, this implements:

.. math::
    x\\_out = new[0] + m(x - old[0])

where

.. math::
    m = \\frac{new[1]-new[0]}{old[1]-old[0]}

Examples
--------
>>> import numpy as np
>>> from numpy.polynomial import polyutils as pu
>>> old_domain = (-1,1)
>>> new_domain = (0,2*np.pi)
>>> x = np.linspace(-1,1,6); x
array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])
>>> x_out = pu.mapdomain(x, old_domain, new_domain); x_out
array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary
        6.28318531])
>>> x - pu.mapdomain(x_out, new_domain, old_domain)
array([0., 0., 0., 0., 0., 0.])

Also works for complex numbers (and thus can be used to map any line in
the complex plane to any other line therein).

>>> i = complex(0,1)
>>> old = (-1 - i, 1 + i)
>>> new = (-1 + i, 1 - i)
>>> z = np.linspace(old[0], old[1], 6); z
array([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])
>>> new_z = pu.mapdomain(z, old, new); new_z
array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_aa9b584b17644aef98a261f853d4abf24}\label{namespacenumpy_1_1polynomial_1_1polyutils_aa9b584b17644aef98a261f853d4abf24} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!mapparms@{mapparms}}
\index{mapparms@{mapparms}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{mapparms()}{mapparms()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+mapparms (\begin{DoxyParamCaption}\item[{}]{old,  }\item[{}]{new }\end{DoxyParamCaption})}

\begin{DoxyVerb}Linear map parameters between domains.

Return the parameters of the linear map ``offset + scale*x`` that maps
`old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.

Parameters
----------
old, new : array_like
    Domains. Each domain must (successfully) convert to a 1-d array
    containing precisely two values.

Returns
-------
offset, scale : scalars
    The map ``L(x) = offset + scale*x`` maps the first domain to the
    second.

See Also
--------
getdomain, mapdomain

Notes
-----
Also works for complex numbers, and thus can be used to calculate the
parameters required to map any line in the complex plane to any other
line therein.

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.mapparms((-1,1),(-1,1))
(0.0, 1.0)
>>> pu.mapparms((1,-1),(-1,1))
(-0.0, -1.0)
>>> i = complex(0,1)
>>> pu.mapparms((-i,-1),(1,i))
((1+1j), (1-0j))\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a025dfde16a81b5a708e19f9ee6d51f47}\label{namespacenumpy_1_1polynomial_1_1polyutils_a025dfde16a81b5a708e19f9ee6d51f47} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!trimcoef@{trimcoef}}
\index{trimcoef@{trimcoef}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{trimcoef()}{trimcoef()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+trimcoef (\begin{DoxyParamCaption}\item[{}]{c,  }\item[{}]{tol = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Remove "small" "trailing" coefficients from a polynomial.

"Small" means "small in absolute value" and is controlled by the
parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
both the 3-rd and 4-th order coefficients would be "trimmed."

Parameters
----------
c : array_like
    1-d array of coefficients, ordered from lowest order to highest.
tol : number, optional
    Trailing (i.e., highest order) elements with absolute value less
    than or equal to `tol` (default value is zero) are removed.

Returns
-------
trimmed : ndarray
    1-d array with trailing zeros removed.  If the resulting series
    would be empty, a series containing a single zero is returned.

Raises
------
ValueError
    If `tol` < 0

Examples
--------
>>> from numpy.polynomial import polyutils as pu
>>> pu.trimcoef((0,0,3,0,5,0,0))
array([0.,  0.,  3.,  0.,  5.])
>>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
array([0.])
>>> i = complex(0,1) # works for complex
>>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
array([0.0003+0.j   , 0.001 -0.001j])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1polyutils_a23749899d5d34b1fe47db966c5c0e124}\label{namespacenumpy_1_1polynomial_1_1polyutils_a23749899d5d34b1fe47db966c5c0e124} 
\index{numpy.polynomial.polyutils@{numpy.polynomial.polyutils}!trimseq@{trimseq}}
\index{trimseq@{trimseq}!numpy.polynomial.polyutils@{numpy.polynomial.polyutils}}
\doxysubsubsection{\texorpdfstring{trimseq()}{trimseq()}}
{\footnotesize\ttfamily numpy.\+polynomial.\+polyutils.\+trimseq (\begin{DoxyParamCaption}\item[{}]{seq }\end{DoxyParamCaption})}

\begin{DoxyVerb}Remove small Poly series coefficients.

Parameters
----------
seq : sequence
    Sequence of Poly series coefficients.

Returns
-------
series : sequence
    Subsequence with trailing zeros removed. If the resulting sequence
    would be empty, return the first element. The returned sequence may
    or may not be a view.

Notes
-----
Do not lose the type info if the sequence contains unknown objects.\end{DoxyVerb}
 